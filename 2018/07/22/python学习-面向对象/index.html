<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="心小天个人博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://puguojing.com">
    <!--SEO-->

<meta name="description" content="生活不止coding,还有诗和远方。">



<meta name="keywords" content="心小天">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>Python学习笔记-面向对象 | 心小天个人博客</title>


    <link rel="alternate" href="/atom.xml" title="心小天个人博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="心小天">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://puguojing.com">心小天个人博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Python学习笔记-面向对象">
            
	            Python学习笔记-面向对象
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/python">
            python
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/Python" title="Python">
                        Python
                    </a>
                
                    <a href="/tags/面向对象" title="面向对象">
                        面向对象
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/07/22</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <p>&#8195;&#8195;</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>类：</strong>是我们抽象出来的属性的集合，是描述。<br><strong>实例：</strong>也叫做对象，是我们用类这个属性集合具体生成的实例。<br><strong>属性：</strong>定义在类中的方法或变量。<br><strong>实例属性：</strong>定义在具体方法中的属性（属性可以是方法也可以是变量），只用作当前的实例。<br><strong>类属性：</strong>类属性定义在类中且在函数体外，类属性被所有实例化的对象共有，类属性通常不作为实例属性使用。</p>
<h3 id="类的变量属性"><a href="#类的变量属性" class="headerlink" title="类的变量属性"></a>类的变量属性</h3><p>比如定义<strong>类变量</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class A():</span><br><span class="line">    var_1 = 1 #类的变量属性，可以使用类名和实例名调用</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">其中var_1这个变量指的就是A这个类的变量，他可以通过类名调用（比如：`A.var_1`），也可以通过实例名调用（比如：`a = A()    a.Var_1`）</span><br><span class="line">比如我们创建2个A类的实例：</span><br></pre></td></tr></table></figure>
<p>a1 = A()<br>a2 = A()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以使用实例名调用变量：</span><br></pre></td></tr></table></figure></p>
<p>a1.var_1  #值为1<br>a2.var_1  #值为1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也可以使用类名调用变量：</span><br></pre></td></tr></table></figure></p>
<p>A.var_1  #值为1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果单独修改a1.var_1或a2.var_1的值，则不会影响其他实例的var_1和类本身的var_1的值，但是如果修改A.var_1（类变量）的值，则所有的实例变量都会被改变。比如,如果把a.var_1的值修改为2，则b.var_1和A.var_1的值均不会改变，仍为1。但是如果把A.var_1的值修改为2则a.var_1和b.var_1的值都会变成2。</span><br><span class="line"></span><br><span class="line">### 实例的变量属性</span><br></pre></td></tr></table></figure></p>
<p>Class A():<br>    def <strong>init</strong>(self)<br>        self.var_1 = 1 #实例的变量属性，只可以使用实例名调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">创建2个实例：</span><br></pre></td></tr></table></figure></p>
<p>a1 = A()<br>a2 = A()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用实例名调用变量：</span><br></pre></td></tr></table></figure></p>
<p>a1.var_1  值为1<br>a2.var_1  值为1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用类名调用变量：</span><br></pre></td></tr></table></figure></p>
<p>A.var_1   #不可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 类属性和实例属性名不能设置成一样</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>class Student(object):<br>…     name = ‘Student’<br>…<br>s = Student() # 创建实例s<br>print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性<br>Student<br>print(Student.name) # 打印类的name属性<br>Student<br>s.name = ‘Michael’ # 给实例绑定name属性<br>print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性<br>Michael<br>print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问<br>Student<br>del s.name # 如果删除实例的name属性<br>print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了<br>Student<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</span><br><span class="line"></span><br><span class="line">### 实例的函数属性</span><br><span class="line">实例的函数属性一般函数的第一个参数是*self*,Pyhon会默认把函数的第一个参数当做指向类实例的参数，一般使用*self*，当然你也可以换成其他的名字，毕竟这个地方只是形参，但是一般从程序的可读性上而言我们不会那么做。</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>Class A():<br>    def func(self,a,b):<br>        print(a+b)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果我们想要调用func,则需要先实例化A这个类，然后使用实例化出来的对象调用：</span><br></pre></td></tr></table></figure>
<p>a = A()<br>a.fun(2,3)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是这里我们可不可以使用类名调用这个func函数呢，比如使用`A.func(2,3)`行不行呢,这当然是不行的。</span><br><span class="line"></span><br><span class="line">&gt;`“self，这里的self可以理解为C++中的this指针。遵循的原则就是：哪个实例调用我这个含有self的函数或变量，我这个函数或变量的self就代表哪个实例（指向哪个实例）。总结一句话：“谁调用就指向谁”`</span><br><span class="line"></span><br><span class="line">### 类方法</span><br><span class="line">类方法顾名思义就是指类的方法，而不是实例的方法，下面我们来看2个例子：</span><br></pre></td></tr></table></figure></p>
<p>Class A():<br>    def func(a,b):<br>        print(a+b)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们注意到这里的func没有使用self这个参数，那如果我们使用`a.fun(2,3)`这种调用会怎么样呢？答案是会报参数出错，因为在使用实例调用一个函数的时候，第一个参数会被默认是self，然而我们这里并没有定义这个参数。这里我们可以通过类名来调用这个参数`A.func(2,3)`,这样会成功。这里我们好像就是要使用类名调用函数了，看起来像是类的方法，但是通常我们不会这样做，而是采用@clasmethod装饰器的方法来定义类方法：</span><br></pre></td></tr></table></figure></p>
<p>Class A():<br>    @classmethod<br>    def func(cls,a,b):<br>        print(a+b)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先我们可以使用实例对象调用这个方法：</span><br></pre></td></tr></table></figure></p>
<p>a = A()<br>a.func(2,3)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也可以使用类名来调用这个方法：</span><br></pre></td></tr></table></figure></p>
<p>A.func(2,3)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里的方法默认会有一个cls的参数，用来表示当前的类（注意不是实例）。</span><br><span class="line"></span><br><span class="line">如果想在类的方法里面调用类的变量，可以使用cls:</span><br></pre></td></tr></table></figure></p>
<p>class A():</p>
<pre><code>num = 1
@classmethod
def func(cls):
    cls.num += 1#使用cls.num，而不能直接使用num
    print(&apos;cls.num:&apos;,cls.num)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意不管是使用类名调用类方法还是使用实例调用类方法所产生的结果都会相应影响：</span><br></pre></td></tr></table></figure>
<p>a = A()</p>
<p>print(‘A.num:’,A.num)<br>a.func()<br>print(‘A.num:’,A.num)<br>A.func()<br>print(‘A.num:’,A.num)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出的结果：</span><br></pre></td></tr></table></figure></p>
<p>A.num: 1<br>cls.num: 2<br>A.num: 2<br>cls.num: 3<br>A.num: 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">而且类方法中不能调用实例变量属性，比如：</span><br></pre></td></tr></table></figure></p>
<p>class A():<br>    def <strong>init</strong>(self):<br>        self.var = 0</p>
<pre><code>@classmethod
def func(cls):
    cls.var += 1
    print(cls.var)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">会报错:`AttributeError: type object &apos;A&apos; has no attribute &apos;var&apos;`</span><br><span class="line"></span><br><span class="line">### 静态方法</span><br><span class="line">定义静态方法使用`@staticmethod`，可以使用类名调用。静态方法不需要默认的任何参数,跟一般的普通函数类似.**通过这样的定义方式，我们可以在多个实例之间共享这个函数中的数据和内容。**静态方法无法访问实例变量。</span><br><span class="line"></span><br><span class="line">**类方法于静态方法**：</span><br><span class="line">&gt;</span><br><span class="line">1.类方法需要传递cls参数，静态方法不需要；</span><br><span class="line">2.静态方法和类方法都不可以访问实例变量；</span><br><span class="line">3.类方法可以通过cs访问类变量，静态方法不可以。</span><br></pre></td></tr></table></figure>
<p>class A():</p>
<pre><code>num = 1

@staticmethod
def func():#func中无法使用num
    a = 1
    print(&apos;&apos;,a)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以使用实例和类名调用：</span><br></pre></td></tr></table></figure>
<p>a = A()<br>A.func()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 继承</span><br><span class="line"></span><br><span class="line">继承分为单继承和多继承。**单继承：**子类只能继承一个父类。**多继承：**子类继承多个父类。</span><br><span class="line">#### 单继承：</span><br></pre></td></tr></table></figure></p>
<p>class A1(A):<br>    pass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以使用`A1.__base__`查看A1的基类</span><br></pre></td></tr></table></figure></p>
<p>class A1(A):<br>    def <strong>init</strong>(self):<br>        self.var = 1<br>        print(self.var)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A1是A的子类，如果A1中没有__init__（self）函数，默认会调用父类的__init__(self),如果子类重写了__init__(self),则不会调用父类的__init___(self)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 多继承：</span><br><span class="line">定义两个基类：</span><br></pre></td></tr></table></figure></p>
<p>class A():<br>    def <strong>init</strong>(self):<br>        print(‘this is A’)</p>
<p>class B():<br>    def <strong>init</strong>(self):<br>        print(‘this is B’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">定义一个子类C：</span><br></pre></td></tr></table></figure></p>
<p>class C(A,B):#注意继承顺序<br>    pass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实例化C这个类：</span><br></pre></td></tr></table></figure></p>
<p>c = C()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出是：</span><br></pre></td></tr></table></figure></p>
<p>this is B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">说明调用的是B的**__init__(self)**</span><br><span class="line"></span><br><span class="line">如果定义C这个类</span><br></pre></td></tr></table></figure></p>
<p>class C(B,A):<br>    pass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实例化C这个类输出是：</span><br></pre></td></tr></table></figure></p>
<p>this is A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">说明调用的是A的**__init__(self)**</span><br><span class="line"></span><br><span class="line">### Python 多继承调用父类的顺序：</span><br><span class="line">python调用父类构造的顺序是:*从左往右，从下往上*。采用的是广度优先搜索算法，总会先找离自己最近的一个节点。具体方法是:首先访问i这个节点，然后访问i所有未被访问的相邻节点。</span><br><span class="line"></span><br><span class="line">![14](http://pc59bkg3l.bkt.clouddn.com/14.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如图，访问顺序是：`9-&gt;7-&gt;8-&gt;3-&gt;4-&gt;5-&gt;6-&gt;1-&gt;2`</span><br></pre></td></tr></table></figure></p>
<p>#!/usr/bin/python3</p>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>class A(object):<br>    def <strong>init</strong>(self):<br>        print(‘A’)<br>        super(A, self).<strong>init</strong>()<br>class B(object):<br>    def <strong>init</strong>(self):<br>        print(‘B’)<br>        super(B, self).<strong>init</strong>()<br>class C(A):<br>    def <strong>init</strong>(self):<br>        print(‘C’)<br>        super(C, self).<strong>init</strong>()<br>class D(A):<br>    def <strong>init</strong>(self):<br>        print(‘D’)<br>        super(D, self).<strong>init</strong>()<br>class E(B,C):<br>    def <strong>init</strong>(self):<br>        print(‘E’)<br>        super(E, self).<strong>init</strong>()<br>class F(C,B,D):<br>    def <strong>init</strong>(self):<br>        print(‘F’)<br>        super(F, self).<strong>init</strong>()<br>class G(D,B):<br>    def <strong>init</strong>(self):<br>        print(‘G’)<br>        super(G, self).<strong>init</strong>()</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    g = G()<br>    print(G.mro())<br>    f = F()<br>    print(F.mro())<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果：</span><br></pre></td></tr></table></figure></p>
<p>G<br>D<br>A<br>B<br>[<class '__main__.g'="">, <class '__main__.d'="">, <class '__main__.a'="">, <class '__main__.b'="">, <class 'object'="">]<br>F<br>C<br>B<br>D<br>A<br>[<class '__main__.f'="">, <class '__main__.c'="">, <class '__main__.b'="">, <class '__main__.d'="">, <class '__main__.a'="">, <class 'object'="">]</class></class></class></class></class></class></class></class></class></class></class></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.如果每个类都有正确的写super(X, self).__init__()，那么mro顺序的所有的类的初始化方法都会执行一遍 </span><br><span class="line">2.如果中途有的类没有写或错误的写了super(X, self).__init__()，那么会按mro顺序执行到执行完没写的那个类，执行结束。 </span><br><span class="line">3.super(X, self)不是必须点__init__()，可以点别的，但一般没有这么做的 </span><br><span class="line">4.类名.mro可以得到mro的顺序 </span><br><span class="line">5.这种写法可以实现每个类都被执行有且仅有一次。</span><br><span class="line"></span><br><span class="line">####  静态语言VS动态语言的继承</span><br><span class="line"></span><br><span class="line">对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</span><br><span class="line"></span><br><span class="line">对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</span><br></pre></td></tr></table></figure>
<p>class Timer(object):<br>    def run(self):<br>        print(‘Start…’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;</span><br><span class="line">这就是动态语言的“**鸭子类型**”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</span><br><span class="line"></span><br><span class="line">Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</span><br><span class="line"></span><br><span class="line">&gt;</span><br><span class="line">继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</span><br><span class="line"></span><br><span class="line">&gt;动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的</span><br><span class="line"></span><br><span class="line">#### 获取对象的信息</span><br><span class="line"></span><br><span class="line">当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</span><br><span class="line"></span><br><span class="line">##### 用dir()</span><br><span class="line">如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>dir(‘ABC’)<br>[‘<strong>add</strong>‘, ‘<strong>class</strong>‘,…, ‘<strong>subclasshook</strong>‘, ‘capitalize’, ‘casefold’,…, ‘zfill’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>len(‘ABC’)<br>3<br>‘ABC’.<strong>len</strong>()<br>3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>class MyDog(object):<br>…     def <strong>len</strong>(self):<br>…         return 100<br>…<br>dog = MyDog()<br>len(dog)<br>100<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">剩下的都是普通属性或方法，比如lower()返回小写的字符串：</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘ABC’.lower()<br>‘abc’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### getattr()、setattr()以及hasattr()</span><br><span class="line"></span><br><span class="line">仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>class MyObject(object):<br>…     def <strong>init</strong>(self):<br>…         self.x = 9<br>…     def power(self):<br>…         return self.x * self.x<br>…<br>obj = MyObject()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">紧接着，可以测试该对象的属性：</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>hasattr(obj, ‘x’) # 有属性’x’吗？<br>True<br>obj.x<br>9<br>hasattr(obj, ‘y’) # 有属性’y’吗？<br>False<br>setattr(obj, ‘y’, 19) # 设置一个属性’y’<br>hasattr(obj, ‘y’) # 有属性’y’吗？<br>True<br>getattr(obj, ‘y’) # 获取属性’y’<br>19<br>obj.y # 获取属性’y’<br>19</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果试图获取不存在的属性，会抛出AttributeError的错误：</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>getattr(obj, ‘z’) # 获取属性’z’<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>AttributeError: ‘MyObject’ object has no attribute ‘z’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以传入一个default参数，如果属性不存在，就返回默认值：</span><br></pre></td></tr></table></figure></module></stdin></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>getattr(obj, ‘z’, 404) # 获取属性’z’，如果不存在，返回默认值404<br>404<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">也可以获得对象的方法：</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>hasattr(obj, ‘power’) # 有属性’power’吗？<br>True<br>getattr(obj, ‘power’) # 获取属性’power’</p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;bound method MyObject.power of &lt;<strong>main</strong>.MyObject object at 0x10077a6a0&gt;&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>fn = getattr(obj, ‘power’) # 获取属性’power’并赋值到变量fn<br>fn # fn指向obj.power</p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;bound method MyObject.power of &lt;<strong>main</strong>.MyObject object at 0x10077a6a0&gt;&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>fn() # 调用fn()与调用obj.power()是一样的<br>81</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 使用__slots__</span><br><span class="line">如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。</span><br><span class="line"></span><br><span class="line">为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：</span><br></pre></td></tr></table></figure>
<p>class Student(object):<br>    <strong>slots</strong> = (‘name’, ‘age’) # 用tuple定义允许绑定的属性名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，我们试试：</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = Student() # 创建新的实例<br>s.name = ‘Michael’ # 绑定属性’name’<br>s.age = 25 # 绑定属性’age’<br>s.score = 99 # 绑定属性’score’<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>AttributeError: ‘Student’ object has no attribute ‘score’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">由于&apos;score&apos;没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。</span><br><span class="line"></span><br><span class="line">使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</span><br></pre></td></tr></table></figure></module></stdin></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>class GraduateStudent(Student):<br>…     pass<br>…<br>g = GraduateStudent()<br>g.score = 9999<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">除非在子类中也定义__slots__，这样，**子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用@property</span><br><span class="line">在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>s = Student()<br>s.score = 9999<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</span><br></pre></td></tr></table></figure></p>
<p>class Student(object):</p>
<pre><code>def get_score(self):
     return self._score

def set_score(self, value):
    if not isinstance(value, int):
        raise ValueError(&apos;score must be an integer!&apos;)
    if value &lt; 0 or value &gt; 100:
        raise ValueError(&apos;score must between 0 ~ 100!&apos;)
    self._score = value
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>s = Student()<br>s.set_score(60) # ok!<br>s.get_score()<br>60<br>s.set_score(9999)<br>Traceback (most recent call last):<br>  …<br>ValueError: score must between 0 ~ 100!</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</span><br><span class="line"></span><br><span class="line">有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！</span><br><span class="line"></span><br><span class="line">还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：</span><br></pre></td></tr></table></figure>
<p>class Student(object):</p>
<pre><code>@property
def score(self):#变成属性调用读取属性
    return self._score

@score.setter
def score(self, value):#设置属性,使用：@方法名.setter
    if not isinstance(value, int):
        raise ValueError(&apos;score must be an integer!&apos;)
    if value &lt; 0 or value &gt; 100:
        raise ValueError(&apos;score must between 0 ~ 100!&apos;)
    self._score = value
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>s = Student()<br>s.score = 60 # OK，实际转化为s.set_score(60)<br>s.score # OK，实际转化为s.get_score()<br>60<br>s.score = 9999<br>Traceback (most recent call last):<br>  …<br>ValueError: score must between 0 ~ 100!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</span><br><span class="line"></span><br><span class="line">还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</span><br></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>class Student(object):</p>
<pre><code>@property
def birth(self):
    return self._birth

@birth.setter
def birth(self, value):
    self._birth = value

@property
def age(self):
    return 2015 - self._birth
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 枚举类</span><br></pre></td></tr></table></figure>
<p>from enum import Enum</p>
<p>#获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员<br>Month = Enum(‘Month’,(‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’, ‘Jun’, ‘Jul’, ‘Aug’, ‘Sep’, ‘Oct’, ‘Nov’, ‘Dec’))#</p>
<p>for name, member in Month.<strong>members</strong>.items():<br>    print(name, member, member.value)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出:</span><br></pre></td></tr></table></figure></p>
<p>Jan Month.Jan 1<br>Feb Month.Feb 2<br>Mar Month.Mar 3<br>Apr Month.Apr 4<br>May Month.May 5<br>Jun Month.Jun 6<br>Jul Month.Jul 7<br>Aug Month.Aug 8<br>Sep Month.Sep 9<br>Oct Month.Oct 10<br>Nov Month.Nov 11<br>Dec Month.Dec 12<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果想自己控制枚举的值，可以是使用派生类，继承Enum:</span><br></pre></td></tr></table></figure></p>
<p>from enum import Enum,unique</p>
<p>#自定义控制枚举数值，使用派生类，继承Enum<br>@unique<br>class WeekDay(Enum):<br>    Sun = 0 # Sun的value被设定为0<br>    Mon = 1<br>    Tue = 2<br>    Wed = 3<br>    Thu = 4<br>    Fri = 5<br>    Sat = 6</p>
<p>#有多种方法可以访问枚举<br>print(WeekDay.Sun)#WeekDay.Sun<br>print(WeekDay.Tue.value)#2<br>print(WeekDay[‘Wed’])#WeekDay.Wed<br>print(WeekDay(0))#WeekDay.Sun</p>
<p>for name, member in WeekDay.<strong>members</strong>.items():<br>    print(name, member, member.value)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果:</span><br></pre></td></tr></table></figure></p>
<p>WeekDay.Sun<br>2<br>WeekDay.Wed<br>WeekDay.Sun<br>Sun WeekDay.Sun 0<br>Mon WeekDay.Mon 1<br>Tue WeekDay.Tue 2<br>Wed WeekDay.Wed 3<br>Thu WeekDay.Thu 4<br>Fri WeekDay.Fri 5<br>Sat WeekDay.Sat 6<br><code>`</code></p>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>参考<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000" target="_blank" rel="noopener">[廖雪峰Python教程]</a></p>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            
                <span class="reward-type">
                    <img class="wechat" src="../img/reward-wepay.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/08/20/python学习-闭包函数、装饰器/" class="pre-post btn btn-default" title="python学习-闭包函数、装饰器">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">python学习-闭包函数、装饰器</span>
        </a>
    
    
        <a href="/2018/07/20/AboutMe/" class="next-post btn btn-default" title="AboutMe">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">AboutMe</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的变量属性"><span class="toc-text">类的变量属性</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#coding-utf-8"><span class="toc-text">-- coding:utf-8 --</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#元类"><span class="toc-text">元类</span></a></li></ol></li>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>