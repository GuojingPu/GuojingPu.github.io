<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="蒲国敬个人博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://puguojing.com">
    <!--SEO-->

<meta name="description" content="生活不止coding,还有诗和远方。">



<meta name="keywords" content="蒲国敬">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>Python学习笔记-面向对象 | 蒲国敬个人博客</title>


    <link rel="alternate" href="/atom.xml" title="蒲国敬个人博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="蒲国敬">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://puguojing.com">蒲国敬个人博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/技术"><i class="fa "></i>技术</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/随笔"><i class="fa "></i>随笔</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/工具"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Python学习笔记-面向对象">
            
	            Python学习笔记-面向对象
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/python">
            python
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/Python" title="Python">
                        Python
                    </a>
                
                    <a href="/tags/面向对象" title="面向对象">
                        面向对象
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/07/22</span>
        </span>
        
    
</div>

            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>599</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>&#8195;&#8195;</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>类：</strong>是我们抽象出来的属性的集合，是描述。<br><strong>实例：</strong>也叫做对象，是我们用类这个属性集合具体生成的实例。<br><strong>属性：</strong>定义在类中的方法或变量。<br><strong>实例属性：</strong>定义在具体方法中的属性（属性可以是方法也可以是变量），只用作当前的实例。<br><strong>类属性：</strong>类属性定义在类中且在函数体外，类属性被所有实例化的对象共有，类属性通常不作为实例属性使用。</p>
<h3 id="类的变量属性"><a href="#类的变量属性" class="headerlink" title="类的变量属性"></a>类的变量属性</h3><p>比如定义类变量: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class A():</span><br><span class="line">    var_1 = 1 #类的变量属性，可以使用类名和实例名调用</span><br></pre></td></tr></table></figure>
<p>其中var_1这个变量指的就是A这个类的变量，他可以通过类名调用（比如：A.var_1），也可以通过实例名调用（比如：a = A()    a.Var_1）<br>比如我们创建2个A类的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br></pre></td></tr></table></figure>
<p>我们可以使用实例名调用变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1.var_1  #值为1</span><br><span class="line">a2.var_1  #值为1</span><br></pre></td></tr></table></figure>
<p>也可以使用类名调用变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.var_1  #值为1</span><br></pre></td></tr></table></figure>
<p>如果单独修改a1.var_1或a2.var_1的值，则不会影响其他实例的var_1和类本身的var_1的值，但是如果修改A.var_1（类变量）的值，则所有的实例变量都会被改变。比如,如果把a.var_1的值修改为2，则b.var_1和A.var_1的值均不会改变，仍为1。但是如果把A.var_1的值修改为2则a.var_1和b.var_1的值都会变成2。</p>
<h3 id="实例的变量属性"><a href="#实例的变量属性" class="headerlink" title="实例的变量属性"></a>实例的变量属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class A():</span><br><span class="line">    def __init__(self)</span><br><span class="line">        self.var_1 = 1 #实例的变量属性，只可以使用实例名调用</span><br></pre></td></tr></table></figure>
<p>创建2个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br></pre></td></tr></table></figure>
<p>使用实例名调用变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1.var_1  值为1</span><br><span class="line">a2.var_1  值为1</span><br></pre></td></tr></table></figure>
<p>使用类名调用变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.var_1   #不可以使用</span><br></pre></td></tr></table></figure>
<h3 id="类属性和实例属性名不能设置成一样"><a href="#类属性和实例属性名不能设置成一样" class="headerlink" title="类属性和实例属性名不能设置成一样"></a>类属性和实例属性名不能设置成一样</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name = &apos;Student&apos;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建实例s</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 打印类的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name # 如果删除实例的name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line">Student</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<h3 id="实例的函数属性"><a href="#实例的函数属性" class="headerlink" title="实例的函数属性"></a>实例的函数属性</h3><p>实例的函数属性一般函数的第一个参数是<em>self</em>,Pyhon会默认把函数的第一个参数当做指向类实例的参数，一般使用<em>self</em>，当然你也可以换成其他的名字，毕竟这个地方只是形参，但是一般从程序的可读性上而言我们不会那么做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class A():</span><br><span class="line">    def func(self,a,b):</span><br><span class="line">        print(a+b)</span><br></pre></td></tr></table></figure>
<p>如果我们想要调用func,则需要先实例化A这个类，然后使用实例化出来的对象调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = A()</span><br><span class="line">a.fun(2,3)</span><br></pre></td></tr></table></figure>
<p>但是这里我们可不可以使用类名调用这个func函数呢，比如使用<code>A.func(2,3)</code>行不行呢,这当然是不行的。</p>
<blockquote>
<p><code>“self，这里的self可以理解为C++中的this指针。遵循的原则就是：哪个实例调用我这个含有self的函数或变量，我这个函数或变量的self就代表哪个实例（指向哪个实例）。总结一句话：“谁调用就指向谁”</code></p>
</blockquote>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类方法顾名思义就是指类的方法，而不是实例的方法，下面我们来看2个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class A():</span><br><span class="line">    def func(a,b):</span><br><span class="line">        print(a+b)</span><br></pre></td></tr></table></figure>
<p>我们注意到这里的func没有使用self这个参数，那如果我们使用<code>a.fun(2,3)</code>这种调用会怎么样呢？答案是会报参数出错，因为在使用实例调用一个函数的时候，第一个参数会被默认是self，然而我们这里并没有定义这个参数。这里我们可以通过类名来调用这个参数<code>A.func(2,3)</code>,这样会成功。这里我们好像就是要使用类名调用函数了，看起来像是类的方法，但是通常我们不会这样做，而是采用@clasmethod装饰器的方法来定义类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class A():</span><br><span class="line">    @classmethod</span><br><span class="line">    def func(cls,a,b):</span><br><span class="line">        print(a+b)</span><br></pre></td></tr></table></figure>
<p>首先我们可以使用实例对象调用这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = A()</span><br><span class="line">a.func(2,3)</span><br></pre></td></tr></table></figure>
<p>也可以使用类名来调用这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.func(2,3)</span><br></pre></td></tr></table></figure>
<p>这里的方法默认会有一个cls的参数，用来表示当前的类（注意不是实例）。</p>
<p>如果想在类的方法里面调用类的变量，可以使用cls:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A():</span><br><span class="line"></span><br><span class="line">    num = 1</span><br><span class="line">    @classmethod</span><br><span class="line">    def func(cls):</span><br><span class="line">        cls.num += 1#使用cls.num，而不能直接使用num</span><br><span class="line">        print(&apos;cls.num:&apos;,cls.num)</span><br></pre></td></tr></table></figure>
<p>注意不管是使用类名调用类方法还是使用实例调用类方法所产生的结果都会相应影响：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line">print(&apos;A.num:&apos;,A.num)</span><br><span class="line">a.func()</span><br><span class="line">print(&apos;A.num:&apos;,A.num)</span><br><span class="line">A.func()</span><br><span class="line">print(&apos;A.num:&apos;,A.num)</span><br></pre></td></tr></table></figure>
<p>输出的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A.num: 1</span><br><span class="line">cls.num: 2</span><br><span class="line">A.num: 2</span><br><span class="line">cls.num: 3</span><br><span class="line">A.num: 3</span><br></pre></td></tr></table></figure>
<p>而且类方法中不能调用实例变量属性，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.var = 0</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def func(cls):</span><br><span class="line">        cls.var += 1</span><br><span class="line">        print(cls.var)</span><br></pre></td></tr></table></figure>
<p>会报错:<code>AttributeError: type object &#39;A&#39; has no attribute &#39;var&#39;</code></p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>定义静态方法使用<code>@staticmethod</code>，可以使用类名调用。静态方法不需要默认的任何参数,跟一般的普通函数类似.<strong>通过这样的定义方式，我们可以在多个实例之间共享这个函数中的数据和内容。</strong>静态方法无法访问实例变量。</p>
<p><strong>类方法于静态方法</strong>：</p>
<blockquote>
</blockquote>
<p>1.类方法需要传递cls参数，静态方法不需要；<br>2.静态方法和类方法都不可以访问实例变量；<br>3.类方法可以通过cs访问类变量，静态方法不可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A():</span><br><span class="line"></span><br><span class="line">    num = 1</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def func():#func中无法使用num</span><br><span class="line">        a = 1</span><br><span class="line">        print(&apos;&apos;,a)</span><br></pre></td></tr></table></figure>
<p>可以使用实例和类名调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = A()</span><br><span class="line">A.func()</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承分为单继承和多继承。<strong>单继承：</strong>子类只能继承一个父类。<strong>多继承：</strong>子类继承多个父类。</p>
<h4 id="单继承："><a href="#单继承：" class="headerlink" title="单继承："></a>单继承：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class A1(A):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>可以使用<code>A1.__base__</code>查看A1的基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A1(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.var = 1</span><br><span class="line">        print(self.var)</span><br></pre></td></tr></table></figure>
<p>A1是A的子类，如果A1中没有<strong>init</strong>（self）函数，默认会调用父类的<strong>init</strong>(self),如果子类重写了<strong>init</strong>(self),则不会调用父类的<strong>init_</strong>(self)。</p>
<h4 id="多继承："><a href="#多继承：" class="headerlink" title="多继承："></a>多继承：</h4><p>定义两个基类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;this is A&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;this is B&apos;)</span><br></pre></td></tr></table></figure>
<p>定义一个子类C：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class C(A,B):#注意继承顺序</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>实例化C这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = C()</span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is B</span><br></pre></td></tr></table></figure>
<p>说明调用的是B的<strong><strong>init</strong>(self)</strong></p>
<p>如果定义C这个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class C(B,A):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>实例化C这个类输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is A</span><br></pre></td></tr></table></figure>
<p>说明调用的是A的<strong><strong>init</strong>(self)</strong></p>
<h3 id="Python-多继承调用父类的顺序："><a href="#Python-多继承调用父类的顺序：" class="headerlink" title="Python 多继承调用父类的顺序："></a>Python 多继承调用父类的顺序：</h3><p>python调用父类构造的顺序是:<em>从左往右，从下往上</em>。采用的是广度优先搜索算法，总会先找离自己最近的一个节点。具体方法是:首先访问i这个节点，然后访问i所有未被访问的相邻节点。</p>
<p><img src="http://pc59bkg3l.bkt.clouddn.com/14.png" alt="14"></p>
<p>如图，访问顺序是：<code>9-&gt;7-&gt;8-&gt;3-&gt;4-&gt;5-&gt;6-&gt;1-&gt;2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">class A(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;A&apos;)</span><br><span class="line">        super(A, self).__init__()</span><br><span class="line">class B(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;B&apos;)</span><br><span class="line">        super(B, self).__init__()</span><br><span class="line">class C(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;C&apos;)</span><br><span class="line">        super(C, self).__init__()</span><br><span class="line">class D(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;D&apos;)</span><br><span class="line">        super(D, self).__init__()</span><br><span class="line">class E(B,C):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;E&apos;)</span><br><span class="line">        super(E, self).__init__()</span><br><span class="line">class F(C,B,D):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;F&apos;)</span><br><span class="line">        super(F, self).__init__()</span><br><span class="line">class G(D,B):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&apos;G&apos;)</span><br><span class="line">        super(G, self).__init__()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    g = G()</span><br><span class="line">    print(G.mro())</span><br><span class="line">    f = F()</span><br><span class="line">    print(F.mro())</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">G</span><br><span class="line">D</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">[&lt;class &apos;__main__.G&apos;&gt;, &lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;object&apos;&gt;]</span><br><span class="line">F</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">A</span><br><span class="line">[&lt;class &apos;__main__.F&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;object&apos;&gt;]</span><br></pre></td></tr></table></figure>
<p>1.如果每个类都有正确的写super(X, self).<strong>init</strong>()，那么mro顺序的所有的类的初始化方法都会执行一遍<br>2.如果中途有的类没有写或错误的写了super(X, self).<strong>init</strong>()，那么会按mro顺序执行到执行完没写的那个类，执行结束。<br>3.super(X, self)不是必须点<strong>init</strong>()，可以点别的，但一般没有这么做的<br>4.类名.mro可以得到mro的顺序<br>5.这种写法可以实现每个类都被执行有且仅有一次。</p>
<h4 id="静态语言VS动态语言的继承"><a href="#静态语言VS动态语言的继承" class="headerlink" title="静态语言VS动态语言的继承"></a>静态语言VS动态语言的继承</h4><p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Timer(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Start...&apos;)</span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<p>这就是动态语言的“<strong>鸭子类型</strong>”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p>
<blockquote>
</blockquote>
<p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</p>
<blockquote>
<p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的</p>
</blockquote>
<h4 id="获取对象的信息"><a href="#获取对象的信息" class="headerlink" title="获取对象的信息"></a>获取对象的信息</h4><p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</p>
<h5 id="用dir"><a href="#用dir" class="headerlink" title="用dir()"></a>用dir()</h5><p>如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(&apos;ABC&apos;)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;]</span><br></pre></td></tr></table></figure>
<p>类似<strong>xxx</strong>的属性和方法在Python中都是有特殊用途的，比如<strong>len</strong>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<strong>len</strong>()方法，所以，下面的代码是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>我们自己写的类，如果也想用len(myObj)的话，就自己写一个<strong>len</strong>()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyDog(object):</span><br><span class="line">...     def __len__(self):</span><br><span class="line">...         return 100</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; dog = MyDog()</span><br><span class="line">&gt;&gt;&gt; len(dog)</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<p>剩下的都是普通属性或方法，比如lower()返回小写的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.lower()</span><br><span class="line">&apos;abc&apos;</span><br></pre></td></tr></table></figure>
<h5 id="getattr-、setattr-以及hasattr"><a href="#getattr-、setattr-以及hasattr" class="headerlink" title="getattr()、setattr()以及hasattr()"></a>getattr()、setattr()以及hasattr()</h5><p>仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyObject(object):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.x = 9</span><br><span class="line">...     def power(self):</span><br><span class="line">...         return self.x * self.x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; obj = MyObject()</span><br></pre></td></tr></table></figure>
<p>紧接着，可以测试该对象的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; obj.x</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;</span><br><span class="line">19</span><br></pre></td></tr></table></figure>
<p>如果试图获取不存在的属性，会抛出AttributeError的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, &apos;z&apos;) # 获取属性&apos;z&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;MyObject&apos; object has no attribute &apos;z&apos;</span><br></pre></td></tr></table></figure>
<p>可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, &apos;z&apos;, 404) # 获取属性&apos;z&apos;，如果不存在，返回默认值404</span><br><span class="line">404</span><br></pre></td></tr></table></figure>
<p>也可以获得对象的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;power&apos;) # 有属性&apos;power&apos;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &apos;power&apos;) # 获取属性&apos;power&apos;</span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn = getattr(obj, &apos;power&apos;) # 获取属性&apos;power&apos;并赋值到变量fn</span><br><span class="line">&gt;&gt;&gt; fn # fn指向obj.power</span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的</span><br><span class="line">81</span><br></pre></td></tr></table></figure>
<h4 id="使用slots"><a href="#使用slots" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h4><p>如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。</p>
<p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<strong>slots</strong>变量，来限制该class实例能添加的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</span><br></pre></td></tr></table></figure>
<p>然后，我们试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student() # 创建新的实例</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;</span><br><span class="line">&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;</span><br><span class="line">&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos;</span><br></pre></td></tr></table></figure>
<p>由于’score’没有被放到<strong>slots</strong>中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。</p>
<p>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class GraduateStudent(Student):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; g = GraduateStudent()</span><br><span class="line">&gt;&gt;&gt; g.score = 9999</span><br></pre></td></tr></table></figure>
<p>除非在子类中也定义<strong>slots</strong>，这样，<strong>子类实例允许定义的属性就是自身的<strong>slots</strong>加上父类的<strong>slots</strong>。</strong></p>
<h4 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h4><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student()</span><br><span class="line">s.score = 9999</span><br></pre></td></tr></table></figure>
<p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">         return self._score</span><br><span class="line"></span><br><span class="line">    def set_score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>
<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.set_score(60) # ok!</span><br><span class="line">&gt;&gt;&gt; s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.set_score(9999)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure>
<p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>
<p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！</p>
<p>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):#变成属性调用读取属性</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):#设置属性,使用：@方法名.setter</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>
<p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)</span><br><span class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.score = 9999</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure>
<p>注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def birth(self):</span><br><span class="line">        return self._birth</span><br><span class="line"></span><br><span class="line">    @birth.setter</span><br><span class="line">    def birth(self, value):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return 2015 - self._birth</span><br></pre></td></tr></table></figure>
<p>上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。</p>
<p>小结<br>@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p>
<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">#获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员</span><br><span class="line">Month = Enum(&apos;Month&apos;,(&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for name, member in Month.__members__.items():</span><br><span class="line">    print(name, member, member.value)</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jan Month.Jan 1</span><br><span class="line">Feb Month.Feb 2</span><br><span class="line">Mar Month.Mar 3</span><br><span class="line">Apr Month.Apr 4</span><br><span class="line">May Month.May 5</span><br><span class="line">Jun Month.Jun 6</span><br><span class="line">Jul Month.Jul 7</span><br><span class="line">Aug Month.Aug 8</span><br><span class="line">Sep Month.Sep 9</span><br><span class="line">Oct Month.Oct 10</span><br><span class="line">Nov Month.Nov 11</span><br><span class="line">Dec Month.Dec 12</span><br></pre></td></tr></table></figure>
<p>如果想自己控制枚举的值，可以是使用派生类，继承Enum:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum,unique</span><br><span class="line">#自定义控制枚举数值，使用派生类，继承Enum</span><br><span class="line">@unique</span><br><span class="line">class WeekDay(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br><span class="line"></span><br><span class="line">#有多种方法可以访问枚举</span><br><span class="line">print(WeekDay.Sun)#WeekDay.Sun</span><br><span class="line">print(WeekDay.Tue.value)#2</span><br><span class="line">print(WeekDay[&apos;Wed&apos;])#WeekDay.Wed</span><br><span class="line">print(WeekDay(0))#WeekDay.Sun</span><br><span class="line"></span><br><span class="line">for name, member in WeekDay.__members__.items():</span><br><span class="line">    print(name, member, member.value)</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WeekDay.Sun</span><br><span class="line">2</span><br><span class="line">WeekDay.Wed</span><br><span class="line">WeekDay.Sun</span><br><span class="line">Sun WeekDay.Sun 0</span><br><span class="line">Mon WeekDay.Mon 1</span><br><span class="line">Tue WeekDay.Tue 2</span><br><span class="line">Wed WeekDay.Wed 3</span><br><span class="line">Thu WeekDay.Thu 4</span><br><span class="line">Fri WeekDay.Fri 5</span><br><span class="line">Sat WeekDay.Sat 6</span><br></pre></td></tr></table></figure>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>参考<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000" target="_blank" rel="noopener">[廖雪峰Python教程]</a></p>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/reward-wepay.jpg"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="https://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/reward-wepay.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">谢谢你的赞赏</p>
</div>


    
    <div class="post-footer">
        <div>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/08/20/python学习-闭包函数、装饰器/" class="pre-post btn btn-default" title="python学习-闭包函数、装饰器">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">python学习-闭包函数、装饰器</span>
        </a>
    
    
        <a href="/2018/07/20/ Python学习笔记-正则表达式（1）/" class="next-post btn btn-default" title="Python学习笔记-正则表达式（1）">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Python学习笔记-正则表达式（1）</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'nRczxBYhHdsdxxz5Xanbp1Me-gzGzoHsz',
            appKey: '8yPer27HUdgsdNqfDBiMuUyo',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的变量属性"><span class="toc-text">类的变量属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例的变量属性"><span class="toc-text">实例的变量属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类属性和实例属性名不能设置成一样"><span class="toc-text">类属性和实例属性名不能设置成一样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例的函数属性"><span class="toc-text">实例的函数属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类方法"><span class="toc-text">类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单继承："><span class="toc-text">单继承：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多继承："><span class="toc-text">多继承：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-多继承调用父类的顺序："><span class="toc-text">Python 多继承调用父类的顺序：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态语言VS动态语言的继承"><span class="toc-text">静态语言VS动态语言的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取对象的信息"><span class="toc-text">获取对象的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#用dir"><span class="toc-text">用dir()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getattr-、setattr-以及hasattr"><span class="toc-text">getattr()、setattr()以及hasattr()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用slots"><span class="toc-text">使用slots</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-property"><span class="toc-text">使用@property</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#枚举类"><span class="toc-text">枚举类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元类"><span class="toc-text">元类</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




    <script src="/assets/tagcanvas.min.js?rev=2.9"></script>
    <script>
        var tagOption = {
            textColour: '#444', // 字体颜色
            outlineMethod: 'block', // 选中模式
            outlineColour: '#FFDAB9', // 选中模式的颜色
            interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
            textHeight: 13,
            outlineRadius: 3,
            freezeActive: true || '', // 选中的标签是否继续滚动
            frontSelect: true || '', // 不选标签云后部的标签
            initial: [0.1, -0.1],
            depth: 0.5,
            decel: 0.95,
            maxSpeed: 0.03,
            reverse: true || '', // 是否反向触发
            fadeIn: 500, // 进入动画时间
            wheelZoom: false || '' // 是否启用鼠标滚轮
        }
        TagCanvas.Start('tag-cloud-3d','',tagOption);
    </script>




<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>