<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蒲国敬个人博客</title>
  
  <subtitle>生活不止coding,还有诗和远方。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://puguojing.com/"/>
  <updated>2019-05-12T10:05:08.188Z</updated>
  <id>http://puguojing.com/</id>
  
  <author>
    <name>蒲国敬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http协议数据结构分析</title>
    <link href="http://puguojing.com/2019/05/12/http%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://puguojing.com/2019/05/12/http协议数据结构分析/</id>
    <published>2019-05-12T10:00:45.000Z</published>
    <updated>2019-05-12T10:05:08.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议数据结构分析"><a href="#HTTP协议数据结构分析" class="headerlink" title="HTTP协议数据结构分析"></a>HTTP协议数据结构分析</h3><p>一：网络协议HHTP</p><p>　　超文本传输协议</p><p>　　RFC2616</p><p>二：HTTP报文主要结构</p><p>　　1)Request</p><p>　　　　Method(get,post) —请求方式</p><p>　　　　URL——-请求地址</p><p>　　　　Header——请求头</p><p>　　　　Body——–请求体</p><p>　　2)Response</p><p>　　　　Status Code——-状态码</p><p>　　　　Header——–响应头</p><p>　　　　Body——–响应体</p><p>三：HTTP状态码</p><p>　　200：成功，这个成功只是表示服务器正常处理完成了，并不能表示逻辑的正确性</p><p>　　301，320：跳转，一般可以在header中看到location，即跳转地址，区别是一个是临时跳转一个是固定跳转</p><p>　　304：未修改，服务器发现资源文件标识未变动，通知客户端读取本地缓存文件即可</p><p>　　400：客户端请求信息格式问题</p><p>　　403：一般是禁止访问，比如文件，目录等存在，但做了访问限制</p><p>　　404：一般为文件，目录不存在，但也可以将其他情况伪装成为不存在</p><p>　　500：出现这个一般都是服务端的代码直接抛出异常导致</p><p>　　502，503，504：这个类似，在网络异常等情况下都可以出现，也有很多代码抛出错误时候出现</p><p>四：HTTP常规Header信息与作用（Request）</p><p>　　Host：必须存在，域名指定（类似与分类，但端口用于区分访问那个域名）</p><p>　　Accept：表示自身可接受的信息类容，类似建议，有子项</p><p>　　User-Agent：客户端标识信息（系统版本，浏览器，内核等）</p><p>　　Cookie：特殊的信息存储位置，用于自动交互，无需代码干涉</p><p>　　Referer：来源，即通过什么页面或文件触发的请求，如果是浏览器地址栏回车则没有该值</p><p>　　Connection：控制长短链接，告诉对方当前链接状态（Keep-Alive，Close）</p><p>　　Range：指定返回信息范围（断点持续子类使用）</p><p>　　Content-Type：请求正文的类型，编码等信息</p><p>　　Content-Length：请求正文长度</p><p>　　If-Modifiled-Since：缓存相关，本地文件的标识有效期</p><p>　　If-None-Match：缓存相关，本地文件的特征码，对应返回信息中的ETag</p><p>五：HTTP常规Header信息与作用（Reaponse）</p><p>　　Date：时间，一般是服务器当前时间</p><p>　　Content-Encoding：返回正文的压缩编码类型</p><p>　　Content-Length：返回正文的长度</p><p>　　Content-Type：返回正文的类型，编码等信息</p><p>　　Cache-Control：缓存机制以及策略，时间，方式等</p><p>　　Etag：返回文件信息的特征码</p><p>　　Expires：返回文件信息的缓存有限期</p><p>　　Set-Cookie：要求设置的Cookie，可以多次出现的头信息</p><p>　　Location：自动重定向到其他新的地址，一般状态301，302时会出现</p><p>　　Connection：控制长短链接，告诉对方当前链接状态，默认Keep，当双方都为Keep时则链接会在下次沿用</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">General:</span><br><span class="line">Request URL: https://www.runoob.com/wp-content/themes/runoob/assets/images/qrcode.png</span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: 200 OK (from memory cache)</span><br><span class="line">Remote Address: 211.138.124.224:443</span><br><span class="line">Referrer Policy: no-referrer-when-downgrade</span><br><span class="line"></span><br><span class="line">Resoponse-Headers:</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Age: 33743</span><br><span class="line">Ali-Swift-Global-Savetime: 1556273201</span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 12595</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Date: Sat, 11 May 2019 17:08:02 GMT</span><br><span class="line">EagleId: d38a7cce15576282256397552e</span><br><span class="line">Etag: &quot;59f41d3a-3133&quot;</span><br><span class="line">Expires: Sat, 11 May 2019 10:41:15 GMT</span><br><span class="line">Last-Modified: Sat, 28 Oct 2017 06:01:30 GMT</span><br><span class="line">Server: Tengine</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Via: cache1.l2cm9[111,304-0,C], cache46.l2cm9[113,0], cache6.cn456[0,200-0,H], cache6.cn456[1,0]</span><br><span class="line">X-Cache: HIT TCP_MEM_HIT dirn:5:87260959</span><br><span class="line">X-M-Log: QNM:xs1167;QNM3</span><br><span class="line">X-M-Reqid: byYAAFmhB_Xtr50V</span><br><span class="line">X-Qnm-Cache: Hit</span><br><span class="line">X-Swift-CacheTime: 86400</span><br><span class="line">X-Swift-SaveTime: Sat, 11 May 2019 17:08:02 GMT</span><br><span class="line"></span><br><span class="line">Request-Headers:</span><br><span class="line">Provisional headers are shown</span><br><span class="line">Referer: https://www.runoob.com/html/html-tutorial.html</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP协议数据结构分析&quot;&gt;&lt;a href=&quot;#HTTP协议数据结构分析&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议数据结构分析&quot;&gt;&lt;/a&gt;HTTP协议数据结构分析&lt;/h3&gt;&lt;p&gt;一：网络协议HHTP&lt;/p&gt;
&lt;p&gt;　　超文本传输协议&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HTTP" scheme="http://puguojing.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04安装mongodb企业版</title>
    <link href="http://puguojing.com/2019/03/24/ubuntu16-04%E5%AE%89%E8%A3%85mongodb%E4%BC%81%E4%B8%9A%E7%89%88/"/>
    <id>http://puguojing.com/2019/03/24/ubuntu16-04安装mongodb企业版/</id>
    <published>2019-03-24T06:13:12.000Z</published>
    <updated>2019-03-24T10:20:38.757Z</updated>
    
    <content type="html"><![CDATA[<p>#MongoDB企业版在ubuntu16.04安装<br>安装方法参考官网：<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-ubuntu/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-ubuntu/</a></p><p>打开终端一次运行下面指令：<br>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [ arch=amd64,arm64,ppc64el,s390x ] http://repo.mongodb.com/apt/ubuntu xenial/mongodb-enterprise/4.0 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-enterprise.list</span><br></pre></td></tr></table></figure><p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><p>4.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y mongodb-enterprise</span><br></pre></td></tr></table></figure></p><p>5.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y mongodb-enterprise=4.0.6 mongodb-enterprise-server=4.0.6 mongodb-enterprise-shell=4.0.6 mongodb-enterprise-mongos=4.0.6 mongodb-enterprise-tools=4.0.6</span><br></pre></td></tr></table></figure><p>6.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;mongodb-enterprise hold&quot; | sudo dpkg --set-selections</span><br><span class="line">echo &quot;mongodb-enterprise-server hold&quot; | sudo dpkg --set-selections</span><br><span class="line">echo &quot;mongodb-enterprise-shell hold&quot; | sudo dpkg --set-selections</span><br><span class="line">echo &quot;mongodb-enterprise-mongos hold&quot; | sudo dpkg --set-selections</span><br><span class="line">echo &quot;mongodb-enterprise-tools hold&quot; | sudo dpkg --set-selections</span><br></pre></td></tr></table></figure><p>安装完成。</p><p>####默认的data和log的位置：</p><p>data的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">its data files in /var/lib/mongodb</span><br></pre></td></tr></table></figure><p>Log的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/mongodb/mongod.log</span><br></pre></td></tr></table></figure><p>#####启动与停止：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod start</span><br><span class="line">sudo service mongod stop</span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure><p>连接Mongodb：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><h4 id="根据配置文件启动mongodb"><a href="#根据配置文件启动mongodb" class="headerlink" title="根据配置文件启动mongodb"></a>根据配置文件启动mongodb</h4><p>使用配置文件启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod  --config /etc/mongod.conf</span><br></pre></td></tr></table></figure><p>默认的mongodb配置文件/etc/mongod.conf </p><p>####开启远程认证连接：</p><p>首先配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindIp: 127.0.0.1 改为 bindIp: 0.0.0.0 或者 bindIp: [127.0.0.1,mongo所在服务器ip]</span><br></pre></td></tr></table></figure><p>注意冒号后面有空格。</p><p>之后重启MOngoDB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service  mongod  restart</span><br></pre></td></tr></table></figure><p>然后在浏览器输入mongodb所在的服务器地址加端口号可以有如下显示：</p><p><img src="http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/QQ20190324-0.png" alt=""></p><h4 id="开启认证"><a href="#开启认证" class="headerlink" title="开启认证:"></a>开启认证:</h4><p>1.（可以省略）进入 admin数据库（默认创建）下创建一个用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use admin;</span><br><span class="line">db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;12345678&quot;,roles:[&#123;role:&quot;root&quot;,db:&quot;admin&quot;&#125;]&#125;)</span><br></pre></td></tr></table></figure><p><img src="http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/QQ20190324-3.png" alt=""></p><p>admin是MOngoDB默认的用来管理的数据库，我们这个用户拥有所有的权限。可以不创建。</p><p>2。我们往往需要创建一个自己使用的数据库，并添加用户和权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use movies;</span><br><span class="line">db.movies.insert(&quot;name&quot;:&quot;test&quot;&#125;);</span><br><span class="line"> db.createUser(&#123;user:&quot;pgj&quot;,pwd:&quot;1234556&quot;,roles:[&#123;role:&quot;readWrite&quot;,db:&quot;movies&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>注意这里<code>use movies;</code>之后会自动创建movies数据库，但是使用<code>show dbs;</code>指令无法显示，需要插入一条数据之后才会显示出来。</p><p>创建用户时：user和pwd表示创建的用户名和密码，role表示这个用户的操作权限，root表示最高，db表示要操作的是哪个数据库。</p><p>关键role的值可以选择下面：</p><p><img src="http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/447370-20171117151015562-892340916.png" alt=""></p><p>创建成功后会像admin一样打印成功信息，并显示创建的信息。</p><p>创建完成之后需要重启MOngoDB，这时候注意需要加上  –auth 参数 同时 –fork 表示在后台运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config  /etc/mongod.conf --auth --fork</span><br></pre></td></tr></table></figure><p><img src="http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/ewwewq34234234324.png" alt=""></p><h4 id="使用Robot3T连接"><a href="#使用Robot3T连接" class="headerlink" title="使用Robot3T连接"></a>使用Robot3T连接</h4><p><img src="http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/QQ20190324-181251@2x.png" alt=""></p><p><img src="http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/QQ20190324-181311@2x.png" alt=""><br><img src="http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/QQ20190324-181420@2x.png" alt=""></p><p>####配置文件说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#日志文件位置</span><br><span class="line">logpath=/data/db/journal/mongodb.log　　（这些都是可以自定义修改的）</span><br><span class="line"></span><br><span class="line"># 以追加方式写入日志</span><br><span class="line">logappend=true</span><br><span class="line"></span><br><span class="line"># 是否以守护进程方式运行</span><br><span class="line">fork = true</span><br><span class="line"></span><br><span class="line"># 默认27017</span><br><span class="line">#port = 27017</span><br><span class="line"></span><br><span class="line"># 数据库文件位置</span><br><span class="line">dbpath=/data/db</span><br><span class="line"></span><br><span class="line"># 启用定期记录CPU利用率和 I/O 等待</span><br><span class="line">#cpu = true</span><br><span class="line"></span><br><span class="line"># 是否以安全认证方式运行，默认是不认证的非安全方式</span><br><span class="line">#noauth = true</span><br><span class="line">#auth = true</span><br><span class="line"></span><br><span class="line"># 详细记录输出</span><br><span class="line">#verbose = true</span><br><span class="line"></span><br><span class="line"># Inspect all client data for validity on receipt (useful for</span><br><span class="line"># developing drivers)用于开发驱动程序时验证客户端请求</span><br><span class="line">#objcheck = true</span><br><span class="line"></span><br><span class="line"># Enable db quota management</span><br><span class="line"># 启用数据库配额管理</span><br><span class="line">#quota = true</span><br><span class="line"># 设置oplog记录等级</span><br><span class="line"># Set oplogging level where n is</span><br><span class="line">#   0=off (default)</span><br><span class="line">#   1=W</span><br><span class="line">#   2=R</span><br><span class="line">#   3=both</span><br><span class="line">#   7=W+some reads</span><br><span class="line">#diaglog=0</span><br><span class="line"></span><br><span class="line"># Diagnostic/debugging option 动态调试项</span><br><span class="line">#nocursors = true</span><br><span class="line"></span><br><span class="line"># Ignore query hints 忽略查询提示</span><br><span class="line">#nohints = true</span><br><span class="line"># 禁用http界面，默认为localhost：28017</span><br><span class="line">#nohttpinterface = true</span><br><span class="line"></span><br><span class="line"># 关闭服务器端脚本，这将极大的限制功能</span><br><span class="line"># Turns off server-side scripting.  This will result in greatly limited</span><br><span class="line"># functionality</span><br><span class="line">#noscripting = true</span><br><span class="line"># 关闭扫描表，任何查询将会是扫描失败</span><br><span class="line"># Turns off table scans.  Any query that would do a table scan fails.</span><br><span class="line">#notablescan = true</span><br><span class="line"># 关闭数据文件预分配</span><br><span class="line"># Disable data file preallocation.</span><br><span class="line">#noprealloc = true</span><br><span class="line"># 为新数据库指定.ns文件的大小，单位:MB</span><br><span class="line"># Specify .ns file size for new databases.</span><br><span class="line"># nssize =</span><br><span class="line"></span><br><span class="line"># Replication Options 复制选项</span><br><span class="line"># in replicated mongo databases, specify the replica set name here</span><br><span class="line">#replSet=setname</span><br><span class="line"># maximum size in megabytes for replication operation log</span><br><span class="line">#oplogSize=1024</span><br><span class="line"># path to a key file storing authentication info for connections</span><br><span class="line"># between replica set members</span><br><span class="line">#指定存储身份验证信息的密钥文件的路径</span><br><span class="line">#keyFile=/path/to/keyfile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#MongoDB企业版在ubuntu16.04安装&lt;br&gt;安装方法参考官网：&lt;a href=&quot;https://docs.mongodb.com/manual/tutorial/install-mongodb-enterprise-on-ubuntu/&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mongodb" scheme="http://puguojing.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>django数据库查询related_name和related_query_name</title>
    <link href="http://puguojing.com/2019/03/09/django%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2related-name%E5%92%8Crelated-query-name/"/>
    <id>http://puguojing.com/2019/03/09/django数据库查询related-name和related-query-name/</id>
    <published>2019-03-09T07:41:41.000Z</published>
    <updated>2019-03-09T07:46:23.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="related-name和related-query-name："><a href="#related-name和related-query-name：" class="headerlink" title="related_name和related_query_name："></a>related_name和related_query_name：</h3><p>有如下模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class User(models.Model):</span><br><span class="line">    username = models.CharField(max_length=20)</span><br><span class="line">    password = models.CharField(max_length=100)</span><br><span class="line"></span><br><span class="line">class Article(models.Model):</span><br><span class="line">    title = models.CharField(max_length=100)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    author = models.ForeignKey(&quot;User&quot;,on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><h5 id="related-name："><a href="#related-name：" class="headerlink" title="related_name："></a>related_name：</h5><p>还是以User和Article为例来进行说明。如果一个article想要访问对应的作者，那么可以通过author来进行访问。但是如果有一个user对象，想要通过这个user对象获取所有的文章，该如何做呢？这时候可以通过user.article_set来访问，这个名字的规律是模型名字小写_set。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user = User.objects.get(name=&apos;张三&apos;)</span><br><span class="line">user.article_set.all()</span><br></pre></td></tr></table></figure><p>如果不想使用模型名字小写_set的方式，想要使用其他的名字，那么可以在定义模型的时候指定related_name。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Article(models.Model):</span><br><span class="line">    title = models.CharField(max_length=100)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    # 传递related_name参数，以后在方向引用的时候使用articles进行访问</span><br><span class="line">    author = models.ForeignKey(&quot;User&quot;,on_delete=models.SET_NULL,null=True,related_name=&apos;articles&apos;)</span><br></pre></td></tr></table></figure><p>以后在方向引用的时候。使用articles可以访问到这个作者的文章模型。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user = User.objects.get(name=&apos;张三&apos;)</span><br><span class="line">user.articles.all()</span><br><span class="line">如果不想使用反向引用，那么可以指定related_name=&apos;+&apos;。示例代码如下：</span><br><span class="line"></span><br><span class="line">class Article(models.Model):</span><br><span class="line">    title = models.CharField(max_length=100)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    # 传递related_name参数，以后在方向引用的时候使用articles进行访问</span><br><span class="line">    author = models.ForeignKey(&quot;User&quot;,on_delete=models.SET_NULL,null=True,related_name=&apos;+&apos;)</span><br></pre></td></tr></table></figure><p>以后将不能通过user.article_set来访问文章模型了。</p><p>####related_query_name：<br>在查找数据的时候，可以使用filter进行过滤。使用filter过滤的时候，不仅仅可以指定本模型上的某个属性要满足什么条件，还可以指定相关联的模型满足什么属性。比如现在想要获取写过标题为abc的所有用户，那么可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">users = User.objects.filter(article__title=&apos;abc&apos;)</span><br></pre></td></tr></table></figure><p>如果你设置了related_name为articles，因为反转的过滤器的名字将使用related_name的名字，那么上例代码将改成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">users = User.objects.filter(articles__title=&apos;abc&apos;)</span><br></pre></td></tr></table></figure><p>可以通过related_query_name将查询的反转名字修改成其他的名字。比如article。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Article(models.Model):</span><br><span class="line">    title = models.CharField(max_length=100)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    # 传递related_name参数，以后在方向引用的时候使用articles进行访问</span><br><span class="line">    author = models.ForeignKey(&quot;User&quot;,on_delete=models.SET_NULL,null=True,related_name=&apos;articles&apos;,related_query_name=&apos;article&apos;)</span><br></pre></td></tr></table></figure><p>那么在做反向过滤查找的时候就可以使用以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">users = User.objects.filter(article__title=&apos;abc&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;related-name和related-query-name：&quot;&gt;&lt;a href=&quot;#related-name和related-query-name：&quot; class=&quot;headerlink&quot; title=&quot;related_name和related_query_n
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Django" scheme="http://puguojing.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置</title>
    <link href="http://puguojing.com/2019/02/27/Nginx%E9%85%8D%E7%BD%AE/"/>
    <id>http://puguojing.com/2019/02/27/Nginx配置/</id>
    <published>2019-02-27T03:56:27.000Z</published>
    <updated>2019-03-01T03:57:10.923Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">main                                # 全局配置</span><br><span class="line"></span><br><span class="line">events &#123;                            # nginx工作模式配置</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;                                # http设置</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    server &#123;                        # 服务器主机配置</span><br><span class="line">        ....</span><br><span class="line">        location &#123;                    # 路由配置</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location path &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location otherpath &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        location &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream name &#123;                    # 负载均衡配置</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述配置文件所示，主要由6个部分组成：</p><p>1.main：用于进行nginx全局信息的配置<br>2.events：用于nginx工作模式的配置<br>3.http：用于进行http协议信息的一些配置<br>4.server：用于进行服务器访问信息的配置<br>5.location：用于进行访问路由的配置<br>6.upstream：用于进行负载均衡的配置</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># user nobody nobody;</span><br><span class="line">worker_processes 2;</span><br><span class="line"># error_log logs/error.log</span><br><span class="line"># error_log logs/error.log notice</span><br><span class="line"># error_log logs/error.log info</span><br><span class="line"># pid logs/nginx.pid</span><br><span class="line">worker_rlimit_nofile 1024;</span><br></pre></td></tr></table></figure><p>上述配置都是存放在main全局配置模块中的配置项</p><p>1.user用来指定nginx worker进程运行用户以及用户组，默认nobody账号运行<br>2.worker_processes指定nginx要开启的子进程数量，运行过程中监控每个进程消耗内存(一般几M~几十M不等)根据实际情况进行调整，通常数量是CPU内核数量的整数倍<br>3.error_log定义错误日志文件的位置及输出级别【debug / info / notice / warn / error / crit】<br>4.pid用来指定进程id的存储文件的位置<br>5.worker_rlimit_nofile用于指定一个进程可以打开最多文件数量的描述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;nginx配置&quot;&gt;&lt;a href=&quot;#nginx配置&quot; class=&quot;headerlink&quot; title=&quot;nginx配置&quot;&gt;&lt;/a&gt;nginx配置&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="http://puguojing.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>keras的fit和fit_generate</title>
    <link href="http://puguojing.com/2019/01/16/keras%E7%9A%84fit%E5%92%8Cfit-generate/"/>
    <id>http://puguojing.com/2019/01/16/keras的fit和fit-generate/</id>
    <published>2019-01-16T12:32:08.000Z</published>
    <updated>2019-03-01T03:57:10.925Z</updated>
    
    <content type="html"><![CDATA[<h3 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(X_train, y_train, epochs=50, batch_size=128)</span><br></pre></td></tr></table></figure><p>各参数含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#fit参数详情</span><br><span class="line">keras.models.fit(</span><br><span class="line">self,</span><br><span class="line">x=None, #训练数据</span><br><span class="line">y=None, #训练数据label标签</span><br><span class="line">batch_size=None, #每经过多少个sample更新一次权重，defult 32</span><br><span class="line">epochs=1, #训练的轮数epochs</span><br><span class="line">verbose=1, #0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</span><br><span class="line">callbacks=None,#list，list中的元素为keras.callbacks.Callback对象，在训练过程中会调用list中的回调函数</span><br><span class="line">validation_split=0., #浮点数0-1，将训练集中的一部分比例作为验证集，然后下面的验证集validation_data将不会起到作用</span><br><span class="line">validation_data=None, #验证集</span><br><span class="line">shuffle=True, #布尔值和字符串，如果为布尔值，表示是否在每一次epoch训练前随机打乱输入样本的顺序，如果为&quot;batch&quot;，为处理HDF5数据</span><br><span class="line">class_weight=None, #dict,分类问题的时候，有的类别可能需要额外关注，分错的时候给的惩罚会比较大，所以权重会调高，体现在损失函数上面</span><br><span class="line">sample_weight=None, #array,和输入样本对等长度,对输入的每个特征+个权值，如果是时序的数据，则采用(samples，sequence_length)的矩阵</span><br><span class="line">initial_epoch=0, #如果之前做了训练，则可以从指定的epoch开始训练</span><br><span class="line">steps_per_epoch=None, #将一个epoch分为多少个steps，也就是划分一个batch_size多大，比如steps_per_epoch=10，则就是将训练集分为10份，不能和batch_size共同使用</span><br><span class="line">validation_steps=None, #当steps_per_epoch被启用的时候才有用，验证集的batch_size</span><br><span class="line">**kwargs #用于和后端交互</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">返回的是一个History对象，可以通过History.history来查看训练过程，loss值等等</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;fit&quot;&gt;&lt;a href=&quot;#fit&quot; class=&quot;headerlink&quot; title=&quot;fit&quot;&gt;&lt;/a&gt;fit&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="深度学习" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="keras" scheme="http://puguojing.com/tags/keras/"/>
    
  </entry>
  
  <entry>
    <title>使用tensorboard显示训练过程</title>
    <link href="http://puguojing.com/2019/01/16/%E4%BD%BF%E7%94%A8tensorboard%E6%98%BE%E7%A4%BA%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B/"/>
    <id>http://puguojing.com/2019/01/16/使用tensorboard显示训练过程/</id>
    <published>2019-01-16T09:35:19.000Z</published>
    <updated>2019-01-16T09:35:19.588Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Resnet残差网络模型-keras模型代码实现</title>
    <link href="http://puguojing.com/2019/01/15/Resnet%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-keras%E6%A8%A1%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://puguojing.com/2019/01/15/Resnet残差网络模型-keras模型代码实现/</id>
    <published>2019-01-15T11:45:41.000Z</published>
    <updated>2019-03-01T03:57:10.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Resnet50残差网络模型keras代码实现："><a href="#Resnet50残差网络模型keras代码实现：" class="headerlink" title="Resnet50残差网络模型keras代码实现："></a>Resnet50残差网络模型keras代码实现：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import warnings</span><br><span class="line"></span><br><span class="line">from keras.layers import Input</span><br><span class="line">from keras import layers</span><br><span class="line">from keras.layers import Dense</span><br><span class="line">from keras.layers import Activation</span><br><span class="line">from keras.layers import Flatten</span><br><span class="line">from keras.layers import Conv2D</span><br><span class="line">from keras.layers import MaxPooling2D</span><br><span class="line">from keras.layers import GlobalMaxPooling2D</span><br><span class="line">from keras.layers import ZeroPadding2D</span><br><span class="line">from keras.layers import AveragePooling2D</span><br><span class="line">from keras.layers import GlobalAveragePooling2D</span><br><span class="line">from keras.layers import BatchNormalization</span><br><span class="line">from keras.models import Model</span><br><span class="line">from keras.preprocessing import image</span><br><span class="line">import keras.backend as K</span><br><span class="line">from keras.utils import layer_utils</span><br><span class="line">from keras.utils.data_utils import get_file</span><br><span class="line">from keras.applications.imagenet_utils import decode_predictions</span><br><span class="line">from keras.applications.imagenet_utils import preprocess_input</span><br><span class="line"># from keras.applications.imagenet_utils import _obtain_input_shape</span><br><span class="line">from keras_applications.imagenet_utils import _obtain_input_shape</span><br><span class="line">from keras.engine.topology import get_source_inputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def identity_block(input_tensor, kernel_size, filters, stage, block):</span><br><span class="line"></span><br><span class="line">    filters1, filters2, filters3 = filters</span><br><span class="line"></span><br><span class="line">    if K.image_data_format() == &apos;channels_last&apos;:</span><br><span class="line">        bn_axis = 3</span><br><span class="line">    else:</span><br><span class="line">        bn_axis = 1</span><br><span class="line"></span><br><span class="line">    conv_name_base = &apos;res&apos; + str(stage) + block + &apos;_branch&apos;</span><br><span class="line">    bn_name_base = &apos;bn&apos; + str(stage) + block + &apos;_branch&apos;</span><br><span class="line"></span><br><span class="line">    x = Conv2D(filters1, (1, 1), name=conv_name_base + &apos;2a&apos;)(input_tensor)</span><br><span class="line">    x = BatchNormalization(axis=bn_axis, name=bn_name_base + &apos;2a&apos;)(x)</span><br><span class="line">    x = Activation(&apos;relu&apos;)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(filters2, kernel_size,</span><br><span class="line">               padding=&apos;same&apos;, name=conv_name_base + &apos;2b&apos;)(x)</span><br><span class="line">    x = BatchNormalization(axis=bn_axis, name=bn_name_base + &apos;2b&apos;)(x)</span><br><span class="line">    x = Activation(&apos;relu&apos;)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(filters3, (1, 1), name=conv_name_base + &apos;2c&apos;)(x)</span><br><span class="line">    x = BatchNormalization(axis=bn_axis, name=bn_name_base + &apos;2c&apos;)(x)</span><br><span class="line"></span><br><span class="line">    x = layers.add([x, input_tensor])</span><br><span class="line">    x = Activation(&apos;relu&apos;)(x)</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def conv_block(input_tensor, kernel_size, filters, stage, block, strides=(2, 2)):</span><br><span class="line"></span><br><span class="line">    filters1, filters2, filters3 = filters</span><br><span class="line">    if K.image_data_format() == &apos;channels_last&apos;:</span><br><span class="line">        bn_axis = 3</span><br><span class="line">    else:</span><br><span class="line">        bn_axis = 1</span><br><span class="line">    conv_name_base = &apos;res&apos; + str(stage) + block + &apos;_branch&apos;</span><br><span class="line">    bn_name_base = &apos;bn&apos; + str(stage) + block + &apos;_branch&apos;</span><br><span class="line"></span><br><span class="line">    x = Conv2D(filters1, (1, 1), strides=strides,</span><br><span class="line">               name=conv_name_base + &apos;2a&apos;)(input_tensor)</span><br><span class="line">    x = BatchNormalization(axis=bn_axis, name=bn_name_base + &apos;2a&apos;)(x)</span><br><span class="line">    x = Activation(&apos;relu&apos;)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(filters2, kernel_size, padding=&apos;same&apos;,</span><br><span class="line">               name=conv_name_base + &apos;2b&apos;)(x)</span><br><span class="line">    x = BatchNormalization(axis=bn_axis, name=bn_name_base + &apos;2b&apos;)(x)</span><br><span class="line">    x = Activation(&apos;relu&apos;)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(filters3, (1, 1), name=conv_name_base + &apos;2c&apos;)(x)</span><br><span class="line">    x = BatchNormalization(axis=bn_axis, name=bn_name_base + &apos;2c&apos;)(x)</span><br><span class="line"></span><br><span class="line">    shortcut = Conv2D(filters3, (1, 1), strides=strides,</span><br><span class="line">                      name=conv_name_base + &apos;1&apos;)(input_tensor)</span><br><span class="line">    shortcut = BatchNormalization(axis=bn_axis, name=bn_name_base + &apos;1&apos;)(shortcut)</span><br><span class="line"></span><br><span class="line">    x = layers.add([x, shortcut])</span><br><span class="line">    x = Activation(&apos;relu&apos;)(x)</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ResNet50(input_tensor=None, input_shape=None,classes=5):</span><br><span class="line"></span><br><span class="line">    input_shape = _obtain_input_shape(input_shape,</span><br><span class="line">                                      default_size=224,</span><br><span class="line">                                      min_size=197,</span><br><span class="line">                                      data_format=K.image_data_format(),</span><br><span class="line">                                      require_flatten=True)</span><br><span class="line"></span><br><span class="line">    if input_tensor is None:</span><br><span class="line">        img_input = Input(shape=input_shape)</span><br><span class="line">    else:</span><br><span class="line">        if not K.is_keras_tensor(input_tensor):</span><br><span class="line">            img_input = Input(tensor=input_tensor, shape=input_shape)</span><br><span class="line">        else:</span><br><span class="line">            img_input = input_tensor</span><br><span class="line">    if K.image_data_format() == &apos;channels_last&apos;:</span><br><span class="line">        bn_axis = 3</span><br><span class="line">    else:</span><br><span class="line">        bn_axis = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    x = ZeroPadding2D((3, 3))(img_input)</span><br><span class="line">    x = Conv2D(64, (7, 7), strides=(2, 2), name=&apos;conv1&apos;)(x)</span><br><span class="line">    x = BatchNormalization(axis=bn_axis, name=&apos;bn_conv1&apos;)(x)</span><br><span class="line">    x = Activation(&apos;relu&apos;)(x)</span><br><span class="line">    x = MaxPooling2D((3, 3), strides=(2, 2))(x)</span><br><span class="line"></span><br><span class="line">    x = conv_block(x, 3, [64, 64, 256], stage=2, block=&apos;a&apos;, strides=(1, 1))</span><br><span class="line">    x = identity_block(x, 3, [64, 64, 256], stage=2, block=&apos;b&apos;)</span><br><span class="line">    x = identity_block(x, 3, [64, 64, 256], stage=2, block=&apos;c&apos;)</span><br><span class="line"></span><br><span class="line">    x = conv_block(x, 3, [128, 128, 512], stage=3, block=&apos;a&apos;)</span><br><span class="line">    x = identity_block(x, 3, [128, 128, 512], stage=3, block=&apos;b&apos;)</span><br><span class="line">    x = identity_block(x, 3, [128, 128, 512], stage=3, block=&apos;c&apos;)</span><br><span class="line">    x = identity_block(x, 3, [128, 128, 512], stage=3, block=&apos;d&apos;)</span><br><span class="line"></span><br><span class="line">    x = conv_block(x, 3, [256, 256, 1024], stage=4, block=&apos;a&apos;)</span><br><span class="line">    x = identity_block(x, 3, [256, 256, 1024], stage=4, block=&apos;b&apos;)</span><br><span class="line">    x = identity_block(x, 3, [256, 256, 1024], stage=4, block=&apos;c&apos;)</span><br><span class="line">    x = identity_block(x, 3, [256, 256, 1024], stage=4, block=&apos;d&apos;)</span><br><span class="line">    x = identity_block(x, 3, [256, 256, 1024], stage=4, block=&apos;e&apos;)</span><br><span class="line">    x = identity_block(x, 3, [256, 256, 1024], stage=4, block=&apos;f&apos;)</span><br><span class="line"></span><br><span class="line">    x = conv_block(x, 3, [512, 512, 2048], stage=5, block=&apos;a&apos;)</span><br><span class="line">    x = identity_block(x, 3, [512, 512, 2048], stage=5, block=&apos;b&apos;)</span><br><span class="line">    x = identity_block(x, 3, [512, 512, 2048], stage=5, block=&apos;c&apos;)</span><br><span class="line"></span><br><span class="line">    x = AveragePooling2D((7, 7), name=&apos;avg_pool&apos;)(x)</span><br><span class="line"></span><br><span class="line">    x = Flatten()(x)</span><br><span class="line">    x = Dense(classes, activation=&apos;softmax&apos;, name=&apos;fc5&apos;)(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(&quot;x:&quot;,x)</span><br><span class="line"></span><br><span class="line">    if input_tensor is not None:</span><br><span class="line">        inputs = get_source_inputs(input_tensor)</span><br><span class="line">    else:</span><br><span class="line">        inputs = img_input</span><br><span class="line"></span><br><span class="line">    model = Model(inputs, x, name=&apos;my_resnet50&apos;)</span><br><span class="line"></span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Resnet50残差网络模型keras代码实现：&quot;&gt;&lt;a href=&quot;#Resnet50残差网络模型keras代码实现：&quot; class=&quot;headerlink&quot; title=&quot;Resnet50残差网络模型keras代码实现：&quot;&gt;&lt;/a&gt;Resnet50残差网络模型
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="深度学习" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Resnet" scheme="http://puguojing.com/tags/Resnet/"/>
    
      <category term="keras" scheme="http://puguojing.com/tags/keras/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://puguojing.com/2019/01/15/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB-%E5%9B%BE%E5%83%8F%E7%9A%84%E6%94%B6%E9%9B%86%E4%B8%8E%E5%A4%84%E7%90%86/"/>
    <id>http://puguojing.com/2019/01/15/图像分类-图像的收集与处理/</id>
    <published>2019-01-15T11:11:56.801Z</published>
    <updated>2019-05-12T10:05:08.191Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 图像分类-图像的收集与处理<br>categories:</p><ul><li>技术</li><li>深度学习<br>tags:</li><li>深度学习</li></ul><p>comments: true<br>date: 2019-01-15 19:11:56<br>img:<br>—s</p><p>####1.图像的收集与标注<br>图像的标注可以使用文件名标注对应的名称分类和y_labe值。<br>将统图片放入文件夹，参考猫狗大战图片标记方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def get_file(dir):</span><br><span class="line">    images = []</span><br><span class="line">    temp =[]</span><br><span class="line"></span><br><span class="line">    for root ,sub_folders,files in os.walk(dir):</span><br><span class="line">        for name in files:</span><br><span class="line">            images.append(os.path.join(root,name))</span><br><span class="line"></span><br><span class="line">        for name in sub_folders:</span><br><span class="line">            temp.append(os.path.join(root,name))</span><br><span class="line"></span><br><span class="line">        print(files)</span><br><span class="line"></span><br><span class="line">    lables=[]</span><br><span class="line"></span><br><span class="line">    for one_folder in temp:</span><br><span class="line">        n_img  = len(os.listdir(one_folder))</span><br><span class="line">        letter = one_folder.split((&apos;/&apos;))[-1]</span><br><span class="line"></span><br><span class="line">        if  letter ==&apos;cat&apos;:</span><br><span class="line">            lables = np.append(lables,n_img*[0])</span><br><span class="line">        else:</span><br><span class="line">            lables = np.append(lables, n_img * [1])</span><br></pre></td></tr></table></figure><h4 id="2-图像的加工与处理"><a href="#2-图像的加工与处理" class="headerlink" title="2.图像的加工与处理"></a>2.图像的加工与处理</h4><p>一般网络模型的输入数据大小都是固定，比如224x224，229x229等,但是我们获取到的图片往往大小不一样，所以需要进行处理。方式一：不管原图大小比例，直接压缩到224x224；方式二：进行图片剪切。</p><h5 id="（1）图片压缩"><a href="#（1）图片压缩" class="headerlink" title="（1）图片压缩"></a>（1）图片压缩</h5><p>（1）使用opencv对图片压缩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">def  rebuild(path,dim=(227,227)):</span><br><span class="line">    img = cv2.imread(path)</span><br><span class="line"></span><br><span class="line">    img = cv2.resize(img,dim)</span><br><span class="line">    # cv2.imwrite(path,img)</span><br><span class="line"></span><br><span class="line">    show_img(img)</span><br></pre></td></tr></table></figure><p>（2）使用keras的util工具包进行压缩，并处理成模型的输入数据格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from keras_preprocessing import image</span><br><span class="line">from keras.applications.imagenet_utils import preprocess_input</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def input_image_process(img_path,target_size=(224, 224)):</span><br><span class="line">    </span><br><span class="line">    img = image.load_img(img_path, target_size=target_size)#load_img使用的是PIL的resize接口将图像压缩到target_size</span><br><span class="line"></span><br><span class="line">    x = image.img_to_array(img)#将图像转成numpy array</span><br><span class="line">    print(&quot;x array:&quot;,x.shape,x)</span><br><span class="line">    x = np.expand_dims(x, axis=0)#数据维度更改，</span><br><span class="line">    print(&quot;expand_dims:&quot;,x.shape,x)</span><br><span class="line"></span><br><span class="line">    x = preprocess_input(x,mode=&apos;tf&apos;)#标准化处理，使用tf格式具体看源码</span><br><span class="line"></span><br><span class="line">    print(&quot;preprocess_input:&quot;,x.shape,x)</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure><h5 id="（2）图片截取"><a href="#（2）图片截取" class="headerlink" title="（2）图片截取"></a>（2）图片截取</h5><p>对图片进行剪切也是一种方式，但是建切实会造成图片信息丢失。但是可以采用剪切多张图片或者平移剪切的方式。<br>部分代码如下：<br>使用PIL对图片进行剪切</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image,ImageDraw,ImageFont</span><br><span class="line"></span><br><span class="line">def draw_rectangle(img,size):</span><br><span class="line">“”“</span><br><span class="line">在图片指定的区域画一个方形框</span><br><span class="line">”“”</span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    draw.rectangle(size, fill=None, outline=&apos;#FF0000&apos;, width=5)</span><br><span class="line">    return img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def crop_img(img_path,size=(0,0,500,500)):</span><br><span class="line">“”“</span><br><span class="line">按照宽或者高最大化在图像中间剪切一块正方形区域</span><br><span class="line">”“”</span><br><span class="line">    img = Image.open(img_path)</span><br><span class="line"></span><br><span class="line">    width,height  = img.size[0],img.size[1]</span><br><span class="line"></span><br><span class="line">    print(width,height)</span><br><span class="line">    if width &gt; height:</span><br><span class="line"></span><br><span class="line">        size = (int((width-height) / 2),0,height + int((width-height)/2),height)</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        size = ( 0,int((height - width) / 2), width, width + int((height - width) / 2))</span><br><span class="line"></span><br><span class="line">    print(size)</span><br><span class="line">    croped_img = img.crop(size)</span><br><span class="line">    return croped_img</span><br></pre></td></tr></table></figure><p>下面附一个显示plt显示图片的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">def show_img(img,title=&apos;&apos;):</span><br><span class="line">    plt.figure(num=1, figsize=(8, 5), )</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.axis(&apos;off&apos;)  # 不显示坐标轴</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 图像分类-图像的收集与处理&lt;br&gt;categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术&lt;/li&gt;
&lt;li&gt;深度学习&lt;br&gt;tags:&lt;/li&gt;
&lt;li&gt;深度学习&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;comments: true&lt;br&gt;date: 2019-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>安装配置TensorFlow的GPU版本</title>
    <link href="http://puguojing.com/2019/01/07/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AETensorFlow%E7%9A%84GPU%E7%89%88%E6%9C%AC/"/>
    <id>http://puguojing.com/2019/01/07/安装配置TensorFlow的GPU版本/</id>
    <published>2019-01-07T09:01:47.000Z</published>
    <updated>2019-01-10T11:50:01.845Z</updated>
    
    <content type="html"><![CDATA[<p>###win10下tensorflow、Kera的GPU版本配置</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>你准备配置TensorFlow GPU版本的之前，你肯定已经十分熟悉了python的开发环境的配置。一个Python的初学者，通常不会上来就做那么复杂的工作。Python、pip、anacoda、virtualenv、virtualenvwrapper…分别是什么？什么是python虚拟环境、为什么需要虚拟环境？如何在windows/linux/mac下安装配置python的开发环境、你可以参考我的<a href="">【这篇文章】</a>或者自己查阅资料。</p><p>你已经安装好了Python的开发环境，不管你是不使用anaconda还是pip，virtuaenv，这里我用的是“<strong>python3+pip+virtualenvwrapper</strong>”的环境,接下来我们来安装CUDA和cuDNN。</p><p>####1.该如何选择CUDA的版本？<br>这里建议选择CUDA9.0的版本，至于为什么选择CUDA9.0而不选择最新的CUDA10.0这里讲一下。</p><p>因为现在tensorflow-gpu的版本更新到tensorflow-gpu==1.12版本，它不支持CUDA10.0版本，即使你正确安装了CUDA10.0版本和对应的cuDNN版本，你在<figure class="highlight plain"><figcaption><span>tensorflow``` 时，也会遇到 “找不到对应的DLL模块的错误”。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当然如果你非要安装CUDA 10.0的版本，我这里有一个被修改过的tensorflow-gpu本地安装版本，他可以在CUDA10.0的版本下正常运行。这里是下载链接：[xxxx.whl]()</span><br><span class="line"></span><br><span class="line">下载完成后通过</span><br></pre></td></tr></table></figure></p><p>pip install  xxxx.whl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">安装，当然在安装前,如果你已经安装过tensorflow包或者tensorflow-gpu包的话，你需要先卸载他们。</span><br><span class="line"></span><br><span class="line">而至于更老的8.1的版本，一方面是因为他看起来有点过时了，另一方面是因为他在安装和使用的时候会产生一些不兼容问题，所以也不建议使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.安装</span><br><span class="line">这里的参考安装版本组合：python3.6 + tensorflow 1.12 + keras 2.2.4 + CUDA 10.0 + cuDNN 7.4</span><br><span class="line"></span><br><span class="line">首先来看一下他们几个之间的关系</span><br><span class="line"></span><br><span class="line">![QQ20190104-165158@2x](http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/QQ20190104-165115%402x.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在安装之前请查看一下自己的显卡是否支持CUDA。GTX 1060 1070 1080/1080i都支持，剩下的可以参考下面的网站查看：[CUDA显卡查询]()</span><br><span class="line"></span><br><span class="line">##### 1.安装CUDA</span><br><span class="line"></span><br><span class="line">这里是下载连接：</span><br><span class="line">[CUDA10.0下载连接](https://developer.nvidia.com/cuda-downloads?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exelocal) </span><br><span class="line"></span><br><span class="line">![WX20190110-173234@2x](media/15465901117286/WX20190110-173234@2x.png)</span><br><span class="line"></span><br><span class="line">[CUDA9.0下载链接](https://developer.nvidia.com/cuda-90-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exelocal)</span><br><span class="line"></span><br><span class="line">![WX20190110-173122@2x](media/15465901117286/WX20190110-173122@2x.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下载完成后尽量以管理员模式运行安装。</span><br><span class="line"></span><br><span class="line">他会提示你选安装方式是精简还是自定义。这里你可以直接选精简，如果你选择自定义，可以勾选掉visualstudio组件的部分，如果你没有使用visualstudio的IDE的话。</span><br><span class="line"></span><br><span class="line">安装完成后，你可以在[此电脑]-&gt;[鼠标右键]-&gt;[属性]-&gt;[高级]-&gt;[环境变量]-&gt;[系统环境变量]中看到2个关于CUDA_PATH的环境变量设置，说明你安装成功。</span><br><span class="line"></span><br><span class="line">##### 2.安装cuDNN</span><br><span class="line"></span><br><span class="line">cuDNN的安装需要你先注册一个账户登录，然后才让你下载，安装时注意，请安装对应的CUDA版本的cuDNN版本，</span><br><span class="line"></span><br><span class="line">[cuDNN for CUDA下载链接](https://developer.nvidia.com/cudnn) </span><br><span class="line"></span><br><span class="line">注册完成下载时里面会有：</span><br><span class="line">![A985FE99-7CDB-4b53-88A0-B6DD8BD5A6A7](media/15465901117286/A985FE99-7CDB-4b53-88A0-B6DD8BD5A6A7.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下载完成后他是一个压缩包，解压出来是一个cuda文件夹，里面有bin、lib、include等文件夹及一些.DDL文件，你可以把它放到任意地方（甚至和CUDA的安装路径放在一起），只要你配置的环境变量能引用到他。这里我们参考建议做法，把它放到C:\Program Files盘里面,路径为：C:\Program Files\cuda   下面我们来配置cuDNN的环境变量。</span><br><span class="line"></span><br><span class="line">![](http://puguojing-hexo.oss-cn-shanghai.aliyuncs.com/NZMTTP%259%7B%244ZV%29%40I86AXVHV.png)</span><br><span class="line"></span><br><span class="line">最主要的是要把cuDNN中的bin中的 XXXX.DLL文件能够通过系统环境变量Path中找到</span><br><span class="line">下面是环境变量的内容在系统环境变量的Path中添加：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">网上有一些复杂的多个环境变量配置，你不需要参考他们，我也不清楚他们为什么会把环境变量配置的那么复杂，你可看看tensorflow官网的介绍：https://tensorflow.google.cn/install/gpu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 3.安装tensorflow-gpu</span><br><span class="line">直接通过pip安装：</span><br></pre></td></tr></table></figure></p><p>pip install tensorflow-gpu<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果是10.0的话记得使用上面我提供的whl安装包安装。</span><br><span class="line"></span><br><span class="line">###### 4.安装keras</span><br></pre></td></tr></table></figure></p><p>pip install keras<br><code>`</code></p><p>安装好之后Keras会自动使用tensorflow的GPU版本，不需要其他配置。</p><p>重新运行你的程序你会发现，已经使用了GPU的版本并且会显示你的显卡型号、大小等信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###win10下tensorflow、Kera的GPU版本配置&lt;/p&gt;
&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;你准备配置TensorFlow GPU版本的之前，你肯定已经
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="深度学习" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="TensorFlow" scheme="http://puguojing.com/tags/TensorFlow/"/>
    
      <category term="机器学习" scheme="http://puguojing.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python读取大文件的注意事项</title>
    <link href="http://puguojing.com/2018/12/12/Python%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://puguojing.com/2018/12/12/Python读取大文件的注意事项/</id>
    <published>2018-12-12T03:20:31.000Z</published>
    <updated>2018-12-13T03:28:40.020Z</updated>
    
    <content type="html"><![CDATA[<p>python读写文件的都很简单，直接一个with open就解决了，但是这也只是在学习基础知识时候的小案例，不能轻易放入项目中。</p><h4 id="1-read-与readlines"><a href="#1-read-与readlines" class="headerlink" title="1.read()与readlines()"></a>1.read()与readlines()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with open(file_path, &apos;rb&apos;) as f:</span><br><span class="line">    sha1Obj.update(f.read())</span><br><span class="line">or</span><br><span class="line">with open(file_path, &apos;rb&apos;) as f:</span><br><span class="line">    for line in f.readlines():</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>这对方法在读取小文件时确实不会产生什么异常，但是一旦读取大文件，很容易会产生MemoryError，也就是内存溢出的问题。</p><p>####Why Memory Error？</p><p>我们首先来看看这几个方法：</p><h5 id="read方法"><a href="#read方法" class="headerlink" title="read方法"></a>read方法</h5><p>read([size])方法从文件当前位置起读取size个字节，若无参数size（size=-1），则表示读取至文件结束EOF为止，当文件大小大于可用内存时，自然会发生内存溢出的错误。</p><h5 id="readline方法"><a href="#readline方法" class="headerlink" title="readline方法"></a>readline方法</h5><p>该方法每次读出一行内容，所以，读取时占用内存小，比较适合大文件，该方法返回一个字符串对象。</p><p>可选参数 size 的含义同上。它是以行为单位返回字符串，也就是每次读一行，依次循环，如果不限定 size，直到最后一个返回的是空字符串，意味着到文件末尾了(EOF).</p><h5 id="readlines方法"><a href="#readlines方法" class="headerlink" title="readlines方法"></a>readlines方法</h5><p>size参数 同上。它返回的是以行为单位的列表，即相当于先执行 readline() ，得到每一行，然后把这一行的字符串作为列表中的元素塞到一个列表中，最后将此列表返回。<br>readlines构造的是list|而不是iter，所以所有的内容都会保存在内存之上，文件内容过大同样也会发生内存溢出的错误。</p><h5 id="2-正确的用法"><a href="#2-正确的用法" class="headerlink" title="2.正确的用法"></a>2.正确的用法</h5><p>在实际运行的系统之中如果写出上述代码是十分危险的，。所以接下来我们来了解一下正确用法。</p><p>如果是<strong>二进制</strong>文件推荐用如下这种写法，可以自己指定缓冲区有多少byte。显然缓冲区越大，读取速度越快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">with open(file_path, &apos;rb&apos;) as f:</span><br><span class="line">    while True:</span><br><span class="line">        buf = f.read(1024)</span><br><span class="line">        if buf:    </span><br><span class="line">            Obj.update(buf)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>而如果是文本文件，则可以用readline方法或直接迭代文件（python这里封装了一个语法糖，二者的内生逻辑一致，不过显然迭代文件的写法更pythonic ）每次读取一行，效率是比较低的。笔者简单测试了一下，在3G文件之下，大概性能和前者差了20%.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">with open(file_path, &apos;rb&apos;) as f:</span><br><span class="line">    while True:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        if buf:    </span><br><span class="line">            print(line)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">            </span><br><span class="line">with open(file_path, &apos;rb&apos;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>所以在使用python读取文件的时候如果是大文件（接近内存或大于1G）建议使用read(size=1024)（二进制文件）或者readline()（文本文件）。如果文件不大，而且需要经常使用文件数据，则可以直接使用read()和readlines()把数据全加载到内存里。</p><h4 id="3-内存检测工具的介绍"><a href="#3-内存检测工具的介绍" class="headerlink" title="3.内存检测工具的介绍"></a>3.内存检测工具的介绍</h4><p>对于python代码的内存占用问题，对于代码进行内存监控十分必要。这里推荐两个小工具来检测python代码的内存占用。</p><p>####memory_profiler</p><p>首先先用pip安装memory_profiler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install memory_profiler</span><br></pre></td></tr></table></figure><p>memory_profiler是利用python的装饰器工作的，所以我们需要在进行测试的函数上添加装饰器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from hashlib import sha1</span><br><span class="line">import sys</span><br><span class="line">@profile</span><br><span class="line">def my_func():</span><br><span class="line">    sha1Obj = sha1()</span><br><span class="line">    with open(sys.argv[1], &apos;rb&apos;) as f:</span><br><span class="line">        while True:</span><br><span class="line">            buf = f.read(10 * 1024 * 1024)</span><br><span class="line">            if buf:</span><br><span class="line">                sha1Obj.update(buf)</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">    print(sha1Obj.hexdigest())</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    my_func()</span><br></pre></td></tr></table></figure><p>之后在运行代码时加上”<code>-m memory_profiler</code>“</p><p>就可以了解函数每一步代码的内存占用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyhton -m memory_profiler  test.py</span><br></pre></td></tr></table></figure><h4 id="guppy"><a href="#guppy" class="headerlink" title="guppy"></a>guppy</h4><p>依仍然是通过pip先安装guppy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install guppy</span><br></pre></td></tr></table></figure><p>之后可以在代码之中利用guppy直接打印出对应各种python类型（list、tuple、dict等）分别创建了多少对象，占用了多少内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from guppy import hpy</span><br><span class="line">import sys</span><br><span class="line">def my_func():</span><br><span class="line">    mem = hpy()</span><br><span class="line">    with open(sys.argv[1], &apos;rb&apos;) as f:</span><br><span class="line">        while True:</span><br><span class="line">            buf = f.read(10 * 1024 * 1024)</span><br><span class="line">            if buf:</span><br><span class="line">                print(mem.heap())</span><br><span class="line">            else:</span><br><span class="line">                break</span><br></pre></td></tr></table></figure><p>运行后，可以看到打印出对应的内存占用数据。</p><p>通过上述两种工具guppy与memory_profiler可以很好地来监控python代码运行时的内存占用问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python读写文件的都很简单，直接一个with open就解决了，但是这也只是在学习基础知识时候的小案例，不能轻易放入项目中。&lt;/p&gt;
&lt;h4 id=&quot;1-read-与readlines&quot;&gt;&lt;a href=&quot;#1-read-与readlines&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="python" scheme="http://puguojing.com/tags/python/"/>
    
      <category term="内存溢出" scheme="http://puguojing.com/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>集群介绍及配置</title>
    <link href="http://puguojing.com/2018/11/09/%E9%9B%86%E7%BE%A4%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <id>http://puguojing.com/2018/11/09/集群介绍及配置/</id>
    <published>2018-11-09T15:13:23.000Z</published>
    <updated>2018-11-09T15:13:23.651Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目部署之阿里云服务器环境配置、数据库安装</title>
    <link href="http://puguojing.com/2018/11/06/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E4%B9%8B%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85/"/>
    <id>http://puguojing.com/2018/11/06/项目部署之阿里云服务器环境配置、数据库安装/</id>
    <published>2018-11-06T13:33:50.000Z</published>
    <updated>2018-11-18T16:12:49.090Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要讲使用阿里云服务器部署项目，首先介绍一下我的阿里云系统是Ubuntu 16.04 64位的版本。</p><h2 id="登录阿里云服务器"><a href="#登录阿里云服务器" class="headerlink" title="登录阿里云服务器"></a>登录阿里云服务器</h2><p>首先使用ssh登陆阿里云服务器：<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-213721@2x.png" alt="QQ20181106-213721@2x"></p><p>阿里云服务默认是使用的root用户，所以不需要我们再开启root用户了，如果你没有开启root用户，可以使用<code>sudo passwd root</code>命令，然后输入2遍root密码开启root。</p><p>##修改apt的安装源</p><p>对于原版的ubuntu系统apt的安装包的源是国外的，我们可以在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/apt/source.list</span><br></pre></td></tr></table></figure><p>文件中查看apt源,但是更好的是我们可以把apt源替换成国内的源。</p><p>为了避免出错你可以首先备份一下source.list</p><p>cd 到/etc/apt/目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp source.list  source.list.bak</span><br></pre></td></tr></table></figure><p>会把source.list拷贝一份并命令为source.list.bak。</p><p>然后我们可以删除source.list内容，把内容替换成下面的源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>更新源。</p><p>但其实阿里云服务器的Ubuntu系统本身已经帮你修改好了apt的源，所以你在使用阿里云服务器的Ubuntu系统时并不需要执行上面的操作，你只需要在使用apt 安装一些软件之前执行：<code>sudo apt update</code>就好了。</p><h2 id="安装Vim"><a href="#安装Vim" class="headerlink" title="安装Vim"></a>安装Vim</h2><p>你可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><p>安装vim ，当然由于你现在可能是root用户，所以你不需要加sudo 直接输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install vim</span><br></pre></td></tr></table></figure><p>就可以安装。但是更好的是阿里云服务器其实已经帮你安装了vim，所以你根本不需要在安装。你可以在终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim</span><br></pre></td></tr></table></figure><p>他会显示如下的信息给你，说明你已经安装了vim<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-215200@2x.png" alt="QQ20181106-215200@2x"></p><h2 id="安装mysql-数据库"><a href="#安装mysql-数据库" class="headerlink" title="安装mysql 数据库"></a>安装mysql 数据库</h2><p>使用如下命令安装mysql数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server mysql-client</span><br></pre></td></tr></table></figure><p>在安装的时候会让你设定数据库的密码，输入自己想设定的数据库密码即可。</p><p>安装完成后可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --help</span><br></pre></td></tr></table></figure><p>查看是否安装成功，更确定的是我们可以尝试使用一下mysql,输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>会提示你输入数据库的密码（就是你在安装数据的时候设定的）<br>你也可以尝试查看一些数据库：<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-215848@2x.png" alt="QQ20181106-215848@2x"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show database;</span><br></pre></td></tr></table></figure><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-220031@2x.png" alt="QQ20181106-220031@2x"></p><p>注意别忘了最后的分号。最后输入<code>quit;</code>退出mysql。</p><h2 id="安装memcached："><a href="#安装memcached：" class="headerlink" title="安装memcached："></a>安装memcached：</h2><p>通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install memcached</span><br></pre></td></tr></table></figure><p>即可安装。<br>然后测试一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 11211</span><br></pre></td></tr></table></figure><p>再尝试存储一下数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set username 0 60 5</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>然后在获取一下数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get username</span><br></pre></td></tr></table></figure><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-220455@2x.png" alt="QQ20181106-220455@2x"></p><p>发现可以操作时说明没问题。(输入quit退出memcached)</p><h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><p>Ubuntu系统会自己默认给我们安装python2.7，你可以使用<code>python -V</code>查看当前的python 版本。但是由于我们使用的是python3所以还需要安装python3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3</span><br></pre></td></tr></table></figure><p>安装完成后可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -V</span><br></pre></td></tr></table></figure><p>查看一下</p><p>安装完python3之后还需要安装python3对应的pip(pip不懂的话请请自行谷歌)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure><p>这里会安装python3对应使用的pip3</p><blockquote><p>pip 是用来管理python的包的工具，直接输入python默认代表的python2，对应的pip是pip2，所以输入时python、pip代表的分别是python2和pip2。而如果想使用python3版本就需要输入：python3和pip3。这里的系统默认安装的是python2 和pip2但是我们需要python3和pip3,所以需要重新安装。</p></blockquote><p>安装完pip3之后可以查看一下pip的版本：</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-221952@2x.png" alt="QQ20181106-221952@2x"></p><p>可以看到pip和pip3的版本都是8.1,但是我们需要使用最新的pip3的包，所以需要更新pip3（由于pip2我们不使用所以就不更新了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br></pre></td></tr></table></figure><p>但是会报如下错误：<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-223005@2x.png" alt="QQ20181106-223005@2x"></p><p>这主要是因为pip3新旧版本的问题。</p><p>我们尝试修改一下<code>/usr/bin/pip3</code>中的内容就。<br>打开<code>/usr/bin/pip3</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># GENERATED BY DEBIAN</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># Run the main entry point, similarly to how setuptools does it, but because</span><br><span class="line"># we didn&apos;t install the actual entry point from setup.py, don&apos;t use the</span><br><span class="line"># pkg_resources API.</span><br><span class="line">from pip import main</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sys.exit(main())</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from pip import __main__</span><br><span class="line"> if __name__ == &apos;__main__&apos;:</span><br><span class="line">     sys.exit(__main__._main())</span><br></pre></td></tr></table></figure><p>如果还报错，直接重新强制升级安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 -m pip install --upgrade --force-reinstall pip</span><br></pre></td></tr></table></figure><p>重新查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 --version</span><br></pre></td></tr></table></figure><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-230237@2x.png" alt="QQ20181106-230237@2x"></p><p>更新到了18.1</p><h2 id="安装virtualenvwrapper，"><a href="#安装virtualenvwrapper，" class="headerlink" title="安装virtualenvwrapper，"></a>安装virtualenvwrapper，</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenvwrapper</span><br></pre></td></tr></table></figure><p>安装完成之后我们还需要做一些配置：<br>1.在用户目录下（cd ~/）新建一个文件夹“.vitualenvs”用来存放我们的虚拟环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/</span><br><span class="line">mkdir .virtualenvs</span><br></pre></td></tr></table></figure><p>然后执行<code>ls -al</code>看一下：</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181107-000835@2x.png" alt="QQ20181107-000835@2x"><br>发现 .virtualenvs 文件夹</p><p>2.配置环境变量<br>我们安装完成之后还无法使用virtualenvwrapper命令，还需要配置环境变量。<br>先执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p>看一下我们的virtualenvwrapper路径<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181107-001206@2x.png" alt="QQ20181107-001206@2x"></p><p>在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p>路径下。</p><p>然后 打开用户目录下的 .bashrc文件<br>在最后添加下面代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">  source /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p>然后退出.bashrc文件，输入命令<code>source ~/.bashrc</code>使.bashrc生效。</p><p>接下来我们就可以使用命令来创建虚拟环境变量了：（由于我们的virtualenvwrapper安装在了pyton3环境中所以可以直接创建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv xfz-env</span><br></pre></td></tr></table></figure><p>注意：如果你把virtualenvwrapper安装在了python2的环境中，在创建虚拟环境的时候需要使用–python参数指定使用哪个Python文件，安装python3的路径是在/usr/bin/python3。那么示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv --python=/usr/bin/python3 xfz-env</span><br></pre></td></tr></table></figure><p>创建完成可以在“。virtualenvs”目录下查看env环境：<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181107-002144@2x.png" alt="QQ20181107-002144@2x"></p><p>你可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workon xfz-env</span><br></pre></td></tr></table></figure><p>进入到指定的虚拟环境</p><p>注意在source .bashrc如果出现以下错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">No module named virtualenvwrapper</span><br><span class="line">virtualenvwrapper.sh: There was a problem running the initialization hooks.</span><br><span class="line"></span><br><span class="line">If Python could not import the module virtualenvwrapper.hook_loader,</span><br><span class="line">check that virtualenvwrapper has been installed for</span><br><span class="line">VIRTUALENVWRAPPER_PYTHON=/usr/bin/python and that PATH is</span><br><span class="line">set properly.</span><br></pre></td></tr></table></figure><p>那么在 .bashrc 加入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br></pre></td></tr></table></figure><h2 id="从远程仓库下载代码"><a href="#从远程仓库下载代码" class="headerlink" title="从远程仓库下载代码"></a>从远程仓库下载代码</h2><p>我们应该应该吧完整的代码上传到了自己的GitHub或者码云中，接下来我们需要从远程仓库把代码pull到服务器：</p><p>1.首先进入到 “/src”，<code>cd /src</code><br>2.在/src下新建一个项目文件夹，比如我的是  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir xiaofaozhuo</span><br></pre></td></tr></table></figure><p>3.然后进入xiaofaozhuo文件夹执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin https://gitee.com/PuGuoJing/xiaofanzhuo</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>如果没有安装git 执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install git</span><br></pre></td></tr></table></figure><p>安装git。</p><p>这样你就可以把所有的远程代码下载到服务器了。</p><h3 id="安装require-txt依赖包"><a href="#安装require-txt依赖包" class="headerlink" title="安装require.txt依赖包"></a>安装require.txt依赖包</h3><p>进入自己的虚拟环境中，然后进入到项目所在的目录，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><p>安装项目依赖的包。如果提示OSError: mysql_config not found，那么再安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libmysqld-dev</span><br></pre></td></tr></table></figure><p>即可。</p><p>注意短信验证码的包需要单独安装。把dysms_python文件夹上传到项目中，然后进入到这个文件夹中。执行命令：python setup.py install。</p><blockquote><p>对于一些第三方的无法通过pip安装的包，这里我们需要手动安装，比如这里的阿里云短信验证码服务就需要通过setup.py手动安装。</p></blockquote><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>在安装好所有的环境之后，我们需要创建我们项目使用的数据库。</p><p> 首先进入我们的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></p><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database  xfz;</span><br></pre></td></tr></table></figure><p>创建我们所使用的数据xfz。<br>创建完成后我们可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181118-232002@2x.png" alt="QQ20181118-232002@2x"></p><p>查看数据库。<br>之后我们进入到项目根路径执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py makemigrations</span><br><span class="line">python3 manage.py migrate</span><br></pre></td></tr></table></figure><p>将模型映射到数据库中，这样我们的数据库创建成功，可以使用了。</p><p>在数据库创建成功之后其实我们往往还需要一个需求，就是我们想可以在远程使用navcat去连接查看我们的数据库，那接下来我们还需要做下面几件事。</p><p>1.开启阿里云网络安全组中的3306端口的防火墙。<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181118-232930@2x.png" alt="QQ20181118-232930@2x"><br>具体如何开启请开我的另一篇博客<a href="http://www.puguojing.com/2018/11/06/Mac%E4%B8%8B%E8%B4%AD%E4%B9%B0%E9%85%8D%E7%BD%AE%E5%92%8C%E8%AE%BF%E9%97%AE%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/" target="_blank" rel="noopener">Mac下购买配置和访问阿里云服务器的详细步骤</a>中的<strong>[MAC使用ssh远程连接阿里云服务器]**</strong>[添加网络安全组]** 或者自行百度。</p><p>2.为我们的数据库创建用户授权，这样才可以远程连接。<br>具体参考：<a href="https://www.aliyun.com/ss/6L-c56iL6L-e5o6lbXlzcWzmlbDmja7lupM/a" target="_blank" rel="noopener">阿里云远程连接数据库</a></p><p>3.修改我们的数据库中的配置文件ALLOW_HOST,如果该配置为127.0.0.1，请删除或注释掉此行。</p><p>注意windows下mysql配置文件是.ini文件，linux下是.cnf文件，请找到自己对应的配置文件修改。</p><p>linux 一般在/etc/mysql/下有mysqld.cnf<br>但是博主的是在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p>下所以根据自己的情况查找。</p><p>在配置好上述之后一般就可以通过navcat远程连接我们的数据库了。用户名和密码就是你在第二部开启权限的用户名密码。</p><h3 id="测试运行项目"><a href="#测试运行项目" class="headerlink" title="测试运行项目"></a>测试运行项目</h3><p>首先我们需要修改setting.py中的ALLOW_HOST=[47.92.52.97]，即我们阿里云服务器的公网Ip这样就可以通过其他电脑访问我们的服务器了。</p><p>然后我们在项目下执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure><p>这样就可以通过Ip:8000 来访问我们的网站了，在网站地址栏输入：<br><a href="http://47.92.53.97：8000" target="_blank" rel="noopener">http://47.92.53.97：8000</a><br>就可以看到我们的网站了，但是这个时候可能会有一些显示问题，这主要是我们的静态文件未正确加载。</p><h3 id="收集静态文件（css-js-image）"><a href="#收集静态文件（css-js-image）" class="headerlink" title="收集静态文件（css\js\image）"></a>收集静态文件（css\js\image）</h3><p>项目中我们的静态文件一般都是分散的。不方便服务器处理，所以我们需要把所有的静态文件收集到一个文件夹中：</p><p>首先在我们在项目下新建议各位空文件夹:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir static_dist</span><br></pre></td></tr></table></figure><p>用来存放素有的静态文件，然后在setting.py中配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ROOT= os.path.join(BASE_DIR,&apos;static_dist&apos;)</span><br></pre></td></tr></table></figure><p>然后执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure><p>collectstatic 会收集setting.py中的STATICFILES_DIRS 指定的目录所有的静态文件和各个app下的static下的静态文件到static_dist文件夹中。具体参考django文档。</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181119-000117@2x.png" alt="QQ20181119-000117@2x"></p><h3 id="安装配置uwsgi"><a href="#安装配置uwsgi" class="headerlink" title="安装配置uwsgi"></a>安装配置uwsgi</h3><p>uwsgi是一个应用服务器，非静态文件的网络请求就必须通过他完成，他也可以充当静态文件服务器，但不是他的强项。uwsgi是使用python编写的，因此通过pip3 install uwsgi就可以了。(uwsgi必须安装在系统级别的Python环境中，不要安装到虚拟环境中)。然后创建一个叫做uwsgi.ini的配置文件（原则上可以在任何位置创建，这里我们可以在项目目录里创建）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"></span><br><span class="line"># 必须全部为绝对路径</span><br><span class="line"># 项目的路径</span><br><span class="line">chdir           = /srv/xiaofanzhuan  #表示我们项目在服务器中的绝对路径 </span><br><span class="line"># Django的wsgi文件</span><br><span class="line">module          = xiaofanzhuan.wsgi #指定我们项目中的wsgi文件</span><br><span class="line"># Python虚拟环境的路径</span><br><span class="line">home            = /root/.virtualenvs/xfz-env</span><br><span class="line"></span><br><span class="line"># 进程相关的设置</span><br><span class="line"># 主进程</span><br><span class="line">master          = true</span><br><span class="line"># 最大数量的工作进程</span><br><span class="line">processes       = 10</span><br><span class="line"></span><br><span class="line">http            = :8000  #运行端口</span><br><span class="line"></span><br><span class="line"># 设置socket的权限</span><br><span class="line">chmod-socket    = 666  #socket用用和nginx通信</span><br><span class="line"># 退出的时候是否清理环境</span><br><span class="line">vacuum          = true</span><br><span class="line"></span><br><span class="line">daemonize       = /var/log/xfz_uwsgi.log  #指定log文件位置，一般的错误信息全在里面</span><br></pre></td></tr></table></figure><p>然后通过命令uwsgi –ini uwsgi.ini运行，确保没有错误。然后在浏览器中访问<a href="http://ip地址:8000，如果能够访问到页面（可能没有静态文件）说明uwsgi配置没有问题。" target="_blank" rel="noopener">http://ip地址:8000，如果能够访问到页面（可能没有静态文件）说明uwsgi配置没有问题。</a></p><p>通过ps aux | grep uwsgi 查看uwsgi运行情况，使用kill -9 第一个uwsgi pid  关闭uwsgi运行。</p><h3 id="安装配置niginx"><a href="#安装配置niginx" class="headerlink" title="安装配置niginx"></a>安装配置niginx</h3><p>虽然uwsgi可以正常的部署我们的项目了。但我们还是依然要采用nginx来作为web服务器。使用nginx来作为web服务器有以下好处：</p><p>uwsgi对静态文件资源处理并不好，包括响应速度，缓存等。<br>nginx作为专业的web服务器，暴露在公网上会比uwsgi更加安全一点。<br>运维起来更加方便。比如要将某些IP写入黑名单，nginx可以非常方便的写进去。而uwsgi可能还要写一大段代码才能实现。</p><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><p>通过apt install nginx即可安装。</p><h4 id="nginx简单操作命令："><a href="#nginx简单操作命令：" class="headerlink" title="nginx简单操作命令："></a>nginx简单操作命令：</h4><p>启动：service nginx start<br>关闭：service nginx stop<br>重启：service nginx restart<br>测试配置文件：service nginx configtest</p><p>添加配置文件：<br>在/etc/nginx/conf.d目录下，新建一个文件，叫做zhiliaoketang.conf，然后将以下代码粘贴进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">upstream zhiliaoketang &#123;</span><br><span class="line">    server unix:///srv/zhiliaoketang/zhiliaoketang.sock; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置服务器</span><br><span class="line">server &#123;</span><br><span class="line">    # 监听的端口号</span><br><span class="line">    listen      80;</span><br><span class="line">    # 域名</span><br><span class="line">    server_name 192.168.0.101; </span><br><span class="line">    charset     utf-8;</span><br><span class="line"></span><br><span class="line">    # 最大的文件上传尺寸</span><br><span class="line">    client_max_body_size 75M;  </span><br><span class="line"></span><br><span class="line">    # 静态文件访问的url</span><br><span class="line">    location /static &#123;</span><br><span class="line">        # 静态文件地址</span><br><span class="line">        alias /srv/zhiliaoketang/static_dist; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 最后，发送所有非静态文件请求到django服务器</span><br><span class="line">    location / &#123;</span><br><span class="line">        uwsgi_pass  zhiliaoketang;</span><br><span class="line">        # uwsgi_params文件地址</span><br><span class="line">        include     /etc/nginx/uwsgi_params; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完配置文件后，为了测试配置文件是否设置成功，运行命令：service nginx configtest，如果不报错，说明成功。<br>每次修改完了配置文件，都要记得运行service nginx restart。</p><h3 id="uwsgi-和nginx的关系及他们各自的作用。"><a href="#uwsgi-和nginx的关系及他们各自的作用。" class="headerlink" title="uwsgi 和nginx的关系及他们各自的作用。"></a>uwsgi 和nginx的关系及他们各自的作用。</h3><h3 id="使用supervisor管理uwsgi进程："><a href="#使用supervisor管理uwsgi进程：" class="headerlink" title="使用supervisor管理uwsgi进程："></a>使用supervisor管理uwsgi进程：</h3><p>让supervisor管理uwsgi，可以在uwsgi发生意外的情况下，会自动的重启。</p><h4 id="安装supervisor："><a href="#安装supervisor：" class="headerlink" title="安装supervisor："></a>安装supervisor：</h4><p>因为supervisor是用python写成的，所以通过pip即可安装。<br>并且因为supervisor不支持python3，因此需要把supervisor安装在python2的环境中。<br>pip2 install supervisor。</p><h4 id="启动："><a href="#启动：" class="headerlink" title="启动："></a>启动：</h4><p>在项目的根目录下创建一个文件叫做supervisor.conf，然后将以下代码填入到配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># supervisor的程序名字</span><br><span class="line">   [program:mysite]</span><br><span class="line">   # supervisor执行的命令</span><br><span class="line">   command=uwsgi --ini zlkt_uwsgi.ini</span><br><span class="line">   # 项目的目录</span><br><span class="line">   directory = /srv/zhiliaoketang </span><br><span class="line">   # 开始的时候等待多少秒</span><br><span class="line">   startsecs=0</span><br><span class="line">   # 停止的时候等待多少秒</span><br><span class="line">   stopwaitsecs=0  </span><br><span class="line">   # 自动开始</span><br><span class="line">   autostart=true</span><br><span class="line">   # 程序挂了后自动重启</span><br><span class="line">   autorestart=true</span><br><span class="line">   # 输出的log文件</span><br><span class="line">   stdout_logfile=/srv/zhiliaoketang/log/supervisord.log</span><br><span class="line">   # 输出的错误文件</span><br><span class="line">   stderr_logfile=/srv/zhiliaoketang/log/supervisord.err</span><br><span class="line"></span><br><span class="line">   [supervisord]</span><br><span class="line">   # log的级别</span><br><span class="line">   loglevel=debug</span><br><span class="line"></span><br><span class="line">   [inet_http_server]</span><br><span class="line">   # supervisor的服务器</span><br><span class="line">   port = :9001</span><br><span class="line">   # 用户名和密码</span><br><span class="line">   username = admin</span><br><span class="line">   password = 123</span><br><span class="line"></span><br><span class="line">   # 使用supervisorctl的配置</span><br><span class="line">   [supervisorctl]</span><br><span class="line">   # 使用supervisorctl登录的地址和端口号</span><br><span class="line">   serverurl = http://127.0.0.1:9001</span><br><span class="line"></span><br><span class="line">   # 登录supervisorctl的用户名和密码</span><br><span class="line">   username = admin</span><br><span class="line">   password = 123</span><br><span class="line"></span><br><span class="line">   [rpcinterface:supervisor]</span><br><span class="line">   supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br></pre></td></tr></table></figure><p>然后使用命令supervisord -c supervisor.conf运行就可以了。<br>以后如果想要启动uwsgi，就可以通过命令supervisorctl -c supervisor.conf进入到管理控制台，然后可以执行相关的命令进行管理：</p><p>status # 查看状态<br>start program_name #启动程序<br>restart program_name #重新启动程序<br>stop program_name # 关闭程序<br>reload # 重新加载配置文件<br>quit # 退出控制台</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天主要讲使用阿里云服务器部署项目，首先介绍一下我的阿里云系统是Ubuntu 16.04 64位的版本。&lt;/p&gt;
&lt;h2 id=&quot;登录阿里云服务器&quot;&gt;&lt;a href=&quot;#登录阿里云服务器&quot; class=&quot;headerlink&quot; title=&quot;登录阿里云服务器&quot;&gt;&lt;/a&gt;登录
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="阿里云服务器" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="阿里云服务器" scheme="http://puguojing.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="部署" scheme="http://puguojing.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Mac下购买配置和访问阿里云服务器的详细步骤</title>
    <link href="http://puguojing.com/2018/11/06/Mac%E4%B8%8B%E8%B4%AD%E4%B9%B0%E9%85%8D%E7%BD%AE%E5%92%8C%E8%AE%BF%E9%97%AE%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/"/>
    <id>http://puguojing.com/2018/11/06/Mac下购买配置和访问阿里云服务器的详细步骤/</id>
    <published>2018-11-06T09:08:02.000Z</published>
    <updated>2018-11-06T10:58:45.294Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直想买一个阿里云服务器玩玩，听说学生版的非常便宜一个月只要9.9元，但是我已经毕业了啊，所以忍痛买了一个入门一70.2元/月。</p><h3 id="阿里云注册"><a href="#阿里云注册" class="headerlink" title="阿里云注册"></a>阿里云注册</h3><p>首先你需要注册一个阿里云账户或者不想注册直接使用自己的淘宝、支付宝账户登录也可以。<br>你可以在这里注册 <a href="https://account.aliyun.com/register/register.htm?spm=5176.8142029.388261.26.a7236d3ewunhyE&amp;oauth_callback=https%3A%2F%2Fwww.aliyun.com%2F%3Futm_medium%3Dtext%26utm_source%3Dbdbrand%26utm_campaign%3Dbdbrand%26utm_content%3Dse_32492" target="_blank" rel="noopener">阿里云注册</a></p><h3 id="阿里云翼计划"><a href="#阿里云翼计划" class="headerlink" title="阿里云翼计划"></a>阿里云翼计划</h3><p>如果你还是学生的话，那么恭喜你可以在这里加入<a href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" rel="noopener">阿里云翼计划</a>一个月只需要9.5元！😍</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/2018110601.png" alt="2018110601"></p><h3 id="阿里云服务器ECS购买"><a href="#阿里云服务器ECS购买" class="headerlink" title="阿里云服务器ECS购买"></a>阿里云服务器ECS购买</h3><p>那如果你和我一样不满足条云翼计划的条件那就只能在 【阿里云】-【产品】-【精选】-【云服务器ECS】(ECS是阿里云服务器的名字，腾讯的叫CVM，仅仅是一个名字而已)</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-172613@2x23.png" alt="QQ20181106-172613@2x23"></p><p>在点击进入之后你会看到如下的界面：<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-173200@2x.png" alt="QQ20181106-173200@2x"></p><p>1.点击立即购买，：<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-173229@2x.png" alt="QQ20181106-173229@2x"><br>2.你会看到一大堆你并不能看懂的配置，没关系，你可以直接选择【一键购买】<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-173311@2x.png" alt="QQ20181106-173311@2x"></p><p>3.是不是开起来清爽多了？那这些配置分别代表什么意思呢？<br>地域：表示你服务器的地理位置，具体不同的地理位置有什么区别，这个主要是访问者的距离服务器越远一般情况访问速度越慢，所以你看到发达的华东地区服务器稍微贵一点。你可以根据你的具体地理位置情况和money多少自由选择，哪一个区域都可以。但是要记住你自己所选择的区域，因为购买完成后我们要到这个区域的管理控制台下管理我们的服务器。</p><p>实例：就是购买的电脑主机了，具体配置怎么选择，关键看你的需求了，就像我们买电脑一样CPU、内存、磁盘大小，具体要看你来干什么，一般我就选最小的，因为我的网站就是个人小网站啊。</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-173422@2x.png" alt="QQ20181106-173422@2x"></p><p>镜像：这个主要是我们购买的主机你想让他装什么样的操作系统和操作系统的版本，有Windows、linux两大类。至于你该如何选择主要参考你网站采用的技术，由于本人使用的是Python开发的网站,所以选择是Ubuntu，一款强大而简单的Linux发行版。</p><p>公网带宽：这个要取决你网站的访问量了，我当然选最低的了1Mbps对于我来说够了。</p><p>购买量：就是购买时间，你可以购买一周，这里楼主买了一个月。</p><p>4.选择完配置之后直接点击【立即购买】</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-173504@2x.png" alt="QQ20181106-173504@2x"></p><p>5.勾选【云服务器ECS服务条款】-【去下单】</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-173531@2x.png" alt="QQ20181106-173531@2x"></p><p>6.【确认支付】，然后使用支付宝扫码支付即可。</p><h3 id="查看购买云服务器ECS"><a href="#查看购买云服务器ECS" class="headerlink" title="查看购买云服务器ECS"></a>查看购买云服务器ECS</h3><p>1.在你购买完成之后一般会自动跳转到云服务器ECS管理控制台，你可以通过点击主页右上角的【控制台】进入控制台管理页面。<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-180207@2x.png" alt="QQ20181106-180207@2x"></p><p>2.进入之后在左侧选择【云服务器ECS】<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-180306@2x.png" alt="QQ20181106-180306@2x"></p><p>3.进入之后选择 左侧【实例】查看购买的云服务器。<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-180516@2x.png" alt="QQ20181106-180516@2x"></p><p>4.如果在【实例】下没有找到云服务器的话，说明你可能没有切换到自己对应地理位置的控制台。你可以通过做左上角下拉选择自己购买时选择的服务器地理区域。<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-180542@2x.png" alt="QQ20181106-180542@2x"></p><p>4.在这里可以看到【基本信息】【配置信息】【付费信息】【监控信息】等等。</p><h3 id="连接阿里云服务器"><a href="#连接阿里云服务器" class="headerlink" title="连接阿里云服务器"></a>连接阿里云服务器</h3><p>在这里面可以进行「远程连接」到你的服务器，但是在进行「远程连接」之前我们还需要配置一下我们的服务器用户密码：</p><p>1.点击【更多】【密码/密钥】【重置密码】，就可以自己设置登录密码了。<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-180630@2x.png" alt="QQ20181106-180630@2x"></p><p>2.在设置完登录密码后需要重启服务器，你可以在【管理】中重启服务器：<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-182205@2x.png" alt="QQ20181106-182205@2x"></p><p>然后我们就可以点击【远程连接】，第一次远程连接时会给你一个默认的6位密码，你也可以在上面的【重置密码】中找到【修改远程连接密码】进行修改自己的密码。<br>在输入远程连接密码后会进入下面的界面，输入用户名和密码就可以登录了。</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-182457@2x.png" alt="QQ20181106-182457@2x"></p><p>用户名默认是root,密码就是刚才我们重置的密码（不是远程连接密码）。</p><h3 id="MAC使用ssh远程连接阿里云服务器"><a href="#MAC使用ssh远程连接阿里云服务器" class="headerlink" title="MAC使用ssh远程连接阿里云服务器"></a>MAC使用ssh远程连接阿里云服务器</h3><p>不过阿里云提供的这个「远程连接」我们可肯定不太使用，所以我们会使用自己的ssh客户端登录阿里云主机。</p><p>但是在使用shh连接阿里云服务器之前我们还需要做一些安全设置，否则你用ssh连接或者ping公网ip都是会失败的，所以我们需要先进行设置。</p><p>1.点击「更多」-「安全组配置」-「配置规则」</p><p><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-183922@2x.png" alt="QQ20181106-183922@2x"></p><p>2.点击「添加安全组规则」然后就开始添加规则了，可参考我的配置<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-184026@2x.png" alt="QQ20181106-184026@2x"></p><p>然后我们来ping一下和尝试使用ssh登录：<br>先看一下IP地址，在【实例】信息中查看<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-184735@2x.png" alt="QQ20181106-184735@2x"></p><p>然后尝试ping和ssh登录：<br><img src="http://pc59bkg3l.bkt.clouddn.com/QQ20181106-184537@2x.png" alt="QQ20181106-184537@2x"></p><p>查看远程网络是否正常连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 47.93.53.97</span><br></pre></td></tr></table></figure><p>远程登录：root用户名，按提示输入上面重置的登录密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@47.93.53.97</span><br></pre></td></tr></table></figure><p>连接成功后就可以干自己的事情了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直想买一个阿里云服务器玩玩，听说学生版的非常便宜一个月只要9.9元，但是我已经毕业了啊，所以忍痛买了一个入门一70.2元/月。&lt;/p&gt;
&lt;h3 id=&quot;阿里云注册&quot;&gt;&lt;a href=&quot;#阿里云注册&quot; class=&quot;headerlink&quot; title=&quot;阿里云注册&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="阿里云" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    
      <category term="阿里云服务器" scheme="http://puguojing.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="部署" scheme="http://puguojing.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>celery执行任务报错，有可能是你的版本不对</title>
    <link href="http://puguojing.com/2018/11/06/celery(1)%E8%A7%A3%E5%86%B3%E8%BF%90%E8%A1%8Ctask%E4%BB%BB%E5%8A%A1%E6%97%B6worker%E6%8A%A5%E9%94%99/"/>
    <id>http://puguojing.com/2018/11/06/celery(1)解决运行task任务时worker报错/</id>
    <published>2018-11-06T06:13:44.000Z</published>
    <updated>2018-12-13T03:28:40.022Z</updated>
    
    <content type="html"><![CDATA[<p>如果的celery worker能够正常起来，但是在运行task任务时却显示如下错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">(xxx-env) ➜  celerydemo celery -A celerydemo worker -l info</span><br><span class="line">[2018-11-28 11:34:56,216: WARNING/MainProcess] /Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/celery/apps/worker.py:161: CDeprecationWarning:</span><br><span class="line">Starting from version 3.2 Celery will refuse to accept pickle by default.</span><br><span class="line"></span><br><span class="line">The pickle serializer is a security concern as it may give attackers</span><br><span class="line">the ability to execute any command.  It&apos;s important to secure</span><br><span class="line">your broker from unauthorized access when using pickle, so we think</span><br><span class="line">that enabling pickle should require a deliberate action and not be</span><br><span class="line">the default choice.</span><br><span class="line"></span><br><span class="line">If you depend on pickle then you should set a setting to disable this</span><br><span class="line">warning and to be sure that everything will continue working</span><br><span class="line">when you upgrade to Celery 3.2::</span><br><span class="line"></span><br><span class="line">    CELERY_ACCEPT_CONTENT = [&apos;pickle&apos;, &apos;json&apos;, &apos;msgpack&apos;, &apos;yaml&apos;]</span><br><span class="line"></span><br><span class="line">You must only enable the serializers that you will actually use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  warnings.warn(CDeprecationWarning(W_PICKLE_DEPRECATED))</span><br><span class="line"></span><br><span class="line"> -------------- celery@PgjMacbookPro.local v3.1.26.post2 (Cipater)</span><br><span class="line">---- **** -----</span><br><span class="line">--- * ***  * -- Darwin-18.2.0-x86_64-i386-64bit</span><br><span class="line">-- * - **** ---</span><br><span class="line">- ** ---------- [config]</span><br><span class="line">- ** ---------- .&gt; app:         celerydemo:0x10e621b70</span><br><span class="line">- ** ---------- .&gt; transport:   redis://127.0.0.1:6379/0</span><br><span class="line">- ** ---------- .&gt; results:     disabled://</span><br><span class="line">- *** --- * --- .&gt; concurrency: 4 (prefork)</span><br><span class="line">-- ******* ----</span><br><span class="line">--- ***** ----- [queues]</span><br><span class="line"> -------------- .&gt; celery           exchange=celery(direct) key=celery</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[tasks]</span><br><span class="line">  . main.tasks.mytask1</span><br><span class="line"></span><br><span class="line">[2018-11-28 11:34:56,386: INFO/MainProcess] Connected to redis://127.0.0.1:6379/0</span><br><span class="line">[2018-11-28 11:34:56,399: INFO/MainProcess] mingle: searching for neighbors</span><br><span class="line">[2018-11-28 11:34:57,409: INFO/MainProcess] mingle: all alone</span><br><span class="line">[2018-11-28 11:34:57,420: WARNING/MainProcess] /Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/celery/fixups/django.py:265: UserWarning: Using settings.DEBUG leads to a memory leak, never use this setting in production environments!</span><br><span class="line">  warnings.warn(&apos;Using settings.DEBUG leads to a memory leak, never &apos;</span><br><span class="line">[2018-11-28 11:34:57,420: WARNING/MainProcess] celery@PgjMacbookPro.local ready.</span><br><span class="line">[2018-11-28 11:36:06,000: ERROR/MainProcess] Unrecoverable error: AttributeError(&quot;&apos;str&apos; object has no attribute &apos;items&apos;&quot;,)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/celery/worker/__init__.py&quot;, line 206, in start</span><br><span class="line">    self.blueprint.start(self)</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/celery/bootsteps.py&quot;, line 123, in start</span><br><span class="line">    step.start(parent)</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/celery/bootsteps.py&quot;, line 374, in start</span><br><span class="line">    return self.obj.start()</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/celery/worker/consumer.py&quot;, line 280, in start</span><br><span class="line">    blueprint.start(self)</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/celery/bootsteps.py&quot;, line 123, in start</span><br><span class="line">    step.start(parent)</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/celery/worker/consumer.py&quot;, line 884, in start</span><br><span class="line">    c.loop(*c.loop_args())</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/celery/worker/loops.py&quot;, line 76, in asynloop</span><br><span class="line">    next(loop)</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/kombu/async/hub.py&quot;, line 340, in create_loop</span><br><span class="line">    cb(*cbargs)</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/kombu/transport/redis.py&quot;, line 1019, in on_readable</span><br><span class="line">    self._callbacks[queue](message)</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/kombu/transport/virtual/__init__.py&quot;, line 534, in _callback</span><br><span class="line">    self.qos.append(message, message.delivery_tag)</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/kombu/transport/redis.py&quot;, line 146, in append</span><br><span class="line">    pipe.zadd(self.unacked_index_key, delivery_tag, time()) \</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/redis/client.py&quot;, line 2263, in zadd</span><br><span class="line">    for pair in iteritems(mapping):</span><br><span class="line">  File &quot;/Users/pgj/.virtualenvs/xxx-env/lib/python3.6/site-packages/redis/_compat.py&quot;, line 123, in iteritems</span><br><span class="line">    return iter(x.items())</span><br><span class="line">AttributeError: &apos;str&apos; object has no attribute &apos;items&apos;</span><br></pre></td></tr></table></figure><p>说明你的pip install  安装的redis 的版本不对！必须要和你的celery,celery-with-redis版本对应：<br>看一下我之前报错的redis版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis             3.0.1</span><br></pre></td></tr></table></figure><p>更改后的版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis             2.10.6</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果的celery worker能够正常起来，但是在运行task任务时却显示如下错误:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="celery" scheme="http://puguojing.com/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>常用书籍列表</title>
    <link href="http://puguojing.com/2018/11/06/%E5%B8%B8%E7%94%A8%E4%B9%A6%E7%B1%8D%E5%88%97%E8%A1%A8/"/>
    <id>http://puguojing.com/2018/11/06/常用书籍列表/</id>
    <published>2018-11-06T06:13:44.000Z</published>
    <updated>2018-11-06T10:52:51.275Z</updated>
    
    <content type="html"><![CDATA[<ol><li>python书籍列表<ul><li></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;python书籍列表&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="工具" scheme="http://puguojing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="书籍" scheme="http://puguojing.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="http://puguojing.com/2018/11/06/%E9%9A%8F%E7%AC%94/"/>
    <id>http://puguojing.com/2018/11/06/随笔/</id>
    <published>2018-11-06T03:32:20.000Z</published>
    <updated>2018-11-06T04:04:12.573Z</updated>
    
    <content type="html"><![CDATA[ <font color="#e67e22">正如你所看到的这里并没有什么内容… </font>]]></content>
    
    <summary type="html">
    
      
      
         &lt;font color=&quot;#e67e22&quot;&gt;正如你所看到的这里并没有什么内容… &lt;/font&gt;


      
    
    </summary>
    
      <category term="随笔" scheme="http://puguojing.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac下Redis数据的安装、操作、配置</title>
    <link href="http://puguojing.com/2018/10/16/mac%E4%B8%8BRedis%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E6%93%8D%E4%BD%9C%E3%80%81%E9%85%8D%E7%BD%AE/"/>
    <id>http://puguojing.com/2018/10/16/mac下Redis数据的安装、操作、配置/</id>
    <published>2018-10-16T07:49:56.000Z</published>
    <updated>2018-11-06T03:20:18.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>使用brew安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure><p>完成后会自动安装redis-server和redis-cli。</p><p>redis安装后，默认会自动启动，可以通过以下PS进程命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep redis</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ps aux|grep redis</span><br><span class="line">pgj              17677   0.0  0.0  4287208   1064 s001  S+    3:54下午   0:00.01 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn redis</span><br><span class="line">pgj              17616   0.0  0.0  4295500   1160 s003  S+    3:44下午   0:00.02 redis-cli -h 127.0.0.1 -p 6379 -a foobared</span><br><span class="line">pgj              17555   0.0  0.0  4309276   2312 s002  S+    3:40下午   0:00.62 redis-server 127.0.0.1:6379</span><br></pre></td></tr></table></figure><p>可以看到进程PID为17555的就是redis-server,可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 17555</span><br></pre></td></tr></table></figure><p>关闭Redis服务（不建议使用，强制杀死进程，可能导致Redis部分缓存丢失）。</p><h4 id="手动启动："><a href="#手动启动：" class="headerlink" title="手动启动："></a>手动启动：</h4><p>Redis安装完成后会生成<code>/usr/local/etc/redis.conf</code>文件，执行启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/etc/redis.conf</span><br></pre></td></tr></table></figure><p>会显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ redis-server /usr/local/etc/redis.conf</span><br><span class="line">17555:C 16 Oct 15:40:34.312 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">17555:C 16 Oct 15:40:34.313 # Redis version=4.0.4, bits=64, commit=00000000, modified=0, pid=17555, just started</span><br><span class="line">17555:C 16 Oct 15:40:34.313 # Configuration loaded</span><br><span class="line">17555:M 16 Oct 15:40:34.316 * Increased maximum number of open files to 10032 (it was originally set to 4864).</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ &apos;&apos;-._</span><br><span class="line">      _.-``    `.  `_.  &apos;&apos;-._           Redis 4.0.4 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._</span><br><span class="line"> (    &apos;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-&apos;    |     PID: 17555</span><br><span class="line">  `-._    `-._  `-./  _.-&apos;    _.-&apos;</span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|</span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io</span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;</span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|</span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |</span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;</span><br><span class="line">      `-._    `-.__.-&apos;    _.-&apos;</span><br><span class="line">          `-._        _.-&apos;</span><br></pre></td></tr></table></figure><p>说明启动成功。</p><h4 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h [ip] -p [端口]</span><br></pre></td></tr></table></figure><p>-h:指定IP<br>-p:指定端口号（默认6379，可在redis.conf中修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure><p>###配置<br>配置文件具体在：<code>/usr/local/etc/redis.conf</code></p><h4 id="1-添加密码"><a href="#1-添加密码" class="headerlink" title="1.添加密码"></a>1.添加密码</h4><p>在配置文件中找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line">#</span><br><span class="line"># requirepass foobared</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>其中<code>requirepass</code>后面的字符，就是Redis数据库密码,默认时注释掉的。如果此处指定了密码，那么以后使用<code>redis-cli</code>链接redis数据库的时候就要使用密码，否则连接Redis数据库之后,无法进行Redis数据库操作。<br>比如指定密码为：123456</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line">#</span><br><span class="line">requirepass 123456</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>那么以后使用<code>redis-cli</code>连接数据库的时候就要用<code>-a</code>指定密码下面的命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a 123456</span><br></pre></td></tr></table></figure><p>如果你在连接redis数据库是没有使用-a指定密码，也可以在redis-cli命令行中使用：<code>auth password</code>指定密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="2-让其其他的电脑访问可以redis"><a href="#2-让其其他的电脑访问可以redis" class="headerlink" title="2.让其其他的电脑访问可以redis"></a>2.让其其他的电脑访问可以redis</h4><p>在配置文件中找打bind,默认IP只有127.0.0.1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 ::1</span><br></pre></td></tr></table></figure><p>在<code>127.0.0.1</code>后面加上自己电脑的（redis-server所在的电脑）的IP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1  198.168.1.102</span><br></pre></td></tr></table></figure><p>注意：添加不是Redis客户端的IP，是redis-server端的IP。<br>这样别的客户端就可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 198.168.1.102 6379</span><br></pre></td></tr></table></figure><p>来连接redis数据库了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h3&gt;&lt;p&gt;使用brew安装&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://puguojing.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://puguojing.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mac下Redis数据的安装、操作、配置</title>
    <link href="http://puguojing.com/2018/10/16/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C/"/>
    <id>http://puguojing.com/2018/10/16/Redis数据库的数据类型及操作/</id>
    <published>2018-10-16T07:49:56.000Z</published>
    <updated>2018-11-22T16:25:54.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis教程："><a href="#redis教程：" class="headerlink" title="redis教程："></a>redis教程：</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>redis是一种nosql数据库,他的数据是保存在内存中，同时redis可以定时把内存数据同步到磁盘，即可以将数据持久化，并且他比memcached支持更多的数据结构(string,list列表[队列和栈],set[集合],sorted set[有序集合],hash(hash表))。相关参考文档：<a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">http://redisdoc.com/index.html</a></p><h3 id="redis使用场景："><a href="#redis使用场景：" class="headerlink" title="redis使用场景："></a>redis使用场景：</h3><ul><li>登录会话存储：存储在redis中，与memcached相比，数据不会丢失。</li><li>排行版/计数器：比如一些秀场类的项目，经常会有一些前多少名的主播排名。还有一些文章阅读量的技术，或者新浪微博的点赞数等。</li><li>作为消息队列：比如celery就是使用redis作为中间人。</li><li>当前在线人数：还是之前的秀场例子，会显示当前系统有多少在线人数。</li><li>一些常用的数据缓存：比如我们的BBS论坛，板块不会经常变化的，但是每次访问首页都要从mysql中获取，可以在redis中缓存起来，不用每次请求数据库。</li><li>把前200篇文章缓存或者评论缓存：一般用户浏览网站，只会浏览前面一部分文章或者评论，那么可以把前面200篇文章和对应的评论缓存起来。用户访问超过的，就访问数据库，并且以后文章超过200篇，则把之前的文章删除。</li><li>好友关系：微博的好友关系使用redis实现。</li><li>发布和订阅功能：可以用来做聊天软件。<h4 id="redis和memcached的比较："><a href="#redis和memcached的比较：" class="headerlink" title="redis和memcached的比较："></a>redis和memcached的比较：</h4>memcached    redis<br>类型    |纯内存数据库    内存磁盘同步数据库<br>数据类型    在定义value时就要固定数据类型    不需要<br>虚拟内存    不支持    支持<br>过期策略    支持    支持<br>存储数据安全    不支持    可以将数据同步到dump.db中<br>灾难恢复    不支持    可以将磁盘中的数据恢复到内存中<br>分布式    支持    主从同步<br>订阅与发布    不支持    支持</li></ul><p>redis在ubuntu系统中的安装与启动</p><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure><h4 id="卸载："><a href="#卸载：" class="headerlink" title="卸载："></a>卸载：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge --auto-remove redis-server</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>redis安装后，默认会自动启动，可以通过以下命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep redis</span><br></pre></td></tr></table></figure><p>如果想自己手动启动，可以通过以下命令进行启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service redis-server start</span><br></pre></td></tr></table></figure><h4 id="停止："><a href="#停止：" class="headerlink" title="停止："></a>停止：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service redis-server stop</span><br></pre></td></tr></table></figure><h3 id="对redis的操作"><a href="#对redis的操作" class="headerlink" title="对redis的操作"></a>对redis的操作</h3><p>对redis的操作可以用两种方式，第一种方式采用redis-cli，第二种方式采用编程语言，比如Python、PHP和JAVA等。</p><h4 id="使用redis-cli对redis进行字符串操作："><a href="#使用redis-cli对redis进行字符串操作：" class="headerlink" title="使用redis-cli对redis进行字符串操作："></a>使用redis-cli对redis进行字符串操作：</h4><h5 id="启动redis："><a href="#启动redis：" class="headerlink" title="启动redis："></a>启动redis：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service redis-server start</span><br></pre></td></tr></table></figure><h5 id="连接上redis-server："><a href="#连接上redis-server：" class="headerlink" title="连接上redis-server："></a>连接上redis-server：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h [ip] -p [端口]</span><br></pre></td></tr></table></figure><h5 id="添加："><a href="#添加：" class="headerlink" title="添加："></a>添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">```  </span><br><span class="line">  如：</span><br></pre></td></tr></table></figure><p>set username xiaotuo<br><code>`</code></p><p>将字符串值value关联到key。如果key已经持有其他值，set命令就覆写旧值，无视其类型。并且默认的过期时间是永久，即永远不会过期。</p><h5 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h5><p>  del key<br>  如：<br>  del username<br>设置过期时间：</p><p>  expire key timeout(单位为秒)<br>也可以在设置值的时候，一同指定过期时间：</p><p>  set key value EX timeout<br>  或：<br>  setex key timeout value<br>查看过期时间：</p><p>  ttl key<br>  如：<br>  ttl username<br>查看当前redis中的所有key：</p><p>  keys *<br>列表操作：</p><p>在列表左边添加元素：</p><p>  lpush key value<br>将值value插入到列表key的表头。如果key不存在，一个空列表会被创建并执行lpush操作。当key存在但不是列表类型时，将返回一个错误。</p><p>在列表右边添加元素：</p><p>  rpush key value<br>将值value插入到列表key的表尾。如果key不存在，一个空列表会被创建并执行RPUSH操作。当key存在但不是列表类型时，返回一个错误。</p><p>查看列表中的元素：</p><p>  lrange key start stop<br>返回列表key中指定区间内的元素，区间以偏移量start和stop指定,如果要左边的第一个到最后的一个lrange key 0 -1。</p><p>移除列表中的元素：</p><p>移除并返回列表key的头元素：<br>  lpop key<br>移除并返回列表的尾元素：<br>rpop key<br>移除并返回列表key的中间元素：</p><p>  lrem key count value<br>将删除key这个列表中，count个值为value的元素。</p><p>指定返回第几个元素：</p><p>  lindex key index<br>将返回key这个列表中，索引为index的这个元素。</p><p>获取列表中的元素个数：</p><p>  llen key<br>  如：<br>  llen languages<br>删除指定的元素：</p><p>  lrem key count value<br>  如：<br>  lrem languages 0 php<br>根据参数 count 的值，移除列表中与参数 value 相等的元素。count的值可以是以下几种：</p><p>count &gt; 0：从表头开始向表尾搜索，移除与value相等的元素，数量为count。<br>count &lt; 0：从表尾开始向表头搜索，移除与 value相等的元素，数量为count的绝对值。<br>count = 0：移除表中所有与value 相等的值。<br>set集合的操作：</p><p>添加元素：<br>  sadd set value1 value2….<br>  如：<br>  sadd team xiaotuo datuo<br>查看元素：<br>  smembeers set<br>  如：<br>  smembers team<br>移除元素：<br>  srem set member…<br>  如：<br>  srem team xiaotuo datuo<br>查看集合中的元素个数：<br>  scard set<br>  如：<br>  scard team1<br>获取多个集合的交集：<br>  sinter set1 set2<br>  如：<br>  sinter team1 team2<br>获取多个集合的并集：<br>  sunion set1 set2<br>  如：<br>  sunion team1 team2<br>获取多个集合的差集：<br>sdiff set1 set2<br>如：<br>sdiff team1 team2<br>hash哈希操作：</p><p>添加一个新值：</p><p>  hset key field value<br>  如：<br>  hset website baidu baidu.com<br>将哈希表key中的域field的值设为value。<br>如果key不存在，一个新的哈希表被创建并进行 HSET操作。如果域 field已经存在于哈希表中，旧值将被覆盖。</p><p>获取哈希中的field对应的值：</p><p>  hget key field<br>  如：<br>  hget website baidu<br>删除field中的某个field：</p><p>  hdel key field<br>  如：<br>  hdel website baidu<br>获取某个哈希中所有的field和value：</p><p>  hgetall key<br>  如：<br>  hgetall website<br>获取某个哈希中所有的field：</p><p>  hkeys key<br>  如：<br>  hkeys website<br>获取某个哈希中所有的值：</p><p>hvals key<br>如：<br>hvals website<br>判断哈希中是否存在某个field：</p><p>hexists key field<br>如：<br>hexists website baidu<br>获取哈希中总共的键值对：</p><p>hlen field<br>如：<br>hlen website<br>事务操作：Redis事务可以一次执行多个命令，事务具有以下特征：</p><p>隔离操作：事务中的所有命令都会序列化、按顺序地执行，不会被其他命令打扰。<br>原子操作：事务中的命令要么全部被执行，要么全部都不执行。<br>开启一个事务：</p><p>  multi<br>以后执行的所有命令，都在这个事务中执行的。</p><p>执行事务：</p><p>  exec<br>会将在multi和exec中的操作一并提交。</p><p>取消事务：</p><p>  discard<br>会将multi后的所有命令取消。</p><p>监视一个或者多个key：</p><p>  watch key…<br>监视一个(或多个)key，如果在事务执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</p><p>取消所有key的监视：</p><p>  unwatch<br>发布/订阅操作：</p><p>给某个频道发布消息：<br>  publish channel message<br>订阅某个频道的消息：<br>  subscribe channel<br>持久化：redis提供了两种数据备份方式，一种是RDB，另外一种是AOF，以下将详细介绍这两种备份策略：</p><p>| | RDB | AOF | | — | — | — | | 开启关闭 | 开启：默认开启。关闭：把配置文件中所有的save都注释，就是关闭了。 | 开启：在配置文件中appendonly yes即开启了aof，为no关闭。 | | 同步机制 | 可以指定某个时间内发生多少个命令进行同步。比如1分钟内发生了2次命令，就做一次同步。 | 每秒同步或者每次发生命令后同步 | | 存储内容 | 存储的是redis里面的具体的值 | 存储的是执行的更新数据的操作命令 | | 存储文件的路径 | 根据dir以及dbfilename来指定路径和具体的文件名 | 根据dir以及appendfilename来指定具体的路径和文件名 | | 优点 | （1）存储数据到文件中会进行压缩，文件体积比aof小。（2）因为存储的是redis具体的值，并且会经过压缩，因此在恢复的时候速度比AOF快。（3）非常适用于备份。 | （1）AOF的策略是每秒钟或者每次发生写操作的时候都会同步，因此即使服务器故障，最多只会丢失1秒的数据。 （2）AOF存储的是Redis命令，并且是直接追加到aof文件后面，因此每次备份的时候只要添加新的数据进去就可以了。（3）如果AOF文件比较大了，那么Redis会进行重写，只保留最小的命令集合。 | | 缺点 | （1）RDB在多少时间内发生了多少写操作的时候就会出发同步机制，因为采用压缩机制，RDB在同步的时候都重新保存整个Redis中的数据，因此你一般会设置在最少5分钟才保存一次数据。在这种情况下，一旦服务器故障，会造成5分钟的数据丢失。（2）在数据保存进RDB的时候，Redis会fork出一个子进程用来同步，在数据量比较大的时候，可能会非常耗时。 | （1）AOF文件因为没有压缩，因此体积比RDB大。 （2）AOF是在每秒或者每次写操作都进行备份，因此如果并发量比较大，效率可能有点慢。（3）AOF文件因为存储的是命令，因此在灾难恢复的时候Redis会重新运行AOF中的命令，速度不及RDB。 | | 更多 | <a href="http://redisdoc.com/topic/persistence.html#redis" target="_blank" rel="noopener">http://redisdoc.com/topic/persistence.html#redis</a> | |</p><p>安全：在配置文件中，设置requirepass password，那么客户端连接的时候，需要使用密码：</p><blockquote><p>redis-cli -p 127.0.0.1 -p 6379<br> redis&gt; set username xxx<br> (error) NOAUTH Authentication required.<br> redis&gt; auth password<br> redis&gt; set username xxx<br> OK<br>Python操作redis<br>安装python-redis：</p></blockquote><p> pip install redis<br>新建一个文件比如redis_test.py，然后初始化一个redis实例变量，并且在ubuntu虚拟机中开启redis。比如虚拟机的ip地址为192.168.174.130。示例代码如下：</p><h1 id="从redis包中导入Redis类"><a href="#从redis包中导入Redis类" class="headerlink" title="从redis包中导入Redis类"></a>从redis包中导入Redis类</h1><p> from redis import Redis</p><h1 id="初始化redis实例变量"><a href="#初始化redis实例变量" class="headerlink" title="初始化redis实例变量"></a>初始化redis实例变量</h1><p> xtredis = Redis(host=’192.168.174.130’,port=6379)<br>对字符串的操作：操作redis的方法名称，跟之前使用redis-cli一样，现就一些常用的来做个简单介绍，示例代码如下(承接以上的代码)：</p><h1 id="添加一个值进去，并且设置过期时间为60秒，如果不设置，则永远不会过期"><a href="#添加一个值进去，并且设置过期时间为60秒，如果不设置，则永远不会过期" class="headerlink" title="添加一个值进去，并且设置过期时间为60秒，如果不设置，则永远不会过期"></a>添加一个值进去，并且设置过期时间为60秒，如果不设置，则永远不会过期</h1><p> xtredis.set(‘username’,’xiaotuo’,ex=60)</p><h1 id="获取一个值"><a href="#获取一个值" class="headerlink" title="获取一个值"></a>获取一个值</h1><p> xtredis.get(‘username’)</p><h1 id="删除一个值"><a href="#删除一个值" class="headerlink" title="删除一个值"></a>删除一个值</h1><p> xtredis.delete(‘username’)</p><h1 id="给某个值自增1"><a href="#给某个值自增1" class="headerlink" title="给某个值自增1"></a>给某个值自增1</h1><p> xtredis.set(‘read_count’,1)<br> xtredis.incr(‘read_count’)  # 这时候read_count变为2</p><h1 id="给某个值减少1"><a href="#给某个值减少1" class="headerlink" title="给某个值减少1"></a>给某个值减少1</h1><p> xtredis.decr(‘read_count’) # 这时候read_count变为1<br>对列表的操作：同字符串操作，所有方法的名称跟使用redis-cli操作是一样的：</p><h1 id="给languages这个列表往左边添加一个python"><a href="#给languages这个列表往左边添加一个python" class="headerlink" title="给languages这个列表往左边添加一个python"></a>给languages这个列表往左边添加一个python</h1><p> xtredis.lpush(‘languages’,’python’)</p><h1 id="给languages这个列表往左边添加一个php"><a href="#给languages这个列表往左边添加一个php" class="headerlink" title="给languages这个列表往左边添加一个php"></a>给languages这个列表往左边添加一个php</h1><p> xtredis.lpush(‘languages’,’php’)</p><h1 id="给languages这个列表往左边添加一个javascript"><a href="#给languages这个列表往左边添加一个javascript" class="headerlink" title="给languages这个列表往左边添加一个javascript"></a>给languages这个列表往左边添加一个javascript</h1><p> xtredis.lpush(‘languages’,’javascript’)</p><h1 id="获取languages这个列表中的所有值"><a href="#获取languages这个列表中的所有值" class="headerlink" title="获取languages这个列表中的所有值"></a>获取languages这个列表中的所有值</h1><p> print xtredis.lrange(‘languages’,0,-1)</p><blockquote><p>[‘javascript’,’php’,’python’]<br>对集合的操作：</p></blockquote><h1 id="给集合team添加一个元素xiaotuo"><a href="#给集合team添加一个元素xiaotuo" class="headerlink" title="给集合team添加一个元素xiaotuo"></a>给集合team添加一个元素xiaotuo</h1><p> xtredis.sadd(‘team’,’xiaotuo’)</p><h1 id="给集合team添加一个元素datuo"><a href="#给集合team添加一个元素datuo" class="headerlink" title="给集合team添加一个元素datuo"></a>给集合team添加一个元素datuo</h1><p> xtredis.sadd(‘team’,’datuo’)</p><h1 id="给集合team添加一个元素slice"><a href="#给集合team添加一个元素slice" class="headerlink" title="给集合team添加一个元素slice"></a>给集合team添加一个元素slice</h1><p> xtredis.sadd(‘team’,’slice’)</p><h1 id="获取集合中的所有元素"><a href="#获取集合中的所有元素" class="headerlink" title="获取集合中的所有元素"></a>获取集合中的所有元素</h1><p> xtredis.smembers(‘team’)</p><blockquote><p>[‘datuo’,’xiaotuo’,’slice’] # 无序的<br>对哈希(hash)的操作：</p></blockquote><h1 id="给website这个哈希中添加baidu"><a href="#给website这个哈希中添加baidu" class="headerlink" title="给website这个哈希中添加baidu"></a>给website这个哈希中添加baidu</h1><p> xtredis.hset(‘website’,’baidu’,’baidu.com’)</p><h1 id="给website这个哈希中添加google"><a href="#给website这个哈希中添加google" class="headerlink" title="给website这个哈希中添加google"></a>给website这个哈希中添加google</h1><p> xtredis.hset(‘website’,’google’,’google.com’)</p><h1 id="获取website这个哈希中的所有值"><a href="#获取website这个哈希中的所有值" class="headerlink" title="获取website这个哈希中的所有值"></a>获取website这个哈希中的所有值</h1><p> print xtredis.hgetall(‘website’)</p><blockquote><p>{“baidu”:”baidu.com”,”google”:”google.com”}<br>事务(管道)操作：redis支持事务操作，也即一些操作只有统一完成，才能算完成。否则都执行失败，用python操作redis也是非常简单，示例代码如下：</p></blockquote><h1 id="定义一个管道实例"><a href="#定义一个管道实例" class="headerlink" title="定义一个管道实例"></a>定义一个管道实例</h1><p> pip = xtredis.pipeline()</p><h1 id="做第一步操作，给BankA自增长1"><a href="#做第一步操作，给BankA自增长1" class="headerlink" title="做第一步操作，给BankA自增长1"></a>做第一步操作，给BankA自增长1</h1><p> pip.incr(‘BankA’)</p><h1 id="做第二步操作，给BankB自减少1"><a href="#做第二步操作，给BankB自减少1" class="headerlink" title="做第二步操作，给BankB自减少1"></a>做第二步操作，给BankB自减少1</h1><p> pip.desc(‘BankB’)</p><h1 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h1><p> pip.execute()<br>以上便展示了python-redis的一些常用方法，如果想深入了解其他的方法，可以参考python-redis的源代码（查看源代码pycharm快捷键提示：把鼠标光标放在import Redis的Redis上，然后按ctrl+b即可进入）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis教程：&quot;&gt;&lt;a href=&quot;#redis教程：&quot; class=&quot;headerlink&quot; title=&quot;redis教程：&quot;&gt;&lt;/a&gt;redis教程：&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://puguojing.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://puguojing.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>memcached（1）- 调试使用</title>
    <link href="http://puguojing.com/2018/10/12/memcached%EF%BC%881%EF%BC%89-%20%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://puguojing.com/2018/10/12/memcached（1）- 调试使用/</id>
    <published>2018-10-12T13:07:03.000Z</published>
    <updated>2018-11-06T03:16:38.860Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mac-memcached的调试"><a href="#Mac-memcached的调试" class="headerlink" title="Mac memcached的调试"></a>Mac memcached的调试</h4><h5 id="1-安装："><a href="#1-安装：" class="headerlink" title="1.安装："></a>1.安装：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install memcached</span><br></pre></td></tr></table></figure><h5 id="2-启动："><a href="#2-启动：" class="headerlink" title="2.启动："></a>2.启动：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcached -d -p 11211 -u nobody -c 1024 -m 64</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-d：这个参数是让memcached在后台运行（启动一个守护进程）。</span><br><span class="line">-m：指定占用多少内存。以M为单位，默认为64M。</span><br><span class="line">-u是运行Memcache的用户，我这里是nobody</span><br><span class="line">-p：设置Memcache监听的端口,最好是1024以上的端口，默认端口是11211。</span><br><span class="line">-l：别的机器可以通过哪个ip地址连接到我这台服务器。如果是通过service memcached </span><br><span class="line">start的方式，那么只能通过本机连接。如果想要让别的机器连接，就必须设置-l 0.0.0.0。</span><br><span class="line">-c选项是最大运行的并发连接数，默认是1024，按照你服务器的负载量来设定</span><br></pre></td></tr></table></figure><h5 id="3-Telnet连接"><a href="#3-Telnet连接" class="headerlink" title="3.Telnet连接"></a>3.Telnet连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 11211</span><br></pre></td></tr></table></figure><h5 id="telnet操作memcached"><a href="#telnet操作memcached" class="headerlink" title="telnet操作memcached:"></a>telnet操作memcached:</h5><p>memcached的数据是以 key:value 方式存储在内存中，所以我们一般对key 进行操作，而value保存实际的值。</p><h6 id="1-set：添加或更新数据："><a href="#1-set：添加或更新数据：" class="headerlink" title="1.set：添加或更新数据："></a>1.set：添加或更新数据：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">  set key flas(是否压缩) timeout(存储的时间,0代表一直存储) value_length(value的长度)</span><br><span class="line">  value</span><br><span class="line">示例：</span><br><span class="line">  set username 0 60 7</span><br><span class="line">  zhiliao</span><br></pre></td></tr></table></figure><p>注意指定的value长度和实际输入value的长度必须一致，否则按Enter键后会出现ERROR(如果实际的value长度大于指定的长度)或者一直等到你输入完指定的字符数。</p><h6 id="2-add：添加数据"><a href="#2-add：添加数据" class="headerlink" title="2.add：添加数据"></a>2.add：添加数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">  add key flas(是否压缩) timeout(存储的时间,0代表一直存储) value_length(value的长度)</span><br><span class="line">  value</span><br><span class="line">示例：</span><br><span class="line">  add username 0 60 7</span><br><span class="line">  xiaotuo</span><br></pre></td></tr></table></figure><p>set和add的区别：add是只负责添加数据，不会去修改数据。如果添加的数据的key已经存在了，则添加失败，如果添加的key不存在，则添加成功。而set不同，如果memcached中不存在相同的key，则进行添加，如果存在，则替换。</p><p>set、add执行成功后会显示：STORED，未执行成功会显示：NOT STORED </p><h6 id="3-get：获取数据"><a href="#3-get：获取数据" class="headerlink" title="3.get：获取数据"></a>3.get：获取数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">  get key</span><br><span class="line">示例：</span><br><span class="line">  get username</span><br></pre></td></tr></table></figure><h6 id="4-delete-删除数据"><a href="#4-delete-删除数据" class="headerlink" title="4.delete:删除数据"></a>4.delete:删除数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">  delete key</span><br><span class="line">示例：</span><br><span class="line">  delete username</span><br></pre></td></tr></table></figure><h6 id="5-flush-all：删除memcached中的所有数据。"><a href="#5-flush-all：删除memcached中的所有数据。" class="headerlink" title="5.flush_all：删除memcached中的所有数据。"></a>5.flush_all：删除memcached中的所有数据。</h6><h6 id="6-incr-给memcached中数字类型的值进行相加操作，相加的项必须也是数字类型。"><a href="#6-incr-给memcached中数字类型的值进行相加操作，相加的项必须也是数字类型。" class="headerlink" title="6.incr:给memcached中数字类型的值进行相加操作，相加的项必须也是数字类型。"></a>6.incr:给memcached中数字类型的值进行相加操作，相加的项必须也是数字类型。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">语法：</span><br><span class="line">incr key num(num表示要加的值，必须是数字)</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">incr age 2   给key是age的值加上2</span><br></pre></td></tr></table></figure><h6 id="7-decr-给memcached中数字类型的值进行减操作，相减的项必须也是数字类型。"><a href="#7-decr-给memcached中数字类型的值进行减操作，相减的项必须也是数字类型。" class="headerlink" title="7.decr:给memcached中数字类型的值进行减操作，相减的项必须也是数字类型。"></a>7.decr:给memcached中数字类型的值进行减操作，相减的项必须也是数字类型。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">decr key num(num表示要减的值，必须是数字)</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">devr age 2   给key是age的值减去2</span><br></pre></td></tr></table></figure><h6 id="8-stats：查看memcached的当前状态，可以查看自己的操作记录和正确执行数据，以分析memcached的命中率（正确率）"><a href="#8-stats：查看memcached的当前状态，可以查看自己的操作记录和正确执行数据，以分析memcached的命中率（正确率）" class="headerlink" title="8.stats：查看memcached的当前状态，可以查看自己的操作记录和正确执行数据，以分析memcached的命中率（正确率）"></a>8.stats：查看memcached的当前状态，可以查看自己的操作记录和正确执行数据，以分析memcached的命中率（正确率）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">stats</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">STAT pid 5286</span><br><span class="line">STAT uptime 3741</span><br><span class="line">STAT time 1539349048</span><br><span class="line">STAT version 1.5.3</span><br><span class="line">...</span><br><span class="line">STAT cmd_get 9   #表示进行实际get的次数</span><br><span class="line">STAT cmd_set 16  #表示进行实际get的次数</span><br><span class="line">STAT cmd_flush 1</span><br><span class="line">STAT cmd_touch 0</span><br><span class="line">STAT get_hits 7  #表示get命中(有效)的次数</span><br><span class="line">...</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>常见的：<br>STAT cmd_get 9  表示进行实际get的次数<br>STAT cmd_set 16  表示进行实际set的次数<br>STAT get_hits 7  表示get命中(有效)的次数<br>STAT curr_items 4 表示当前有多少条数据</p><p>stats之后会显示很多结果常用的就是查看set、get等操作的cmd_get/set 数量和 get_hits 数量  用类似: get_hits/cmd_get  的结果反映当前memcached的状态，如果命中率良好，说明memcached的状态良好，反之说明memcached的状态较差，比如可能碎片较多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Mac-memcached的调试&quot;&gt;&lt;a href=&quot;#Mac-memcached的调试&quot; class=&quot;headerlink&quot; title=&quot;Mac memcached的调试&quot;&gt;&lt;/a&gt;Mac memcached的调试&lt;/h4&gt;&lt;h5 id=&quot;1-安装：&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://puguojing.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="memcached" scheme="http://puguojing.com/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的left join、right join 以及inner join之间的区别</title>
    <link href="http://puguojing.com/2018/10/08/Mysql%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E6%8E%A5%E3%80%81%E5%B7%A6%E5%A4%96%E8%81%94%E6%8E%A5%E3%80%81%E5%8F%B3%E5%A4%96%E8%81%94%E6%8E%A5/"/>
    <id>http://puguojing.com/2018/10/08/Mysql中的内联接、左外联接、右外联接/</id>
    <published>2018-10-08T06:29:15.000Z</published>
    <updated>2018-11-06T03:17:21.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sql语句中left-join、right-join-以及inner-join之间的区别"><a href="#sql语句中left-join、right-join-以及inner-join之间的区别" class="headerlink" title="sql语句中left join、right join 以及inner join之间的区别"></a>sql语句中left join、right join 以及inner join之间的区别</h3><p>left [outer] join(左联接)： 返回包括左表中的所有记录和右表中联结字段相等的记录 。<br>right [outer] join(右联接) ：返回包括右表中的所有记录和左表中联结字段相等的记录。<br>inner join(等值连接) ：只返回两个表中联结字段相等的行。</p><blockquote><p>左联接和右联接统称为外联接，其中的outer关键字可以省略。</p></blockquote><blockquote><p>左连接和右连接的区别在于以哪个表为主（主表中的数据都会出现在表中）</p></blockquote><h3 id="举例如下："><a href="#举例如下：" class="headerlink" title="举例如下："></a>举例如下：</h3><p>表A记录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aID　　　　　aNum</span><br><span class="line">1　　　　　a20050111</span><br><span class="line">2　　　　　a20050112</span><br><span class="line">3　　　　　a20050113</span><br><span class="line">4　　　　　a20050114</span><br><span class="line">5　　　　　a20050115</span><br></pre></td></tr></table></figure><p>表B记录如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bID　　　　　bName</span><br><span class="line">1　　　　　2006032401</span><br><span class="line">2　　　　　2006032402</span><br><span class="line">3　　　　　2006032403</span><br><span class="line">4　　　　　2006032404</span><br><span class="line">8　　　　　2006032408</span><br></pre></td></tr></table></figure><p>-</p><h4 id="1-left-join"><a href="#1-left-join" class="headerlink" title="1.left join"></a>1.left join</h4><p>sql语句如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">left join B </span><br><span class="line">on A.aID = B.bID</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aID　　　　　aNum　　　　　bID　　　　　bName</span><br><span class="line">1　　　　　a20050111　　　　1　　　　　2006032401</span><br><span class="line">2　　　　　a20050112　　　　2　　　　　2006032402</span><br><span class="line">3　　　　　a20050113　　　　3　　　　　2006032403</span><br><span class="line">4　　　　　a20050114　　　　4　　　　　2006032404</span><br><span class="line">5　　　　　a20050115　　　　NULL　　　　　NULL</span><br></pre></td></tr></table></figure><p>（所影响的行数为 5 行）<br>结果说明:<br>left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.</p><p>换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID).<br>B表记录不足的地方均为NULL.</p><p>-</p><h4 id="2-right-join"><a href="#2-right-join" class="headerlink" title="2.right join"></a>2.right join</h4><p>sql语句如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">right join B </span><br><span class="line">on A.aID = B.bID</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aID　　　　　aNum　　　　　bID　　　　　bName</span><br><span class="line">1　　　　　a20050111　　　　1　　　　　2006032401</span><br><span class="line">2　　　　　a20050112　　　　2　　　　　2006032402</span><br><span class="line">3　　　　　a20050113　　　　3　　　　　2006032403</span><br><span class="line">4　　　　　a20050114　　　　4　　　　　2006032404</span><br><span class="line">NULL　　　　　NULL　　　　　8　　　　　2006032408</span><br></pre></td></tr></table></figure><p>（所影响的行数为 5 行）<br>结果说明:<br>仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.</p><p>-</p><h4 id="3-inner-join"><a href="#3-inner-join" class="headerlink" title="3.inner join"></a>3.inner join</h4><p>sql语句如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from A</span><br><span class="line">innerjoin B </span><br><span class="line">on A.aID = B.bID</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aID　　　　　aNum　　　　　bID　　　　　bName</span><br><span class="line">1　　　　　a20050111　　　　1　　　　　2006032401</span><br><span class="line">2　　　　　a20050112　　　　2　　　　　2006032402</span><br><span class="line">3　　　　　a20050113　　　　3　　　　　2006032403</span><br><span class="line">4　　　　　a20050114　　　　4　　　　　2006032404</span><br></pre></td></tr></table></figure><p>结果说明:<br>很明显,这里只显示出了 A.aID = B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.</p><p>-</p><p>注:<br>LEFT JOIN操作用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，即使在第二个（右边）表中并没有相符值的记录。</p><p>语法：<code>FROM table1 LEFT JOIN table2 ON table1.field1 compopr table2.field2</code><br>说明：table1, table2参数用于指定要将记录组合的表的名称。</p><p>field1, field2参数指定被联接的字段的名称。且这些字段必须有相同的数据类型及包含相同类型的数据，但它们不需要有相同的名称。</p><p>compopr参数指定关系比较运算符：”=”， “&lt;”， “&gt;”， “&lt;=”， “&gt;=” 或 “&lt;&gt;”。</p><p>如果在INNER JOIN操作中要联接包含Memo 数据类型或 OLE Object 数据类型数据的字段，将会发生错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;sql语句中left-join、right-join-以及inner-join之间的区别&quot;&gt;&lt;a href=&quot;#sql语句中left-join、right-join-以及inner-join之间的区别&quot; class=&quot;headerlink&quot; title=&quot;sql语
      
    
    </summary>
    
      <category term="技术" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://puguojing.com/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Python" scheme="http://puguojing.com/tags/Python/"/>
    
      <category term="数据库" scheme="http://puguojing.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://puguojing.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
