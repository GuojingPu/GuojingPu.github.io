{"meta":{"title":"心小天个人博客","subtitle":"生活不止coding,还有诗和远方。","description":"生活不止coding,还有诗和远方。","author":"心小天","url":"http://puguojing.com"},"pages":[{"title":"about","date":"2018-11-05T08:08:55.000Z","updated":"2018-11-05T08:08:55.344Z","comments":true,"path":"about/index.html","permalink":"http://puguojing.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-05T07:54:52.000Z","updated":"2018-11-05T07:55:16.783Z","comments":true,"path":"categories/index.html","permalink":"http://puguojing.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-05T07:48:59.000Z","updated":"2018-11-05T07:53:12.387Z","comments":true,"path":"tags/index.html","permalink":"http://puguojing.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"集群介绍及配置","slug":"集群介绍及配置","date":"2018-11-09T15:13:23.000Z","updated":"2018-11-09T15:13:23.651Z","comments":true,"path":"2018/11/09/集群介绍及配置/","link":"","permalink":"http://puguojing.com/2018/11/09/集群介绍及配置/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"项目部署之阿里云服务器环境配置、数据库安装","slug":"项目部署之阿里云服务器环境配置、数据库安装","date":"2018-11-06T13:33:50.000Z","updated":"2018-11-18T16:12:49.090Z","comments":true,"path":"2018/11/06/项目部署之阿里云服务器环境配置、数据库安装/","link":"","permalink":"http://puguojing.com/2018/11/06/项目部署之阿里云服务器环境配置、数据库安装/","excerpt":"","text":"今天主要讲使用阿里云服务器部署项目，首先介绍一下我的阿里云系统是Ubuntu 16.04 64位的版本。 登录阿里云服务器首先使用ssh登陆阿里云服务器： 阿里云服务默认是使用的root用户，所以不需要我们再开启root用户了，如果你没有开启root用户，可以使用sudo passwd root命令，然后输入2遍root密码开启root。 ##修改apt的安装源 对于原版的ubuntu系统apt的安装包的源是国外的，我们可以在 1/etc/apt/source.list 文件中查看apt源,但是更好的是我们可以把apt源替换成国内的源。 为了避免出错你可以首先备份一下source.list cd 到/etc/apt/目录下执行： 1cp source.list source.list.bak 会把source.list拷贝一份并命令为source.list.bak。 然后我们可以删除source.list内容，把内容替换成下面的源： 1234567891011121314151617deb-src http://archive.ubuntu.com/ubuntu xenial main restricteddeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universedeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 然后执行： 1sudo apt update 更新源。 但其实阿里云服务器的Ubuntu系统本身已经帮你修改好了apt的源，所以你在使用阿里云服务器的Ubuntu系统时并不需要执行上面的操作，你只需要在使用apt 安装一些软件之前执行：sudo apt update就好了。 安装Vim你可以使用： 1sudo apt install vim 安装vim ，当然由于你现在可能是root用户，所以你不需要加sudo 直接输入： 1apt install vim 就可以安装。但是更好的是阿里云服务器其实已经帮你安装了vim，所以你根本不需要在安装。你可以在终端输入： 1vim 他会显示如下的信息给你，说明你已经安装了vim 安装mysql 数据库使用如下命令安装mysql数据库： 1sudo apt install mysql-server mysql-client 在安装的时候会让你设定数据库的密码，输入自己想设定的数据库密码即可。 安装完成后可以使用： 1mysql --help 查看是否安装成功，更确定的是我们可以尝试使用一下mysql,输入： 1mysql -uroot -p 会提示你输入数据库的密码（就是你在安装数据的时候设定的）你也可以尝试查看一些数据库： 1mysql&gt; show database; 注意别忘了最后的分号。最后输入quit;退出mysql。 安装memcached：通过命令： 1apt install memcached 即可安装。然后测试一下: 1telnet 127.0.0.1 11211 再尝试存储一下数据： 12set username 0 60 5hello 然后在获取一下数据： 1get username 发现可以操作时说明没问题。(输入quit退出memcached) 安装python3Ubuntu系统会自己默认给我们安装python2.7，你可以使用python -V查看当前的python 版本。但是由于我们使用的是python3所以还需要安装python3: 1sudo apt install python3 安装完成后可以使用： 1python3 -V 查看一下 安装完python3之后还需要安装python3对应的pip(pip不懂的话请请自行谷歌) 1sudo apt install python3-pip 这里会安装python3对应使用的pip3 pip 是用来管理python的包的工具，直接输入python默认代表的python2，对应的pip是pip2，所以输入时python、pip代表的分别是python2和pip2。而如果想使用python3版本就需要输入：python3和pip3。这里的系统默认安装的是python2 和pip2但是我们需要python3和pip3,所以需要重新安装。 安装完pip3之后可以查看一下pip的版本： 可以看到pip和pip3的版本都是8.1,但是我们需要使用最新的pip3的包，所以需要更新pip3（由于pip2我们不使用所以就不更新了） 1pip3 install --upgrade pip 但是会报如下错误： 这主要是因为pip3新旧版本的问题。 我们尝试修改一下/usr/bin/pip3中的内容就。打开/usr/bin/pip3 1vim /usr/bin/pip3 内容如下: 12345678910111213#!/usr/bin/python3# GENERATED BY DEBIANimport sys# Run the main entry point, similarly to how setuptools does it, but because# we didn&apos;t install the actual entry point from setup.py, don&apos;t use the# pkg_resources API.from pip import mainif __name__ == &apos;__main__&apos;: sys.exit(main())~~ 修改为： 123from pip import __main__ if __name__ == &apos;__main__&apos;: sys.exit(__main__._main()) 如果还报错，直接重新强制升级安装： 1sudo python3 -m pip install --upgrade --force-reinstall pip 重新查看一下： 1pip3 --version 更新到了18.1 安装virtualenvwrapper，1pip3 install virtualenvwrapper 安装完成之后我们还需要做一些配置：1.在用户目录下（cd ~/）新建一个文件夹“.vitualenvs”用来存放我们的虚拟环境 12cd ~/mkdir .virtualenvs 然后执行ls -al看一下： 发现 .virtualenvs 文件夹 2.配置环境变量我们安装完成之后还无法使用virtualenvwrapper命令，还需要配置环境变量。先执行： 1which virtualenvwrapper.sh 看一下我们的virtualenvwrapper路径 在： 1/usr/local/bin/virtualenvwrapper.sh 路径下。 然后 打开用户目录下的 .bashrc文件在最后添加下面代码: 12export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.sh 然后退出.bashrc文件，输入命令source ~/.bashrc使.bashrc生效。 接下来我们就可以使用命令来创建虚拟环境变量了：（由于我们的virtualenvwrapper安装在了pyton3环境中所以可以直接创建） 1mkvirtualenv xfz-env 注意：如果你把virtualenvwrapper安装在了python2的环境中，在创建虚拟环境的时候需要使用–python参数指定使用哪个Python文件，安装python3的路径是在/usr/bin/python3。那么示例代码如下： 1mkvirtualenv --python=/usr/bin/python3 xfz-env 创建完成可以在“。virtualenvs”目录下查看env环境： 你可以使用： 1workon xfz-env 进入到指定的虚拟环境 注意在source .bashrc如果出现以下错误: 1234567No module named virtualenvwrappervirtualenvwrapper.sh: There was a problem running the initialization hooks.If Python could not import the module virtualenvwrapper.hook_loader,check that virtualenvwrapper has been installed forVIRTUALENVWRAPPER_PYTHON=/usr/bin/python and that PATH isset properly. 那么在 .bashrc 加入: 1export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 从远程仓库下载代码我们应该应该吧完整的代码上传到了自己的GitHub或者码云中，接下来我们需要从远程仓库把代码pull到服务器： 1.首先进入到 “/src”，cd /src2.在/src下新建一个项目文件夹，比如我的是 1mkdir xiaofaozhuo 3.然后进入xiaofaozhuo文件夹执行： 123git initgit remote add origin https://gitee.com/PuGuoJing/xiaofanzhuogit pull origin master 如果没有安装git 执行： 1apt install git 安装git。 这样你就可以把所有的远程代码下载到服务器了。 安装require.txt依赖包进入自己的虚拟环境中，然后进入到项目所在的目录，执行命令： 1pip3 install -r requirements.txt 安装项目依赖的包。如果提示OSError: mysql_config not found，那么再安装: 1sudo apt install libmysqld-dev 即可。 注意短信验证码的包需要单独安装。把dysms_python文件夹上传到项目中，然后进入到这个文件夹中。执行命令：python setup.py install。 对于一些第三方的无法通过pip安装的包，这里我们需要手动安装，比如这里的阿里云短信验证码服务就需要通过setup.py手动安装。 创建数据库在安装好所有的环境之后，我们需要创建我们项目使用的数据库。 首先进入我们的数据：1mysql -uroot -p 然后执行： 1create database xfz; 创建我们所使用的数据xfz。创建完成后我们可以使用： 1show databases; 查看数据库。之后我们进入到项目根路径执行: 12python3 manage.py makemigrationspython3 manage.py migrate 将模型映射到数据库中，这样我们的数据库创建成功，可以使用了。 在数据库创建成功之后其实我们往往还需要一个需求，就是我们想可以在远程使用navcat去连接查看我们的数据库，那接下来我们还需要做下面几件事。 1.开启阿里云网络安全组中的3306端口的防火墙。具体如何开启请开我的另一篇博客Mac下购买配置和访问阿里云服务器的详细步骤中的[MAC使用ssh远程连接阿里云服务器]**[添加网络安全组]** 或者自行百度。 2.为我们的数据库创建用户授权，这样才可以远程连接。具体参考：阿里云远程连接数据库 3.修改我们的数据库中的配置文件ALLOW_HOST,如果该配置为127.0.0.1，请删除或注释掉此行。 注意windows下mysql配置文件是.ini文件，linux下是.cnf文件，请找到自己对应的配置文件修改。 linux 一般在/etc/mysql/下有mysqld.cnf但是博主的是在： 1/etc/mysql/mysql.conf.d/mysqld.cnf 下所以根据自己的情况查找。 在配置好上述之后一般就可以通过navcat远程连接我们的数据库了。用户名和密码就是你在第二部开启权限的用户名密码。 测试运行项目首先我们需要修改setting.py中的ALLOW_HOST=[47.92.52.97]，即我们阿里云服务器的公网Ip这样就可以通过其他电脑访问我们的服务器了。 然后我们在项目下执行: 1python3 manage.py runserver 0.0.0.0:8000 这样就可以通过Ip:8000 来访问我们的网站了，在网站地址栏输入：http://47.92.53.97：8000就可以看到我们的网站了，但是这个时候可能会有一些显示问题，这主要是我们的静态文件未正确加载。 收集静态文件（css\\js\\image）项目中我们的静态文件一般都是分散的。不方便服务器处理，所以我们需要把所有的静态文件收集到一个文件夹中： 首先在我们在项目下新建议各位空文件夹: 1mkdir static_dist 用来存放素有的静态文件，然后在setting.py中配置: 1STATIC_ROOT= os.path.join(BASE_DIR,&apos;static_dist&apos;) 然后执行: 1python manage.py collectstatic collectstatic 会收集setting.py中的STATICFILES_DIRS 指定的目录所有的静态文件和各个app下的static下的静态文件到static_dist文件夹中。具体参考django文档。 安装配置uwsgiuwsgi是一个应用服务器，非静态文件的网络请求就必须通过他完成，他也可以充当静态文件服务器，但不是他的强项。uwsgi是使用python编写的，因此通过pip3 install uwsgi就可以了。(uwsgi必须安装在系统级别的Python环境中，不要安装到虚拟环境中)。然后创建一个叫做uwsgi.ini的配置文件（原则上可以在任何位置创建，这里我们可以在项目目录里创建）： 123456789101112131415161718192021222324[uwsgi]# 必须全部为绝对路径# 项目的路径chdir = /srv/xiaofanzhuan #表示我们项目在服务器中的绝对路径 # Django的wsgi文件module = xiaofanzhuan.wsgi #指定我们项目中的wsgi文件# Python虚拟环境的路径home = /root/.virtualenvs/xfz-env# 进程相关的设置# 主进程master = true# 最大数量的工作进程processes = 10http = :8000 #运行端口# 设置socket的权限chmod-socket = 666 #socket用用和nginx通信# 退出的时候是否清理环境vacuum = truedaemonize = /var/log/xfz_uwsgi.log #指定log文件位置，一般的错误信息全在里面 然后通过命令uwsgi –ini uwsgi.ini运行，确保没有错误。然后在浏览器中访问http://ip地址:8000，如果能够访问到页面（可能没有静态文件）说明uwsgi配置没有问题。 通过ps aux | grep uwsgi 查看uwsgi运行情况，使用kill -9 第一个uwsgi pid 关闭uwsgi运行。 安装配置niginx虽然uwsgi可以正常的部署我们的项目了。但我们还是依然要采用nginx来作为web服务器。使用nginx来作为web服务器有以下好处： uwsgi对静态文件资源处理并不好，包括响应速度，缓存等。nginx作为专业的web服务器，暴露在公网上会比uwsgi更加安全一点。运维起来更加方便。比如要将某些IP写入黑名单，nginx可以非常方便的写进去。而uwsgi可能还要写一大段代码才能实现。 安装：通过apt install nginx即可安装。 nginx简单操作命令：启动：service nginx start关闭：service nginx stop重启：service nginx restart测试配置文件：service nginx configtest 添加配置文件：在/etc/nginx/conf.d目录下，新建一个文件，叫做zhiliaoketang.conf，然后将以下代码粘贴进去： 12345678910111213141516171819202122232425262728upstream zhiliaoketang &#123; server unix:///srv/zhiliaoketang/zhiliaoketang.sock; &#125;# 配置服务器server &#123; # 监听的端口号 listen 80; # 域名 server_name 192.168.0.101; charset utf-8; # 最大的文件上传尺寸 client_max_body_size 75M; # 静态文件访问的url location /static &#123; # 静态文件地址 alias /srv/zhiliaoketang/static_dist; &#125; # 最后，发送所有非静态文件请求到django服务器 location / &#123; uwsgi_pass zhiliaoketang; # uwsgi_params文件地址 include /etc/nginx/uwsgi_params; &#125;&#125; 写完配置文件后，为了测试配置文件是否设置成功，运行命令：service nginx configtest，如果不报错，说明成功。每次修改完了配置文件，都要记得运行service nginx restart。 uwsgi 和nginx的关系及他们各自的作用。使用supervisor管理uwsgi进程：让supervisor管理uwsgi，可以在uwsgi发生意外的情况下，会自动的重启。 安装supervisor：因为supervisor是用python写成的，所以通过pip即可安装。并且因为supervisor不支持python3，因此需要把supervisor安装在python2的环境中。pip2 install supervisor。 启动：在项目的根目录下创建一个文件叫做supervisor.conf，然后将以下代码填入到配置文件中： 1234567891011121314151617181920212223242526272829303132333435363738394041# supervisor的程序名字 [program:mysite] # supervisor执行的命令 command=uwsgi --ini zlkt_uwsgi.ini # 项目的目录 directory = /srv/zhiliaoketang # 开始的时候等待多少秒 startsecs=0 # 停止的时候等待多少秒 stopwaitsecs=0 # 自动开始 autostart=true # 程序挂了后自动重启 autorestart=true # 输出的log文件 stdout_logfile=/srv/zhiliaoketang/log/supervisord.log # 输出的错误文件 stderr_logfile=/srv/zhiliaoketang/log/supervisord.err [supervisord] # log的级别 loglevel=debug [inet_http_server] # supervisor的服务器 port = :9001 # 用户名和密码 username = admin password = 123 # 使用supervisorctl的配置 [supervisorctl] # 使用supervisorctl登录的地址和端口号 serverurl = http://127.0.0.1:9001 # 登录supervisorctl的用户名和密码 username = admin password = 123 [rpcinterface:supervisor] supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface 然后使用命令supervisord -c supervisor.conf运行就可以了。以后如果想要启动uwsgi，就可以通过命令supervisorctl -c supervisor.conf进入到管理控制台，然后可以执行相关的命令进行管理： status # 查看状态start program_name #启动程序restart program_name #重新启动程序stop program_name # 关闭程序reload # 重新加载配置文件quit # 退出控制台","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"阿里云服务器","slug":"技术/阿里云服务器","permalink":"http://puguojing.com/categories/技术/阿里云服务器/"}],"tags":[{"name":"阿里云服务器","slug":"阿里云服务器","permalink":"http://puguojing.com/tags/阿里云服务器/"},{"name":"部署","slug":"部署","permalink":"http://puguojing.com/tags/部署/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"阿里云服务器","slug":"技术/阿里云服务器","permalink":"http://puguojing.com/categories/技术/阿里云服务器/"}]},{"title":"Mac下购买配置和访问阿里云服务器的详细步骤","slug":"Mac下购买配置和访问阿里云服务器的详细步骤","date":"2018-11-06T09:08:02.000Z","updated":"2018-11-06T10:58:45.294Z","comments":true,"path":"2018/11/06/Mac下购买配置和访问阿里云服务器的详细步骤/","link":"","permalink":"http://puguojing.com/2018/11/06/Mac下购买配置和访问阿里云服务器的详细步骤/","excerpt":"","text":"最近一直想买一个阿里云服务器玩玩，听说学生版的非常便宜一个月只要9.9元，但是我已经毕业了啊，所以忍痛买了一个入门一70.2元/月。 阿里云注册首先你需要注册一个阿里云账户或者不想注册直接使用自己的淘宝、支付宝账户登录也可以。你可以在这里注册 阿里云注册 阿里云翼计划如果你还是学生的话，那么恭喜你可以在这里加入阿里云翼计划一个月只需要9.5元！😍 阿里云服务器ECS购买那如果你和我一样不满足条云翼计划的条件那就只能在 【阿里云】-【产品】-【精选】-【云服务器ECS】(ECS是阿里云服务器的名字，腾讯的叫CVM，仅仅是一个名字而已) 在点击进入之后你会看到如下的界面： 1.点击立即购买，：2.你会看到一大堆你并不能看懂的配置，没关系，你可以直接选择【一键购买】 3.是不是开起来清爽多了？那这些配置分别代表什么意思呢？地域：表示你服务器的地理位置，具体不同的地理位置有什么区别，这个主要是访问者的距离服务器越远一般情况访问速度越慢，所以你看到发达的华东地区服务器稍微贵一点。你可以根据你的具体地理位置情况和money多少自由选择，哪一个区域都可以。但是要记住你自己所选择的区域，因为购买完成后我们要到这个区域的管理控制台下管理我们的服务器。 实例：就是购买的电脑主机了，具体配置怎么选择，关键看你的需求了，就像我们买电脑一样CPU、内存、磁盘大小，具体要看你来干什么，一般我就选最小的，因为我的网站就是个人小网站啊。 镜像：这个主要是我们购买的主机你想让他装什么样的操作系统和操作系统的版本，有Windows、linux两大类。至于你该如何选择主要参考你网站采用的技术，由于本人使用的是Python开发的网站,所以选择是Ubuntu，一款强大而简单的Linux发行版。 公网带宽：这个要取决你网站的访问量了，我当然选最低的了1Mbps对于我来说够了。 购买量：就是购买时间，你可以购买一周，这里楼主买了一个月。 4.选择完配置之后直接点击【立即购买】 5.勾选【云服务器ECS服务条款】-【去下单】 6.【确认支付】，然后使用支付宝扫码支付即可。 查看购买云服务器ECS1.在你购买完成之后一般会自动跳转到云服务器ECS管理控制台，你可以通过点击主页右上角的【控制台】进入控制台管理页面。 2.进入之后在左侧选择【云服务器ECS】 3.进入之后选择 左侧【实例】查看购买的云服务器。 4.如果在【实例】下没有找到云服务器的话，说明你可能没有切换到自己对应地理位置的控制台。你可以通过做左上角下拉选择自己购买时选择的服务器地理区域。 4.在这里可以看到【基本信息】【配置信息】【付费信息】【监控信息】等等。 连接阿里云服务器在这里面可以进行「远程连接」到你的服务器，但是在进行「远程连接」之前我们还需要配置一下我们的服务器用户密码： 1.点击【更多】【密码/密钥】【重置密码】，就可以自己设置登录密码了。 2.在设置完登录密码后需要重启服务器，你可以在【管理】中重启服务器： 然后我们就可以点击【远程连接】，第一次远程连接时会给你一个默认的6位密码，你也可以在上面的【重置密码】中找到【修改远程连接密码】进行修改自己的密码。在输入远程连接密码后会进入下面的界面，输入用户名和密码就可以登录了。 用户名默认是root,密码就是刚才我们重置的密码（不是远程连接密码）。 MAC使用ssh远程连接阿里云服务器不过阿里云提供的这个「远程连接」我们可肯定不太使用，所以我们会使用自己的ssh客户端登录阿里云主机。 但是在使用shh连接阿里云服务器之前我们还需要做一些安全设置，否则你用ssh连接或者ping公网ip都是会失败的，所以我们需要先进行设置。 1.点击「更多」-「安全组配置」-「配置规则」 2.点击「添加安全组规则」然后就开始添加规则了，可参考我的配置 然后我们来ping一下和尝试使用ssh登录：先看一下IP地址，在【实例】信息中查看 然后尝试ping和ssh登录： 查看远程网络是否正常连接： 1ping 47.93.53.97 远程登录：root用户名，按提示输入上面重置的登录密码 1ssh root@47.93.53.97 连接成功后就可以干自己的事情了！","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"阿里云","slug":"技术/阿里云","permalink":"http://puguojing.com/categories/技术/阿里云/"}],"tags":[{"name":"阿里云服务器","slug":"阿里云服务器","permalink":"http://puguojing.com/tags/阿里云服务器/"},{"name":"部署","slug":"部署","permalink":"http://puguojing.com/tags/部署/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"阿里云","slug":"技术/阿里云","permalink":"http://puguojing.com/categories/技术/阿里云/"}]},{"title":"常用书籍列表","slug":"常用书籍列表","date":"2018-11-06T06:13:44.000Z","updated":"2018-11-06T10:52:51.275Z","comments":true,"path":"2018/11/06/常用书籍列表/","link":"","permalink":"http://puguojing.com/2018/11/06/常用书籍列表/","excerpt":"","text":"python书籍列表","categories":[{"name":"工具","slug":"工具","permalink":"http://puguojing.com/categories/工具/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://puguojing.com/tags/书籍/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://puguojing.com/categories/工具/"}]},{"title":"随笔","slug":"随笔","date":"2018-11-06T03:32:20.000Z","updated":"2018-11-06T04:04:12.573Z","comments":true,"path":"2018/11/06/随笔/","link":"","permalink":"http://puguojing.com/2018/11/06/随笔/","excerpt":"","text":"正如你所看到的这里并没有什么内容…","categories":[{"name":"随笔","slug":"随笔","permalink":"http://puguojing.com/categories/随笔/"}],"tags":[],"keywords":[{"name":"随笔","slug":"随笔","permalink":"http://puguojing.com/categories/随笔/"}]},{"title":"Mac下Redis数据的安装、操作、配置","slug":"Redis数据库的数据类型及操作","date":"2018-10-16T07:49:56.000Z","updated":"2018-11-22T16:25:54.695Z","comments":true,"path":"2018/10/16/Redis数据库的数据类型及操作/","link":"","permalink":"http://puguojing.com/2018/10/16/Redis数据库的数据类型及操作/","excerpt":"","text":"redis教程：概述redis是一种nosql数据库,他的数据是保存在内存中，同时redis可以定时把内存数据同步到磁盘，即可以将数据持久化，并且他比memcached支持更多的数据结构(string,list列表[队列和栈],set[集合],sorted set[有序集合],hash(hash表))。相关参考文档：http://redisdoc.com/index.html redis使用场景： 登录会话存储：存储在redis中，与memcached相比，数据不会丢失。 排行版/计数器：比如一些秀场类的项目，经常会有一些前多少名的主播排名。还有一些文章阅读量的技术，或者新浪微博的点赞数等。 作为消息队列：比如celery就是使用redis作为中间人。 当前在线人数：还是之前的秀场例子，会显示当前系统有多少在线人数。 一些常用的数据缓存：比如我们的BBS论坛，板块不会经常变化的，但是每次访问首页都要从mysql中获取，可以在redis中缓存起来，不用每次请求数据库。 把前200篇文章缓存或者评论缓存：一般用户浏览网站，只会浏览前面一部分文章或者评论，那么可以把前面200篇文章和对应的评论缓存起来。用户访问超过的，就访问数据库，并且以后文章超过200篇，则把之前的文章删除。 好友关系：微博的好友关系使用redis实现。 发布和订阅功能：可以用来做聊天软件。redis和memcached的比较：memcached redis类型 |纯内存数据库 内存磁盘同步数据库数据类型 在定义value时就要固定数据类型 不需要虚拟内存 不支持 支持过期策略 支持 支持存储数据安全 不支持 可以将数据同步到dump.db中灾难恢复 不支持 可以将磁盘中的数据恢复到内存中分布式 支持 主从同步订阅与发布 不支持 支持 redis在ubuntu系统中的安装与启动 安装：1sudo apt-get install redis-server 卸载：1sudo apt-get purge --auto-remove redis-server 启动redis安装后，默认会自动启动，可以通过以下命令查看： 1ps aux|grep redis 如果想自己手动启动，可以通过以下命令进行启动： 1sudo service redis-server start 停止：1sudo service redis-server stop 对redis的操作对redis的操作可以用两种方式，第一种方式采用redis-cli，第二种方式采用编程语言，比如Python、PHP和JAVA等。 使用redis-cli对redis进行字符串操作：启动redis：1sudo service redis-server start 连接上redis-server：1redis-cli -h [ip] -p [端口] 添加：123set key value``` 如： set username xiaotuo` 将字符串值value关联到key。如果key已经持有其他值，set命令就覆写旧值，无视其类型。并且默认的过期时间是永久，即永远不会过期。 删除： del key 如： del username设置过期时间： expire key timeout(单位为秒)也可以在设置值的时候，一同指定过期时间： set key value EX timeout 或： setex key timeout value查看过期时间： ttl key 如： ttl username查看当前redis中的所有key： keys *列表操作： 在列表左边添加元素： lpush key value将值value插入到列表key的表头。如果key不存在，一个空列表会被创建并执行lpush操作。当key存在但不是列表类型时，将返回一个错误。 在列表右边添加元素： rpush key value将值value插入到列表key的表尾。如果key不存在，一个空列表会被创建并执行RPUSH操作。当key存在但不是列表类型时，返回一个错误。 查看列表中的元素： lrange key start stop返回列表key中指定区间内的元素，区间以偏移量start和stop指定,如果要左边的第一个到最后的一个lrange key 0 -1。 移除列表中的元素： 移除并返回列表key的头元素： lpop key移除并返回列表的尾元素：rpop key移除并返回列表key的中间元素： lrem key count value将删除key这个列表中，count个值为value的元素。 指定返回第几个元素： lindex key index将返回key这个列表中，索引为index的这个元素。 获取列表中的元素个数： llen key 如： llen languages删除指定的元素： lrem key count value 如： lrem languages 0 php根据参数 count 的值，移除列表中与参数 value 相等的元素。count的值可以是以下几种： count &gt; 0：从表头开始向表尾搜索，移除与value相等的元素，数量为count。count &lt; 0：从表尾开始向表头搜索，移除与 value相等的元素，数量为count的绝对值。count = 0：移除表中所有与value 相等的值。set集合的操作： 添加元素： sadd set value1 value2…. 如： sadd team xiaotuo datuo查看元素： smembeers set 如： smembers team移除元素： srem set member… 如： srem team xiaotuo datuo查看集合中的元素个数： scard set 如： scard team1获取多个集合的交集： sinter set1 set2 如： sinter team1 team2获取多个集合的并集： sunion set1 set2 如： sunion team1 team2获取多个集合的差集：sdiff set1 set2如：sdiff team1 team2hash哈希操作： 添加一个新值： hset key field value 如： hset website baidu baidu.com将哈希表key中的域field的值设为value。如果key不存在，一个新的哈希表被创建并进行 HSET操作。如果域 field已经存在于哈希表中，旧值将被覆盖。 获取哈希中的field对应的值： hget key field 如： hget website baidu删除field中的某个field： hdel key field 如： hdel website baidu获取某个哈希中所有的field和value： hgetall key 如： hgetall website获取某个哈希中所有的field： hkeys key 如： hkeys website获取某个哈希中所有的值： hvals key如：hvals website判断哈希中是否存在某个field： hexists key field如：hexists website baidu获取哈希中总共的键值对： hlen field如：hlen website事务操作：Redis事务可以一次执行多个命令，事务具有以下特征： 隔离操作：事务中的所有命令都会序列化、按顺序地执行，不会被其他命令打扰。原子操作：事务中的命令要么全部被执行，要么全部都不执行。开启一个事务： multi以后执行的所有命令，都在这个事务中执行的。 执行事务： exec会将在multi和exec中的操作一并提交。 取消事务： discard会将multi后的所有命令取消。 监视一个或者多个key： watch key…监视一个(或多个)key，如果在事务执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。 取消所有key的监视： unwatch发布/订阅操作： 给某个频道发布消息： publish channel message订阅某个频道的消息： subscribe channel持久化：redis提供了两种数据备份方式，一种是RDB，另外一种是AOF，以下将详细介绍这两种备份策略： | | RDB | AOF | | — | — | — | | 开启关闭 | 开启：默认开启。关闭：把配置文件中所有的save都注释，就是关闭了。 | 开启：在配置文件中appendonly yes即开启了aof，为no关闭。 | | 同步机制 | 可以指定某个时间内发生多少个命令进行同步。比如1分钟内发生了2次命令，就做一次同步。 | 每秒同步或者每次发生命令后同步 | | 存储内容 | 存储的是redis里面的具体的值 | 存储的是执行的更新数据的操作命令 | | 存储文件的路径 | 根据dir以及dbfilename来指定路径和具体的文件名 | 根据dir以及appendfilename来指定具体的路径和文件名 | | 优点 | （1）存储数据到文件中会进行压缩，文件体积比aof小。（2）因为存储的是redis具体的值，并且会经过压缩，因此在恢复的时候速度比AOF快。（3）非常适用于备份。 | （1）AOF的策略是每秒钟或者每次发生写操作的时候都会同步，因此即使服务器故障，最多只会丢失1秒的数据。 （2）AOF存储的是Redis命令，并且是直接追加到aof文件后面，因此每次备份的时候只要添加新的数据进去就可以了。（3）如果AOF文件比较大了，那么Redis会进行重写，只保留最小的命令集合。 | | 缺点 | （1）RDB在多少时间内发生了多少写操作的时候就会出发同步机制，因为采用压缩机制，RDB在同步的时候都重新保存整个Redis中的数据，因此你一般会设置在最少5分钟才保存一次数据。在这种情况下，一旦服务器故障，会造成5分钟的数据丢失。（2）在数据保存进RDB的时候，Redis会fork出一个子进程用来同步，在数据量比较大的时候，可能会非常耗时。 | （1）AOF文件因为没有压缩，因此体积比RDB大。 （2）AOF是在每秒或者每次写操作都进行备份，因此如果并发量比较大，效率可能有点慢。（3）AOF文件因为存储的是命令，因此在灾难恢复的时候Redis会重新运行AOF中的命令，速度不及RDB。 | | 更多 | http://redisdoc.com/topic/persistence.html#redis | | 安全：在配置文件中，设置requirepass password，那么客户端连接的时候，需要使用密码： redis-cli -p 127.0.0.1 -p 6379 redis&gt; set username xxx (error) NOAUTH Authentication required. redis&gt; auth password redis&gt; set username xxx OKPython操作redis安装python-redis： pip install redis新建一个文件比如redis_test.py，然后初始化一个redis实例变量，并且在ubuntu虚拟机中开启redis。比如虚拟机的ip地址为192.168.174.130。示例代码如下： 从redis包中导入Redis类 from redis import Redis 初始化redis实例变量 xtredis = Redis(host=’192.168.174.130’,port=6379)对字符串的操作：操作redis的方法名称，跟之前使用redis-cli一样，现就一些常用的来做个简单介绍，示例代码如下(承接以上的代码)： 添加一个值进去，并且设置过期时间为60秒，如果不设置，则永远不会过期 xtredis.set(‘username’,’xiaotuo’,ex=60) 获取一个值 xtredis.get(‘username’) 删除一个值 xtredis.delete(‘username’) 给某个值自增1 xtredis.set(‘read_count’,1) xtredis.incr(‘read_count’) # 这时候read_count变为2 给某个值减少1 xtredis.decr(‘read_count’) # 这时候read_count变为1对列表的操作：同字符串操作，所有方法的名称跟使用redis-cli操作是一样的： 给languages这个列表往左边添加一个python xtredis.lpush(‘languages’,’python’) 给languages这个列表往左边添加一个php xtredis.lpush(‘languages’,’php’) 给languages这个列表往左边添加一个javascript xtredis.lpush(‘languages’,’javascript’) 获取languages这个列表中的所有值 print xtredis.lrange(‘languages’,0,-1) [‘javascript’,’php’,’python’]对集合的操作： 给集合team添加一个元素xiaotuo xtredis.sadd(‘team’,’xiaotuo’) 给集合team添加一个元素datuo xtredis.sadd(‘team’,’datuo’) 给集合team添加一个元素slice xtredis.sadd(‘team’,’slice’) 获取集合中的所有元素 xtredis.smembers(‘team’) [‘datuo’,’xiaotuo’,’slice’] # 无序的对哈希(hash)的操作： 给website这个哈希中添加baidu xtredis.hset(‘website’,’baidu’,’baidu.com’) 给website这个哈希中添加google xtredis.hset(‘website’,’google’,’google.com’) 获取website这个哈希中的所有值 print xtredis.hgetall(‘website’) {“baidu”:”baidu.com”,”google”:”google.com”}事务(管道)操作：redis支持事务操作，也即一些操作只有统一完成，才能算完成。否则都执行失败，用python操作redis也是非常简单，示例代码如下： 定义一个管道实例 pip = xtredis.pipeline() 做第一步操作，给BankA自增长1 pip.incr(‘BankA’) 做第二步操作，给BankB自减少1 pip.desc(‘BankB’) 执行事务 pip.execute()以上便展示了python-redis的一些常用方法，如果想深入了解其他的方法，可以参考python-redis的源代码（查看源代码pycharm快捷键提示：把鼠标光标放在import Redis的Redis上，然后按ctrl+b即可进入）。","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://puguojing.com/tags/数据库/"},{"name":"Redis","slug":"Redis","permalink":"http://puguojing.com/tags/Redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}]},{"title":"Mac下Redis数据的安装、操作、配置","slug":"mac下Redis数据的安装、操作、配置","date":"2018-10-16T07:49:56.000Z","updated":"2018-11-06T03:20:18.796Z","comments":true,"path":"2018/10/16/mac下Redis数据的安装、操作、配置/","link":"","permalink":"http://puguojing.com/2018/10/16/mac下Redis数据的安装、操作、配置/","excerpt":"","text":"1.安装使用brew安装 1brew install redis 完成后会自动安装redis-server和redis-cli。 redis安装后，默认会自动启动，可以通过以下PS进程命令查看： 1ps aux|grep redis 执行结果： 1234➜ ~ ps aux|grep redispgj 17677 0.0 0.0 4287208 1064 s001 S+ 3:54下午 0:00.01 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn redispgj 17616 0.0 0.0 4295500 1160 s003 S+ 3:44下午 0:00.02 redis-cli -h 127.0.0.1 -p 6379 -a foobaredpgj 17555 0.0 0.0 4309276 2312 s002 S+ 3:40下午 0:00.62 redis-server 127.0.0.1:6379 可以看到进程PID为17555的就是redis-server,可以使用： 1kill 17555 关闭Redis服务（不建议使用，强制杀死进程，可能导致Redis部分缓存丢失）。 手动启动：Redis安装完成后会生成/usr/local/etc/redis.conf文件，执行启动命令： 1redis-server /usr/local/etc/redis.conf 会显示： 123456789101112131415161718192021➜ ~ redis-server /usr/local/etc/redis.conf17555:C 16 Oct 15:40:34.312 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo17555:C 16 Oct 15:40:34.313 # Redis version=4.0.4, bits=64, commit=00000000, modified=0, pid=17555, just started17555:C 16 Oct 15:40:34.313 # Configuration loaded17555:M 16 Oct 15:40:34.316 * Increased maximum number of open files to 10032 (it was originally set to 4864). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 4.0.4 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 17555 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; 说明启动成功。 客户端连接1redis-cli -h [ip] -p [端口] -h:指定IP-p:指定端口号（默认6379，可在redis.conf中修改） 1redis-cli -h 127.0.0.1 -p 6379 ###配置配置文件具体在：/usr/local/etc/redis.conf 1.添加密码在配置文件中找到： 1234# use a very strong password otherwise it will be very easy to break.## requirepass foobared# 其中requirepass后面的字符，就是Redis数据库密码,默认时注释掉的。如果此处指定了密码，那么以后使用redis-cli链接redis数据库的时候就要使用密码，否则连接Redis数据库之后,无法进行Redis数据库操作。比如指定密码为：123456 1234# use a very strong password otherwise it will be very easy to break.#requirepass 123456# 那么以后使用redis-cli连接数据库的时候就要用-a指定密码下面的命令: 1redis-cli -h 127.0.0.1 -p 6379 -a 123456 如果你在连接redis数据库是没有使用-a指定密码，也可以在redis-cli命令行中使用：auth password指定密码： 12127.0.0.1:6379&gt; auth 123456OK 2.让其其他的电脑访问可以redis在配置文件中找打bind,默认IP只有127.0.0.1： 1bind 127.0.0.1 ::1 在127.0.0.1后面加上自己电脑的（redis-server所在的电脑）的IP。 1bind 127.0.0.1 198.168.1.102 注意：添加不是Redis客户端的IP，是redis-server端的IP。这样别的客户端就可以使用： 1redis-cli -h 198.168.1.102 6379 来连接redis数据库了","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://puguojing.com/tags/数据库/"},{"name":"Redis","slug":"Redis","permalink":"http://puguojing.com/tags/Redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}]},{"title":"memcached（1）- 调试使用","slug":"memcached（1）- 调试使用","date":"2018-10-12T13:07:03.000Z","updated":"2018-11-06T03:16:38.860Z","comments":true,"path":"2018/10/12/memcached（1）- 调试使用/","link":"","permalink":"http://puguojing.com/2018/10/12/memcached（1）- 调试使用/","excerpt":"","text":"Mac memcached的调试1.安装：1brew install memcached 2.启动：1memcached -d -p 11211 -u nobody -c 1024 -m 64 1234567-d：这个参数是让memcached在后台运行（启动一个守护进程）。-m：指定占用多少内存。以M为单位，默认为64M。-u是运行Memcache的用户，我这里是nobody-p：设置Memcache监听的端口,最好是1024以上的端口，默认端口是11211。-l：别的机器可以通过哪个ip地址连接到我这台服务器。如果是通过service memcached start的方式，那么只能通过本机连接。如果想要让别的机器连接，就必须设置-l 0.0.0.0。-c选项是最大运行的并发连接数，默认是1024，按照你服务器的负载量来设定 3.Telnet连接1telnet 127.0.0.1 11211 telnet操作memcached:memcached的数据是以 key:value 方式存储在内存中，所以我们一般对key 进行操作，而value保存实际的值。 1.set：添加或更新数据：123456语法： set key flas(是否压缩) timeout(存储的时间,0代表一直存储) value_length(value的长度) value示例： set username 0 60 7 zhiliao 注意指定的value长度和实际输入value的长度必须一致，否则按Enter键后会出现ERROR(如果实际的value长度大于指定的长度)或者一直等到你输入完指定的字符数。 2.add：添加数据123456语法： add key flas(是否压缩) timeout(存储的时间,0代表一直存储) value_length(value的长度) value示例： add username 0 60 7 xiaotuo set和add的区别：add是只负责添加数据，不会去修改数据。如果添加的数据的key已经存在了，则添加失败，如果添加的key不存在，则添加成功。而set不同，如果memcached中不存在相同的key，则进行添加，如果存在，则替换。 set、add执行成功后会显示：STORED，未执行成功会显示：NOT STORED 3.get：获取数据1234语法： get key示例： get username 4.delete:删除数据1234语法： delete key示例： delete username 5.flush_all：删除memcached中的所有数据。6.incr:给memcached中数字类型的值进行相加操作，相加的项必须也是数字类型。123456语法： incr key num(num表示要加的值，必须是数字)示例： incr age 2 给key是age的值加上2 7.decr:给memcached中数字类型的值进行减操作，相减的项必须也是数字类型。12345语法： decr key num(num表示要减的值，必须是数字)示例： devr age 2 给key是age的值减去2 8.stats：查看memcached的当前状态，可以查看自己的操作记录和正确执行数据，以分析memcached的命中率（正确率）12示例： stats 结果： 123456789101112STAT pid 5286STAT uptime 3741STAT time 1539349048STAT version 1.5.3...STAT cmd_get 9 #表示进行实际get的次数STAT cmd_set 16 #表示进行实际get的次数STAT cmd_flush 1STAT cmd_touch 0STAT get_hits 7 #表示get命中(有效)的次数...END 常见的：STAT cmd_get 9 表示进行实际get的次数STAT cmd_set 16 表示进行实际set的次数STAT get_hits 7 表示get命中(有效)的次数STAT curr_items 4 表示当前有多少条数据 stats之后会显示很多结果常用的就是查看set、get等操作的cmd_get/set 数量和 get_hits 数量 用类似: get_hits/cmd_get 的结果反映当前memcached的状态，如果命中率良好，说明memcached的状态良好，反之说明memcached的状态较差，比如可能碎片较多。","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://puguojing.com/tags/数据库/"},{"name":"memcached","slug":"memcached","permalink":"http://puguojing.com/tags/memcached/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}]},{"title":"MySQL中的left join、right join 以及inner join之间的区别","slug":"Mysql中的内联接、左外联接、右外联接","date":"2018-10-08T06:29:15.000Z","updated":"2018-11-06T03:17:21.027Z","comments":true,"path":"2018/10/08/Mysql中的内联接、左外联接、右外联接/","link":"","permalink":"http://puguojing.com/2018/10/08/Mysql中的内联接、左外联接、右外联接/","excerpt":"","text":"sql语句中left join、right join 以及inner join之间的区别left [outer] join(左联接)： 返回包括左表中的所有记录和右表中联结字段相等的记录 。right [outer] join(右联接) ：返回包括右表中的所有记录和左表中联结字段相等的记录。inner join(等值连接) ：只返回两个表中联结字段相等的行。 左联接和右联接统称为外联接，其中的outer关键字可以省略。 左连接和右连接的区别在于以哪个表为主（主表中的数据都会出现在表中） 举例如下：表A记录如下： 123456aID aNum1 a200501112 a200501123 a200501134 a200501145 a20050115 表B记录如下: 123456bID bName1 20060324012 20060324023 20060324034 20060324048 2006032408 - 1.left joinsql语句如下: 123select * from Aleft join B on A.aID = B.bID 结果如下: 123456aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 20060324045 a20050115 NULL NULL （所影响的行数为 5 行）结果说明:left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的. 换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID).B表记录不足的地方均为NULL. - 2.right joinsql语句如下: 123select * from Aright join B on A.aID = B.bID 结果如下: 123456aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404NULL NULL 8 2006032408 （所影响的行数为 5 行）结果说明:仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充. - 3.inner joinsql语句如下: 123select * from Ainnerjoin B on A.aID = B.bID 结果如下: 12345aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404 结果说明:很明显,这里只显示出了 A.aID = B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录. - 注:LEFT JOIN操作用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，即使在第二个（右边）表中并没有相符值的记录。 语法：FROM table1 LEFT JOIN table2 ON table1.field1 compopr table2.field2说明：table1, table2参数用于指定要将记录组合的表的名称。 field1, field2参数指定被联接的字段的名称。且这些字段必须有相同的数据类型及包含相同类型的数据，但它们不需要有相同的名称。 compopr参数指定关系比较运算符：”=”， “&lt;”， “&gt;”， “&lt;=”， “&gt;=” 或 “&lt;&gt;”。 如果在INNER JOIN操作中要联接包含Memo 数据类型或 OLE Object 数据类型数据的字段，将会发生错误。","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"http://puguojing.com/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"http://puguojing.com/tags/MySQL/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}]},{"title":"Pycharm连接mysql数据库","slug":"pycharm连接mysql数据库","date":"2018-10-07T10:08:57.000Z","updated":"2018-11-06T03:27:52.558Z","comments":true,"path":"2018/10/07/pycharm连接mysql数据库/","link":"","permalink":"http://puguojing.com/2018/10/07/pycharm连接mysql数据库/","excerpt":"","text":"1.首先选择添加mysql数据库。 2.填入对应的额mysql配置信息（其中数据库orm_lookup_demo应该事先被创建好） 此时可以点击“Test Connections”测试是否连接成功，如果连接成功会出现:”succesfully”提示。如果“Test Connections”按钮无法点击，说明没有安装对应的mysql java驱动（因为pyhcarm使用java语言编写）。可以按下面的步骤快速安装：（1）.点击“Test Connections”按钮下面的Mysql 跳转到 Driver配置界面。（2）.点击下面途中的连接下载安装。（3）.重新回到数据库连接界面发现可以执行“Test Connections”。","categories":[{"name":"工具","slug":"工具","permalink":"http://puguojing.com/categories/工具/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://puguojing.com/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"http://puguojing.com/tags/MySQL/"},{"name":"PyCharm","slug":"PyCharm","permalink":"http://puguojing.com/tags/PyCharm/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://puguojing.com/categories/工具/"}]},{"title":"Mysql中的外键","slug":"Mysql中的外键","date":"2018-10-06T08:54:06.000Z","updated":"2018-11-06T03:17:33.735Z","comments":true,"path":"2018/10/06/Mysql中的外键/","link":"","permalink":"http://puguojing.com/2018/10/06/Mysql中的外键/","excerpt":"","text":"mysql中的外键foreign key一、如果一张表中有一个非主键的字段指向了别一张表中的主键，就将该字段叫做外键。 一张表中可以有多个外键。 外键的默认作用有两点： 1.对子表(外键所在的表)的作用：子表在进行写操作的时候，如果外键字段在父表中找不到对应的匹配，操作就会失败。 2.对父表的作用：对父表的主键字段进行删和改时，如果对应的主键在子表中被引用，操作就会失败。 外键的定制作用—-三种约束模式： district：严格模式(默认), 父表不能删除或更新一个被子表引用的记录。 cascade：级联模式, 父表操作后，子表关联的数据也跟着一起操作。 set null：置空模式,前提外键字段允许为NLL, 父表操作后，子表对应的字段被置空。 使用外键的前提： 1. 表储存引擎必须是innodb，否则创建的外键无约束效果。 2. 外键的列类型必须与父表的主键类型完全一致。 3. 外键的名字不能重复。 4. 已经存在数据的字段被设为外键时，必须保证字段中的数据与父表的主键数据对应起来。 二、新增外键 在创建时增加 1234567891011create table my_tab1( id int primary key auto_increment, name varchar(10) not null, class int, foreign key(class) references my_tab2(主键字段名); )charset utf8; 在创建好的表中增加 1alter table my_tab1 add [constraint 外键名] foreign key(外键字段名) references mytab2(主键字段名); 三、删除外键1alter table my_tab drop foreign key 外键名字;","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"http://puguojing.com/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"http://puguojing.com/tags/MySQL/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}]},{"title":"python3 与 Django 连接数据库Error loading MySQL db module解决方案","slug":"python3 与 Django 连接数据库Error loading MySQLdb module解决方案","date":"2018-09-30T09:11:41.000Z","updated":"2018-11-06T03:18:35.276Z","comments":true,"path":"2018/09/30/python3 与 Django 连接数据库Error loading MySQLdb module解决方案/","link":"","permalink":"http://puguojing.com/2018/09/30/python3 与 Django 连接数据库Error loading MySQLdb module解决方案/","excerpt":"","text":"学习Django时候，采用MySQL作为后台数据库，在执行python3 manage.py startapp appname创建app时遇到如下问题: 12django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module.Did you install mysqlclient? 完整报错如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Traceback (most recent call last): File &quot;/usr/local/lib/python3.6/site-packages/django/db/backends/mysql/base.py&quot;, line 15, in &lt;module&gt; import MySQLdb as DatabaseModuleNotFoundError: No module named &apos;MySQLdb&apos;The above exception was the direct cause of the following exception:Traceback (most recent call last): File &quot;manage.py&quot;, line 15, in &lt;module&gt; execute_from_command_line(sys.argv) File &quot;/usr/local/lib/python3.6/site-packages/django/core/management/__init__.py&quot;, line 381, in execute_from_command_line utility.execute() File &quot;/usr/local/lib/python3.6/site-packages/django/core/management/__init__.py&quot;, line 357, in execute django.setup() File &quot;/usr/local/lib/python3.6/site-packages/django/__init__.py&quot;, line 24, in setup apps.populate(settings.INSTALLED_APPS) File &quot;/usr/local/lib/python3.6/site-packages/django/apps/registry.py&quot;, line 112, in populate app_config.import_models() File &quot;/usr/local/lib/python3.6/site-packages/django/apps/config.py&quot;, line 198, in import_models self.models_module = import_module(models_module_name) File &quot;/usr/local/Cellar/python3/3.6.3/Frameworks/Python.framework/Versions/3.6/lib/python3.6/importlib/__init__.py&quot;, line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 994, in _gcd_import File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 971, in _find_and_load File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 955, in _find_and_load_unlocked File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 665, in _load_unlocked File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 678, in exec_module File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed File &quot;/usr/local/lib/python3.6/site-packages/django/contrib/auth/models.py&quot;, line 2, in &lt;module&gt; from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager File &quot;/usr/local/lib/python3.6/site-packages/django/contrib/auth/base_user.py&quot;, line 47, in &lt;module&gt; class AbstractBaseUser(models.Model): File &quot;/usr/local/lib/python3.6/site-packages/django/db/models/base.py&quot;, line 101, in __new__ new_class.add_to_class(&apos;_meta&apos;, Options(meta, app_label)) File &quot;/usr/local/lib/python3.6/site-packages/django/db/models/base.py&quot;, line 304, in add_to_class value.contribute_to_class(cls, name) File &quot;/usr/local/lib/python3.6/site-packages/django/db/models/options.py&quot;, line 203, in contribute_to_class self.db_table = truncate_name(self.db_table, connection.ops.max_name_length()) File &quot;/usr/local/lib/python3.6/site-packages/django/db/__init__.py&quot;, line 33, in __getattr__ return getattr(connections[DEFAULT_DB_ALIAS], item) File &quot;/usr/local/lib/python3.6/site-packages/django/db/utils.py&quot;, line 202, in __getitem__ backend = load_backend(db[&apos;ENGINE&apos;]) File &quot;/usr/local/lib/python3.6/site-packages/django/db/utils.py&quot;, line 110, in load_backend return import_module(&apos;%s.base&apos; % backend_name) File &quot;/usr/local/Cellar/python3/3.6.3/Frameworks/Python.framework/Versions/3.6/lib/python3.6/importlib/__init__.py&quot;, line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) File &quot;/usr/local/lib/python3.6/site-packages/django/db/backends/mysql/base.py&quot;, line 20, in &lt;module&gt; ) from errdjango.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module.Did you install mysqlclient? 原因分析：在 python2 中，使用 pip install mysql-python 进行安装连接MySQL的库，使用时 import MySQLdb 进行使用 在 python3 中，改变了连接库，改为了 pymysql 库，但是在 Django 中， 连接数据库时使用的是 MySQLdb 库，这在与 python3 的合作中就会报以下错误了： 1django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: No module named &apos;MySQLdb&apos; 使用pip install pymysql 进行安装，直接导入即可使用。 1. 安装pymsql1pip install pymysql 2. 安装完毕，打开项目的init.py,添加代码12import pymysql pymysql.install_as_MySQLdb() 重新执行python3 manage.py startapp appname创建app成功。","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"http://puguojing.com/tags/MySQL/"},{"name":"Django","slug":"Django","permalink":"http://puguojing.com/tags/Django/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}]},{"title":"虚拟环境virtualenv和virtualenvwrapper的使用","slug":"virtualenv和virtualenvwrapper的使用","date":"2018-09-29T06:11:44.000Z","updated":"2018-11-06T03:26:19.164Z","comments":true,"path":"2018/09/29/virtualenv和virtualenvwrapper的使用/","link":"","permalink":"http://puguojing.com/2018/09/29/virtualenv和virtualenvwrapper的使用/","excerpt":"","text":"1.virtualenv虚拟环境的使用1.安装虚拟环境：1pip install virtualenv 2.创建虚拟环境1virtualenv [虚拟环境的名称] 会在当前路径中创建虚拟环境文件夹 3.进入虚拟环境12Windows:cd 到Script文件夹Linux/Mac： source path/虚拟环境/bin/activate 4.退出虚拟环境1deactivate 5.创建虚拟环境的时候指定Python解释器：当电脑有多个Python版本时，可以使用 -p 参数来指定Python解释器： 1virtualenv -p [Python解释器路径] 建议使用 virtualenvwrapper使用virtualenv时每一次创建虚拟环境都会在当前目录下创建一个虚拟环境文件夹，如果创建太多会很混乱，使用virtualenvwrapper只会下用户文件夹下创建一个Env文件夹，所有的虚拟环境都放在这个Env里面，所以非常易于维护。 1.安装1pip install virtualenvwrapper 进行下面步骤配置：1.创建目录用来存放虚拟环境 1mkdir $HOME/.virtualenvs 2.在~/.bash_profile中添加行： 123456#声明虚拟环境的文件夹export WORKON_HOME=$HOME/.virtualenvs#声明虚拟环境使用的python版本（多pyhton版本情况，请填写自己的python版本解释器路径）export VIRTUALENVWRAPPER_PYTHON=/usr/bin/local/python3.6 #执行虚拟环境脚本生效source /usr/local/bin/virtualenvwrapper.sh 3.运行以下命令使修改生效: 1source ~/.bash_profile 执行： 1➜~ virtualenvwrapper 如果提示：not found command或者/usr/bin/python: No module named virtualenvwrapper，说明未在正确的版本上安装virtualenv。 1.创建虚拟环境1mkvirtualenv [虚拟环境名称] 会在当前用户文件夹下创建一个Env文件夹，然后将虚拟环境安装到这个目录下。 2.切换到虚拟环境1workon my_env 退出当前虚拟环境1deactivate 3.删除某个虚拟环境1rmvirtualenv my_env 4.列出所有虚拟环境1lsvirtualenv 5.进入某个虚拟环境1cdvirtualenv my_env","categories":[{"name":"工具","slug":"工具","permalink":"http://puguojing.com/categories/工具/"},{"name":"python","slug":"工具/python","permalink":"http://puguojing.com/categories/工具/python/"}],"tags":[{"name":"virsualenv","slug":"virsualenv","permalink":"http://puguojing.com/tags/virsualenv/"},{"name":"virtualenvwrapper","slug":"virtualenvwrapper","permalink":"http://puguojing.com/tags/virtualenvwrapper/"},{"name":"虚拟环境","slug":"虚拟环境","permalink":"http://puguojing.com/tags/虚拟环境/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://puguojing.com/categories/工具/"},{"name":"python","slug":"工具/python","permalink":"http://puguojing.com/categories/工具/python/"}]},{"title":"HTTP协议（1）","slug":"HTTP协议（1）","date":"2018-09-28T09:30:01.000Z","updated":"2018-11-06T03:14:14.002Z","comments":true,"path":"2018/09/28/HTTP协议（1）/","link":"","permalink":"http://puguojing.com/2018/09/28/HTTP协议（1）/","excerpt":"","text":"HTTP及超文本传输协议，用于在客户端和服务器之间传送数据，包括文本、图像、视频流都可以使用HTTP协议进行传输。 1.1HTTP协议流程 输入网址并按Enter键，比如访问：hhtp://mysite:8080/app/index.html。 浏览器通过域名系统查询mysite的真实IP，比如：212.34.98.20。 向服务器的8080端口发起TCP请求并建立链接。 发送HTTP请求的内容，包括访问的地址/app/index.html、访问方式GET、浏览器本身的产品等。 服务器返回/app/index.html中的数据，并作文Reponse发送给客户端，如果请求的不是一个文件，则服务器需要执行相应的代码，动态生成切返回给客户端。 浏览器收到结果后关闭于服务器的链接。 浏览器将收到的结果呈现在显示器上。 注意:其中1、2不是HTTP解析的一部分。 如今的HTTP还允许客户端在一次HTTP请求之后不关闭TCP链接，以便之后第2次发送HTTP请求时复用该链接，以减少系统开销，此技术在HTTP中叫keep-alive。 1.2HTTP消息结构1.Request消息结构Request是客户端向服务器发起请求时的请求结构。 123456【请求方法】 【URL】【协议版本】【头字段1】：值 ...【头字段N】：值【消息体】 Request消息结构由两部分组成，消息头和消息体。消息头必须遵循上述格式，消息体则没有固定格式。消息头和消息体之间使用一行空格。 123GET /hello.txt HTTP/1.1Host:www.mysite.comAccept-Languange:en 上面就是一个请求头结构。 1.Reponse消息结构","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"}],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"http://puguojing.com/tags/HTTP协议/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"}]},{"title":"python生成器详解","slug":"Python生成器详解","date":"2018-09-15T14:41:56.000Z","updated":"2018-11-06T03:19:48.855Z","comments":true,"path":"2018/09/15/Python生成器详解/","link":"","permalink":"http://puguojing.com/2018/09/15/Python生成器详解/","excerpt":"","text":"参考： 廖雪峰官网Python教程-生成器 Python生成器generator之next和send运行流程","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://puguojing.com/tags/python/"},{"name":"生成器","slug":"生成器","permalink":"http://puguojing.com/tags/生成器/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}]},{"title":"Python多线程（2）","slug":"Python多线程（2）","date":"2018-09-09T15:11:06.000Z","updated":"2018-11-06T03:18:53.931Z","comments":true,"path":"2018/09/09/Python多线程（2）/","link":"","permalink":"http://puguojing.com/2018/09/09/Python多线程（2）/","excerpt":"","text":"Lock、BoundedSemaphore（和Semaphore类似，不过不允许超过初始值）的使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding:utf-8 -*-from atexit import registerfrom random import randrangefrom threading import BoundedSemaphore,Lock,Threadfrom time import sleep,ctimelock = Lock()MAX = 5candytray = BoundedSemaphore(MAX)def producer(loops): print(&apos;producer loops:&apos;,loops) lock.acquire() for i in range(loops): try: candytray.release()#realse后Semaphore会增多相当于产生 except ValueError: print(&apos;release fail all Semaphore &apos;) else: print(&apos;release(produce) ok&apos;) sleep(randrange(3)) lock.release()def consumer(loops): print(&apos;consumer loops:&apos;, loops) lock.acquire() for i in range(loops): if candytray.acquire(False):#acquire后 Semaphore会减少 print(&apos;acquire(consumer) ok&apos;) else: print(&apos;acquire fail empty&apos;) sleep(randrange(3)) lock.release()def main(): n=randrange(2,6) Thread(target=consumer,args=(randrange(n,n+MAX+2),)).start() Thread(target=producer, args=(n,)).start()@registerdef _atexit(): print(&apos;DONE :&apos;,ctime())if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"线程","slug":"线程","permalink":"http://puguojing.com/tags/线程/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}]},{"title":"Python多线程（1）","slug":"Python多线程（1）","date":"2018-09-09T14:11:06.000Z","updated":"2018-11-06T03:18:42.285Z","comments":true,"path":"2018/09/09/Python多线程（1）/","link":"","permalink":"http://puguojing.com/2018/09/09/Python多线程（1）/","excerpt":"","text":"&#8195;&#8195; 1.进程&#8195;&#8195;计算机程序知识存储在磁盘上的可执行二进制（或其他类型）文件，只有把他们加载到内存中并被操作系统调用，才拥有生命周期，进程是一个执行中的程序，每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪的辅助数据。由于进程之间相互独立，所以只能采用进程间通信(IPC)的方式共享信息。 2.线程&#8195;&#8195;线程与进程类似，不过他是在同一个进程下执行的，所以共享上下文。 3.全局解释锁(GIL)&#8195;&#8195;Python代码的执行是由Python解释器（解释器主循环）进行控制的，在主循环中同时只能有一个线程在执行，就像单核CPU的多进程一样。尽管Python解释器可以运行多个线程，但是在任意给定的时刻只能有一个线程会被解释器调用。Python解释器将按照下面的过程执行：1.设置GIL。2.切换金一个线程去运行。3.执行下面的操作之一 ： &#8195;&#8195;a.指定数量的字节码指令。 &#8195;&#8195;b.线程主动让出控制权（可以调用time.sleep(0)来完成。4.把线程切换回睡眠状态（切换出线程。5.解锁GIL。6.重复上述步骤。 &#8195;&#8195;在当调用外部代码（即任意C/C++扩展D额内置函数）时，GIL会保持锁定，直至函数执行结束(因为在这期间没有Python字节码计数）。编写扩展函数的程序员有能力解锁GIL。然而，作为Python开发者，你并不需要担心Pyhon代码会在这些情况下被锁住。 &#8195;&#8195;例如，对于任意面向I/O的Python例程(调用了内置操作系统的C代码那种)GIL会在I/O调用前被释放，以允许其他线程在I/O执行的时候运行。而对那些没有太多I/O操作的代码而言，更加倾向于在该线程整个时间片内始终占有处理器。换句话说就是，I/O密集型的Python程序要比计算密集型的代码能够更好的利用多线程环境。 &#8195;&#8195;关于解释器主循环和GIL可以才看源码Python/ceval.c 4.在Python中使用线程&#8195;&#8195;Python提供了多个模块来支持多线程编程，包括thread、threading，queue模块等。thread提供了基本的线程和锁定支持。threading模块提供了更高级别功能，更全面面的线程管理。queue模块，用户可以创建一个队列数据结构，用于在多线程之间进行共享。 推荐使用更高级别的锁定模块threading，而不是使用thread模块。 1.一个原因是低级别的thread模块入的同步原语很少只有Lock，而threading模块拥有Lock,Semephore、Condition、Event等多种同步机制。2.另一个原因是thread对于进程何时退出没有控制，当主线程结束时，所有其他线程也都强制结束，不会发出警告或者进行适当的清理，所以他也不支持守护线程。 守护线程 &#8195;&#8195;守护线程一般是一个等待客户端请求服务的服务器，如果没有客户端请求守护线程就是空闲的.如果把一个线程置为守护线程，就表示这个线程是不重要的。进程退出时不需要等待这个线程执行完成。 &#8195;&#8195;如果主线程准备退出时不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。该标记值为真时，表示线程是不重要的，或者说线程只是用来等待客户端请求而不做任何其他事情。设置一个线程为守护线程需要在启动线程之前执行如下赋值语句：thread.daemon = True 5.threaing模块下的Thread类 属性 描述 Thread对象的数据属性 Name 线程名 Ident 线程标志符 Daemon 守护线程标志 Thread对象方法 init(group=NONE,target=None,name=None, args=(),kwargs{},verbose=None,daemon=None) 实例化一个线程对象，需要有一个可调用的target，以及其参数args或kwargs，还可以传递name或group参数，daemon会设置thread.daemon属性标志 Start() 开始执行线程 run() 定义线程功能的方法（通常在子类中进行重写） jion() 直至启动的线程终止之前一直挂起。除非给出了timeout。否则会一直阻塞。 代码案例一，创建Thread实例传给他一个可调用的函数： 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python3# -*- coding:utf-8 -*-import threadingfrom time import sleep,ctimeloops_time = [4,2]def loop(nloop,nsec): print(&apos;start loop :&apos;,nloop,&apos;at:&apos;,ctime()) sleep(nsec) print(&apos;end loop :&apos;, nloop, &apos;at:&apos;, ctime())def main(): print(&apos;starting at----------------- :&apos;,ctime()) test_thresds = [] for i in range(len(loops_time)): t = threading.Thread(target=loop,args=(i,loops_time[i])) test_thresds.append(t) for i in range(len(loops_time)): test_thresds[i].start() for i in range(len(loops_time)): test_thresds[i].join() print(&apos;end at :-------------------&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 代码案例二：创建Thread实例传给他一个可调用的类实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3# -*- coding:utf-8 -*-import threadingfrom time import sleep,ctimeloops_time = [4,2]class ThreadFunc(object): def __init__(self,func,args,name=&apos;&apos;): self.name = name self.args = args self.func = func def __call__(self, *args, **kwargs): self.func(*self.args)def loop(nloop,nsec): print(&apos;start loop :&apos;,nloop,&apos;at:&apos;,ctime()) sleep(nsec) print(&apos;end loop :&apos;, nloop, &apos;at:&apos;, ctime())def main(): print(&apos;starting at----------------- :&apos;,ctime()) test_thresds = [] for i in range(len(loops_time)): t = threading.Thread(target=ThreadFunc(loop,args=(i,loops_time[i]),name=loop.__name__)) test_thresds.append(t) for i in range(len(loops_time)): test_thresds[i].start() for i in range(len(loops_time)): test_thresds[i].join() print(&apos;end at :-------------------&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 代码案例三，派生Thread子类，并创建子类实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding:utf-8 -*-import threadingfrom time import sleep,ctimeloops_time = [4,2]class MyThread(threading.Thread): def __init__(self,func,args,name=&apos;&apos;): threading.Thread.__init__(self) self.name = name self.args = args self.func = func def getResult(self): return self.res def run(self): self.res = self.func(*self.args)def loop(nloop,nsec): print(&apos;start loop :&apos;,nloop,&apos;at:&apos;,ctime()) sleep(nsec) print(&apos;end loop :&apos;, nloop, &apos;at:&apos;, ctime())def main(): print(&apos;starting at----------------- :&apos;,ctime()) test_thresds = [] for i in range(len(loops_time)): t = MyThread(func=loop,args=(i,loops_time[i]),name=loop.__name__) test_thresds.append(t) for i in range(len(loops_time)): test_thresds[i].start() print(threading.enumerate()) # 当前活动的Thread对象列表 for i in range(len(loops_time)): test_thresds[i].join() print(&apos;end at :-------------------&apos;, ctime())if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"线程","slug":"线程","permalink":"http://puguojing.com/tags/线程/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}]},{"title":"项目-learning-log（3）","slug":"项目-learning-log（3）","date":"2018-09-09T14:11:06.000Z","updated":"2018-11-06T03:16:26.191Z","comments":true,"path":"2018/09/09/项目-learning-log（3）/","link":"","permalink":"http://puguojing.com/2018/09/09/项目-learning-log（3）/","excerpt":"","text":"1. 前言–在本篇中，我们将：·使用Bootstrap库设置样式；·把项目部署到Heroku上。 2. 设置项目“学习笔记”的样式– 之前关注的都是项目的功能，现在来为项目添加样式。 我们将使用django-bootstrap3来设置样式。首先请在虚拟环境中安装这个第三方库。 1pip install django-bootstrap3 然后像之前在项目settings.py中注册我们自己编写的APP一样，注册bootstrap3这个应用程序。 还需要包含django-bootstrap3包含jQuery，在settings.py末尾添加如下代码： 1234567...LOGIN_URL = &apos;/users/login/&apos;# django-bootstrap3的设置BOOTSTRAP3 = &#123; &quot;include_jquery&quot;: True,&#125; 2.1-2.2参看原文链接 2.3 设置登录页面样式–此处与文中不同，我的login.html中的form无法通过% bootstrap_form form %}引用Bootstrap的样式.因此我的login.html如下： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;% extends &quot;learning_logs/base.html&quot; %&#125;&#123;% load bootstrap3 %&#125;&#123;% block header %&#125; &lt;h2&gt;登录您的账户&lt;/h2&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form action=&quot;&#123;% url &apos;users:login&apos; %&#125;&quot; method=&quot;post&quot; class=&quot;form-signin&quot;&gt; &#123;% csrf_token %&#125; &lt;h2 class=&quot;form-signin-heading&quot;&gt;请登录&lt;/h2&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;&#123;&#123; username &#125;&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;用户名&quot; required autofocus&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; value=&quot;&#123;&#123; password &#125;&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; required&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 2.4-2.6参看原文链接 3. 部署“学习笔记”–3.1-3.2参看原文链接 3.3 为部署到Heroku而修改settings.py–此处setting.py中的与文中不同，文中如下: 1234567891011121314151617181920212223-- snip --# 书中的判断语句是 if os.getcwd() == &apos;/app&apos;: # 现在估计是Heroku升级了，改为了下面的语句，否则待会儿部署的时候会出错if os.environ[&apos;HOME&apos;] == &quot;/app&quot;: import dj_database_url DATABASES = &#123; &quot;default&quot;: dj_database_url.config(default=&quot;postgres://localhost&quot;) &#125; # 让request.is_secure()承认X-Forwarded-Proto头 SECURE_PROXY_HEADER = (&quot;HTTP_X_FORWARDED_PROTO&quot;, &quot;https&quot;) # 支持所有的主机头（host header） ALLOWED_HOSTS = [&quot;*&quot;] # 静态资产配置 BASE_DIR = os.path.dirname(os.path.abspath(__file__)) # 书中设置是这样的： STATIC_ROOT = &quot;staticfiles&quot; STATIC_ROOT = os.path.join(BASE_DIR, &apos;static&apos;) STATICFILES_DIRS = ( os.path.join(BASE_DIR, &quot;static&quot;), ) 按照此种方式设置报错，提示STATICFILES_DIRS 的STATIC_ROOT不正确。 1?: (staticfiles.E002) The STATICFILES_DIRS setting should not contain the STATIC_ROOT setting. 修改为: 1234567891011... # 静态资产配置 BASE_DIR = os.path.dirname(os.path.abspath(__file__)) STATIC_ROOT = &quot;staticfiles&quot;#书中设置是这样的： STATIC_URL = &apos;/static/&apos; #STATIC_ROOT = os.path.join(BASE_DIR, &apos;/static/&apos;)#错误 #STATIC_ROOT = os.path.join(BASE_DIR, &quot;static/&quot;) # 错误(staticfiles.E002) The STATICFILES_DIRS setting should not contain the STATIC_ROOT setting. STATICFILES_DIRS = ( os.path.join(BASE_DIR, &quot;static&quot;), ) 最终执行成功。 3.4 创建启动进程的Procfile– Procfile告诉Heroku启动那些进程，以便能够正确地提供项目支持的服务。这个文件只包含一行，文件名为Procfile，不带扩展名，保存到项目根目录。 1web: gunicorn learning_log.wsgi --log-file - 这段代码让Heroku将gunicorn用过服务器，并使用learning_log/wsgi.py中的设置来启动应用程序。标志log-file告诉Heroku应将哪些类型的时间写入日志。注意最后的“-”不能省略 3.14 部署总结–从前面这些例子可看出，开发与部署的过程如下： ①修改项目。如果创建了新文件，使用命令 git add .（最后有个句点！）将它们加到Git仓库中。如果要迁移数据库，也需要执行该命令，因为每个迁移都生成了新的迁移文件。 ②执行 git commit -am &quot;commit message&quot;，将修改提交到仓库。 ③执行 git push heroku master 将修改推送到服务器。 ④如果本地迁移了数据库，也需要迁移在线数据库，可以使用一次性命令 heroku run python manage.py migrate，也可以使用 heroku run bash打开一个远程终端会话，再执行迁移。 3.15 设置SECRET_KEY–Django根据settings.py中的SECRET_KEY来实现大量的安全协议。本项目中设置的SECRET_KEY对一个练习项目来说已经足够了，但是对于生产网站，请务必认真对待这个值。 3.16 将项目从Heroku删除1(ll_env)learning_log$ heroku apps:destroy --app appname 现在可以访问这个网站 https://pgj-learning-log.herokuapp.com","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"项目","slug":"技术/项目","permalink":"http://puguojing.com/categories/技术/项目/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://puguojing.com/tags/部署/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://puguojing.com/tags/Bootstrap/"},{"name":"Heroku","slug":"Heroku","permalink":"http://puguojing.com/tags/Heroku/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"项目","slug":"技术/项目","permalink":"http://puguojing.com/categories/技术/项目/"}]},{"title":"python爬虫Scrapy框架学习（1）","slug":"python爬虫Scrapy框架学习（1）","date":"2018-09-07T15:13:09.000Z","updated":"2018-11-06T03:19:13.665Z","comments":true,"path":"2018/09/07/python爬虫Scrapy框架学习（1）/","link":"","permalink":"http://puguojing.com/2018/09/07/python爬虫Scrapy框架学习（1）/","excerpt":"","text":"Scrapy安装Mac下构建Scrapy依赖库需要C编译器及开发头文件，他一般由Xcode提供，具体命令如下： 1xcode-select --install 随后利用pip安装Scrapy 1pip install Scrapy 安装完成后验证安装，命令行输入： 1Scrapy 运行结果如下图说明安装成功： Scrapy框架介绍Scrapy是一个基于Twisted的异步处理框架，是纯Python实现的爬虫框架。其架构清晰，模块之间耦合程度低，可扩展性极强，可以灵活完成各种需求。我们只需要定制开发几个模版就可以轻松实现一个爬虫。 Scrapy的架构框架如下图所示","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"爬虫","slug":"技术/爬虫","permalink":"http://puguojing.com/categories/技术/爬虫/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"http://puguojing.com/tags/Scrapy/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"爬虫","slug":"技术/爬虫","permalink":"http://puguojing.com/categories/技术/爬虫/"}]},{"title":"Python爬虫-selenium的使用（2）","slug":"selenium的使用（2）","date":"2018-08-30T07:49:51.000Z","updated":"2018-11-06T03:20:39.254Z","comments":true,"path":"2018/08/30/selenium的使用（2）/","link":"","permalink":"http://puguojing.com/2018/08/30/selenium的使用（2）/","excerpt":"","text":"使用selenium打开chrome浏览器百度进行搜索12345678910111213141516171819202122232425from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitimport timebrower = webdriver.Chrome()try: brower.get(&apos;https://www.baidu.com/&apos;) input = brower.find_element_by_id(&apos;kw&apos;)#通过id寻找元素 input.send_keys(&apos;Python&apos;)#在找到的input输入框内输入Python input.send_keys(Keys.ENTER)#输入键盘的Enter wait = WebDriverWait(brower,10)#设置wait的超时时间 wait.until(EC.presence_of_element_located((By.ID,&apos;content_left&apos;)))#等待直到出现id是conten_left的元素加载出来的时候，最大等待时间不超过10秒 print(brower.current_url)#打印url print(brower.get_cookies())#打印现在的cookies print(brower.page_source)#打印网页源代码 time.sleep(5)except Exception as e: print(e)finally: brower.close() 还可以使用其他浏览器，比如：Firefox、Edge、以及一些手机浏览器等 12345678from selenium import webdriverbrower = webdriver.Chrome()brower = webdriver.Firefox()brower = webdriver.Edge()brower = webdriver.PhantomJS()brower = webdriver.Safari() 注意每个浏览器都有自己对应的类似chrome浏览器的chromedriver驱动可执行文件。 2使用selenium打开淘货搜索123456789101112131415161718brower = webdriver.Chrome()try: brower.get(&apos;https://www.taobao.com/&apos;) search_input = brower.find_element_by_id(&apos;q&apos;) search_input.send_keys(&apos;iPhone&apos;) time.sleep(2) search_input.clear() time.sleep(1) search_input.send_keys(&apos;iPad&apos;) time.sleep(1) search_button = brower.find_element_by_class_name(&apos;btn-search&apos;) time.sleep(1) search_button.click() time.sleep(10)except Exception as e: print(e)finally: brower.close() 打开淘宝，搜索‘iPhone’然后删除，接着搜索‘iPad’ 3.动作链，实现拖拽1234567891011121314151617from selenium.webdriver import ActionChainsbrower = webdriver.Chrome()try: url = &apos;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&apos; brower.get(url) brower.switch_to.frame(&apos;#iframeResult&apos;)#切换到子页面中&apos;iframeResult&apos;是子页面的id名，也可以根据name inex 甚至webElement对象定位 source = brower.find_element_by_css_selector(&apos;#draggable&apos;) target = brower.find_element_by_css_selector(&apos;#droppable&apos;) actions = ActionChains(brower)#构建action actions.drag_and_drop(source,target)# actions.perform()#调用perform()就是执行上面的动作链except Exception as e: print(e)finally: brower.close() ActionChains是什么呢？顾名思义，是一个动作链，如果在一个用例中只有一两个动作，那么用之前讲过的简单版的就可以了，如果动作很复杂，那么可以使用这个了。 1.ActionChains是自动执行低级交互的一种方式，例如：鼠标移动，鼠标点按，键盘操作，文本操作等。2.当我们调用这里的方法时，这些操作会被先储存在一个队列中，当我们调用perform()方法时，队列中的操作会被按顺序执行，执行后队列被清空。 iframe的切换参看网址:https://blog.csdn.net/huilan_same/article/details/52200586frame标签有frameset、frame、iframe三种，frameset跟其他普通标签没有区别，不会影响到正常的定位，而frame与iframe对selenium定位而言是一样的，selenium有一组方法对frame进行操作。 1.怎么切到frame中(switch_to.frame())selenium提供了switch_to.frame()方法来切换frame 1switch_to.frame(reference) 不得不提到switch_to_frame()，很多人在这样写的时候会发现，这句话被划上了删除线，原因是这个方法已经out了，之后很有可能会不支持，建议的写法是switch_to.frame() reference是传入的参数，用来定位frame，可以传入id、name、index以及selenium的WebElement对象，假设有如下HTML代码 index.html： 12345678&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;FrameTest&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src=&quot;a.html&quot; id=&quot;frame1&quot; name=&quot;myframe&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 想要定位其中的iframe并切进去，可以通过如下代码： 123456from selenium import webdriverdriver = webdriver.Firefox()driver.switch_to.frame(0) # 1.用frame的index来定位，第一个是0# driver.switch_to.frame(&quot;frame1&quot;) # 2.用id来定位# driver.switch_to.frame(&quot;myframe&quot;) # 3.用name来定位# driver.switch_to.frame(driver.find_element_by_tag_name(&quot;iframe&quot;)) # 4.用WebElement对象来定位 通常采用id和name就能够解决绝大多数问题。但有时候frame并无这两项属性，则可以用index和WebElement来定位：1.index从0开始，传入整型参数即判定为用index定位，传入str参数则判定为用id/name定位2.WebElement对象，即用find_element系列方法所取得的对象，我们可以用tag_name、xpath等来定位frame对象 比如： 1&lt;iframe src=&quot;myframetest.html&quot; /&gt; 用xpath定位，传入WebElement对象： 1driver.switch_to.frame(driver.find_element_by_xpath(&quot;//iframe[contains(@src,&apos;myframe&apos;)]&quot;)) 2.从frame中切回主文档(switch_to.default_content())切到frame中之后，我们便不能继续操作主文档的元素，这时如果想操作主文档内容，则需切回主文档。 1driver.switch_to.default_content() 3.嵌套frame的操作(switch_to.parent_frame())有时候我们会遇到嵌套的frame，如下： 12345&lt;html&gt; &lt;iframe id=&quot;frame1&quot;&gt; &lt;iframe id=&quot;frame2&quot; / &gt; &lt;/iframe&gt;&lt;/html&gt; 1.从主文档切到frame2，一层层切进去 12driver.switch_to.frame(&quot;frame1&quot;)driver.switch_to.frame(&quot;frame2&quot;) 2.从frame2再切回frame1，这里selenium给我们提供了一个方法能够从子frame切回到父frame，而不用我们切回主文档再切进来。 1driver.switch_to.parent_frame() # 如果当前已是主文档，则无效果 有了parent_frame()这个相当于后退的方法，我们可以随意切换不同的frame，随意的跳来跳去了。 所以只要善用以下三个方法，遇到frame分分钟搞定： 123driver.switch_to.frame(reference)driver.switch_to.parent_frame()driver.switch_to.default_content() 另外补充一下，之前曾看到过用点分法来切入嵌套frame的方法，但我试验之后发现并不能定位到frame： 1driver.switch_to.frame(&apos;frame1.0.frame3&apos;) 据说以上代码可以切到 “frame1” 下的 “第一个frame” 下的 “frame3” 中。 Selenium官方文档点击查看Selenium官方文档","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"爬虫","slug":"技术/爬虫","permalink":"http://puguojing.com/categories/技术/爬虫/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/tags/爬虫/"},{"name":"selenium","slug":"selenium","permalink":"http://puguojing.com/tags/selenium/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"爬虫","slug":"技术/爬虫","permalink":"http://puguojing.com/categories/技术/爬虫/"}]},{"title":"selenium的使用（1）安装及环境配置","slug":"selenium的使用（1）","date":"2018-08-30T07:49:51.000Z","updated":"2018-11-06T03:20:26.852Z","comments":true,"path":"2018/08/30/selenium的使用（1）/","link":"","permalink":"http://puguojing.com/2018/08/30/selenium的使用（1）/","excerpt":"","text":"1.安装selenium1pip install selenium 2.安装ChromeDriver2.1查看chrome版本： 我的版本是68.0 64 位，所以要下载对应的ChromeDriver版本，打开如下网址：https://chromedriver.storage.googleapis.com/index.html 下拉找到对应自己chrome版本的ChromeDriver版本，我的Chrome版本是68.0对应的ChromeDriver版本是2.40。 下面的是不同的chrome版本和对应的ChromeDriver版本对照表：第一列是ChromeDriver版本，第二列是chrome版本。 v2.40 v66-68v2.39 v66-68v2.38 v65-67v2.37 v64-66v2.36 v63-65v2.35 v62-64v2.34 v61-63v2.33 v60-62v2.32 v59-61v2.31 v58-60v2.30 v58-60v2.29 v56-58v2.28 v55-57v2.27 v54-56v2.26 v53-55v2.25 v53-55v2.24 v52-54v2.23 v51-53v2.22 v49-52v2.21 v46-50v2.20 v43-48v2.19 v43-47v2.18 v43-46v2.17 v42-43v2.13 v42-45v2.15 v40-43v2.14 v39-42v2.13 v38-41v2.12 v36-40v2.11 v36-40v2.10 v33-36v2.9 v31-34v2.8 v30-33v2.7 v30-33v2.6 v29-32v2.5 v29-32v2.4 v29-32 下载完成后会是一个chromedriver_mac64.zip压缩文件，解压后chromedriver是一个Unix可执行文件 接下来就需要配置环境变量让这个可执行文件在任意目录下可执行，你可以直接把它放到/usr/bin等已经存在环境变量路径的目录里，也可以新添加一条自己的路径：首先新建一个文件目录： 1sudo mkdir -p /usr/local/chromedriver 然后把‘chromedriver’这个可执行文件放到这个目录里,在‘chromedriver’这个可执行文件所在的目录下执行： 1sudo mv chromedriver /usr/local/chromedriver 可以把文件放到该目录。 接着打开配置文件添加环境变量路径： 1vim ./.bash_profile 添加一行： 1export PATH=&quot;/usr/local/chromedriver:$PATH&quot; 然后执行 1source ./.bash_profile 使修改生效，然后输入：export查看修改结果： 1234567~export...PATH=&apos;/usr/local/chromedriver:/usr/local/opt/imagemagick@6/bin:/Users/pgj/anaconda3/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/aria2/bin:/usr/local/share/dotnet:/Library/Frameworks/Mono.framework/Versions/Current/Commands:/Applications/Wireshark.app/Contents/MacOS:/Applications/Xamarin Workbooks.app/Contents/SharedSupport/path-bin:/usr/local/mysql/bin&apos;PWD=/Users/pgjSHELL=/bin/zsh.... 发现PATH中有：/usr/local/chromedriver目录路径（此路径一定要和chromedriver可执行文件所放目录一致，务必注意拼写错误），说明加入到环境变量成功。之后关闭命令行终端重新打开命令行终端输入：chromedriver如果控制台有如下显示输出说明配置好了: 123~ chromedriverStarting ChromeDriver 2.40.565386 (45a059dc425e08165f9a10324bd1380cc13ca363) on port 9515Only local connections are allowed. !!!注意该上述修改之后可能在运行代码是仍然会报：NOT FOUND chromedriver 错误，所以最好的办法就是直接把chromedriver可执行文件放入usr/bin/中。其他浏览器也是同样类似的只需要下载对应的驱动文件放入usr/bin/中即可，比如Firefox浏览器就需要下载GeckoDriver，地址如下：https://github.com/mozilla/geckodriver/releases 由于我的MAC版本是：10.13,系统开启了Rootless内核保护机制，所以需要关闭。（mac 从10.11及之后加入了Rootless内核保护机制）关闭方法参考如下链接：http://www.pc6.com/edu/86809.html1.重启电脑开后按住 Command-R 进入恢复分区. 然后在 实用工具 栏找到 终端启动运行.输入:csrutil disable; reboot2.你会看到系统保护被关闭的字样并且系统自动重启. 这样你就可以修改系统级别的文件了. 3.通过csrutil status来查询 Rootless 保护的状态. 12~ csrutil statusSystem Integrity Protection status: disabled. 4.最后就是重新激活 Rootless的方法了. 终端内输入：csrutil enable","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"爬虫","slug":"技术/爬虫","permalink":"http://puguojing.com/categories/技术/爬虫/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"selenium","slug":"selenium","permalink":"http://puguojing.com/tags/selenium/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"爬虫","slug":"技术/爬虫","permalink":"http://puguojing.com/categories/技术/爬虫/"}]},{"title":"MongoDB（1）- 安装、python操作","slug":"MongoDB（1）- python操作","date":"2018-08-29T09:22:49.000Z","updated":"2018-11-09T15:11:59.545Z","comments":true,"path":"2018/08/29/MongoDB（1）- python操作/","link":"","permalink":"http://puguojing.com/2018/08/29/MongoDB（1）- python操作/","excerpt":"","text":"介绍MongoDB C++语言编写，基于分布式文件存储系统开源数据库，其内容存储形式类似JSON对象，他的字段值可以包含其他文档、数组已经文档数组，非常灵活。中文官网官方文档 安装Windows不建议，不使用,安装非常麻烦！ Ubuntu官方安装教程：https://docs.mongodb.com/manual/installation/ Mac安装： 1brew install mongodb 创建存放数据库的文件夹： 1mkdir /data/db 启动： 12brew services start mongodbsudo mongod 停止和重启： 12brew services stop mongodbbrew services restart mongodb 参考其他: 123456#brew install mongodb#新建一个文件夹/data/db 用于存放MangoDB数据#启动MongoDB服务：brew services start mongodb#sudo mongodb#停止MongoDB服务：brew services stop mongodb#重启MongoDB服务：brew services restart mongodb Mac最大的优势就是不管什么软件安装起来都是如此简单！！！！ python 下使用安装pymongondb 包1pip3 install pymongo 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#!/usr/bin/python3# -*- coding:utf-8 -*-import pymongoimport pymongo#创建MongoDB连接对象client = pymongo.MongoClient(host=&apos;localhost&apos;,port=27017)#client = pymongo.MongoClient(&apos;mongondb://localhost:27017/&apos;)#指定或创建数据库db = client.testmongodb#db = client[&apos;testmongodb&apos;]#指定或创建集合(类似于table)collection = db.studens#collection = db[&apos;studens&apos;]#插入数据，数据以字典的形势表示data = &#123; &apos;id&apos;:&apos;20180001&apos;, &apos;name&apos;:&apos;Lio&apos;, &apos;age&apos;:20&#125;#第一种方式，插入一条数据#result = collection.insert(data)#print(result)#5b866486623b564260fca3f7data_1 = &#123; &apos;id&apos;:&apos;20180002&apos;, &apos;name&apos;:&apos;mark&apos;, &apos;age&apos;:21&#125;data_2 = &#123; &apos;id&apos;:&apos;20180003&apos;, &apos;name&apos;:&apos;kang&apos;, &apos;age&apos;:24&#125;#第一种方式，插入多条数据#result = collection.insert([data_1,data_2])#print(result)#[ObjectId(&apos;5b866b6c623b5643595070b2&apos;), ObjectId(&apos;5b866b6c623b5643595070b3&apos;)]data_3 = &#123; &apos;id&apos;:&apos;20180004&apos;, &apos;name&apos;:&apos;lin&apos;, &apos;age&apos;:25, &apos;gender&apos;:&apos;male&apos;&#125;#第二种方式，插入一条数据#result = collection.insert_one(data_3)#print(result)#&lt;pymongo.results.InsertOneResult object at 0x10c1d3d88&gt;#print(type(result))#&lt;class &apos;pymongo.results.InsertOneResult&apos;&gt;#print(result.inserted_id)#5b866c5d623b5643904db0afdata_4 = &#123; &apos;id&apos;:&apos;20180005&apos;, &apos;name&apos;:&apos;heler&apos;, &apos;age&apos;:30, &apos;gender&apos;:&apos;male&apos;&#125;data_5 = &#123; &apos;id&apos;:&apos;20180006&apos;, &apos;name&apos;:&apos;jay&apos;, &apos;age&apos;:22, &apos;gender&apos;:&apos;female&apos;&#125;#第二种方式插入多条数据#result = collection.insert_many([data_4,data_5])#print(result)#&lt;pymongo.results.InsertManyResult object at 0x109435ec8&gt;#print(type(result))#&lt;class &apos;pymongo.results.InsertManyResult&apos;&gt;#print(result.inserted_ids)#[ObjectId(&apos;5b866d0f623b5643c6acf070&apos;), ObjectId(&apos;5b866d0f623b5643c6acf071&apos;)]##### 推荐使用insert_one()和insert_many()#查询#可以使用find_one()和find（）方法进行查询，其中find_one()查询得到的是单条结果，find（）则是返回一个生成器对象#result = collection.find_one(&#123;&apos;name&apos;:&apos;Lio&apos;&#125;)#print(type(result))#&lt;class &apos;dict&apos;&gt;#print(result)#&#123;&apos;_id&apos;: ObjectId(&apos;5b866486623b564260fca3f7&apos;), &apos;id&apos;: &apos;20180001&apos;, &apos;name&apos;: &apos;Lio&apos;, &apos;age&apos;: 20&#125;#返回的是字典类型，其中数据多了一个_id属性他是MongoDB插入数据时自动添加的#此外我们可以根据ObjectId来查询，此时需要bson库中的objectid:#from bson.objectid import ObjectId#result = collection.find_one(&#123;&apos;_id&apos;:ObjectId(&apos;5b866486623b564260fca3f7&apos;)&#125;)#print(type(result))#&lt;class &apos;dict&apos;&gt;#print(result)#&#123;&apos;_id&apos;: ObjectId(&apos;5b866486623b564260fca3f7&apos;), &apos;id&apos;: &apos;20180001&apos;, &apos;name&apos;: &apos;Lio&apos;, &apos;age&apos;: 20&#125;#对于多条数据查询可以使用find#results = collection.find(&#123;&apos;age&apos;:30&#125;)#print(type(results))#&lt;class &apos;pymongo.cursor.Cursor&apos;&gt;#print(results)#&lt;pymongo.cursor.Cursor object at 0x10cd07160&gt;#for result in results:#&#123;&apos;_id&apos;: ObjectId(&apos;5b866d0f623b5643c6acf070&apos;), &apos;id&apos;: &apos;20180005&apos;, &apos;name&apos;: &apos;heler&apos;, &apos;age&apos;: 30, &apos;gender&apos;: &apos;male&apos;&#125;# print(result)#返回的结果是cursor类型，相当于一个生成器#条件查询#查询年龄大于20的数据#results = collection.find(&#123;&apos;age&apos;:&#123;&apos;$gt&apos;:20&#125;&#125;)#print(type(results))#&lt;class &apos;pymongo.cursor.Cursor&apos;&gt;#print(results)#&lt;pymongo.cursor.Cursor object at 0x10cf561d0&gt;#for result in results:## print(result)#查询结果：#&#123;&apos;_id&apos;: ObjectId(&apos;5b866b6c623b5643595070b2&apos;), &apos;id&apos;: &apos;20180002&apos;, &apos;name&apos;: &apos;mark&apos;, &apos;age&apos;: 21&#125;#&#123;&apos;_id&apos;: ObjectId(&apos;5b866b6c623b5643595070b3&apos;), &apos;id&apos;: &apos;20180003&apos;, &apos;name&apos;: &apos;kang&apos;, &apos;age&apos;: 24&#125;#&#123;&apos;_id&apos;: ObjectId(&apos;5b866c5d623b5643904db0af&apos;), &apos;id&apos;: &apos;20180004&apos;, &apos;name&apos;: &apos;lin&apos;, &apos;age&apos;: 25, &apos;gender&apos;: &apos;male&apos;&#125;#&#123;&apos;_id&apos;: ObjectId(&apos;5b866d0f623b5643c6acf070&apos;), &apos;id&apos;: &apos;20180005&apos;, &apos;name&apos;: &apos;heler&apos;, &apos;age&apos;: 30, &apos;gender&apos;: &apos;male&apos;&#125;#&#123;&apos;_id&apos;: ObjectId(&apos;5b866d0f623b5643c6acf071&apos;), &apos;id&apos;: &apos;20180006&apos;, &apos;name&apos;: &apos;jay&apos;, &apos;age&apos;: 22, &apos;gender&apos;: &apos;female&apos;&#125;#这里的查询条件是一个字典形式：意思是查询age大于20的信息,$gt是大于，其他常见入如下：#$lt 小于 &#123;&apos;age&apos;:&#123;&apos;$lt&apos;:20&#125;&#125;#$gt 大于 &#123;&apos;age&apos;:&#123;&apos;$gt&apos;:20&#125;&#125;#$lte 小于等于 &#123;&apos;age&apos;:&#123;&apos;$lte&apos;:20&#125;&#125;#$gte 大于等于 &#123;&apos;age&apos;:&#123;&apos;$gte&apos;:20&#125;&#125;#$ne 不等于 &#123;&apos;age&apos;:&#123;&apos;$ne&apos;:20&#125;&#125;#$in 在范围内 &#123;&apos;age&apos;:&#123;&apos;$in&apos;:[20,23]&#125;&#125;#$nin 不在范围内 &#123;&apos;age&apos;:&#123;&apos;$nin&apos;:[20,23]&#125;&#125;#$lt 小于 &#123;&apos;age&apos;:&#123;&apos;$t&apos;:20&#125;&#125;#还可以正则匹配#results = collection.find(&#123;&apos;name&apos;:&#123;&apos;$regex&apos;:&apos;^M.*&apos;&#125;&#125;)#&apos;$regex&apos;表示使用正则匹配，&apos;^M.*&apos;表示以M开头#其他：#$exists 属性是否存在 &#123;&apos;name&apos;:&#123;&apos;$exists&apos;:True&#125;&#125; name的属性存在#$type 类型判断 &#123;&apos;age&apos;:&#123;&apos;$type&apos;:&apos;int&apos;&#125;&#125; age的类型为int#$mod 数字模操作 &#123;&apos;age&apos;:&#123;&apos;$mod&apos;:&apos;[5,0]&apos;&#125;&#125; 年龄的模5余0#$text 文本查询 &#123;&apos;$text&apos;:&#123;&apos;$search&apos;:&apos;Mike&apos;&#125;&#125; text类型的属性中包含Mike字符串#$where 高级条件查询 &#123;&apos;where&apos;:&apos;obj.fans_count == obj.follows_count&apos;&#125; 自身粉丝数等于关注数#计数#可使用count函数统计查询的数据条数#count = collection.find(&#123;&apos;name&apos;:&#123;&apos;$regex&apos;:&apos;^.*&apos;&#125;&#125;).count()#print(count)#排序#pymongo.ASCENDIN升序,pymongo.DESCENDING降序#results = collection.find().sort(&apos;name&apos;,pymongo.DESCENDING)#for result in results:# print(result)#偏移#使用skip(2)，表示偏移几个位置，及忽略查询到的前面2条数据#使用limit(2)表示最多获取多少结果，限制获取的条数#！！！注意在庞大数据的时候（千万、亿级别）不要使用大偏移量来查询数据，可能导致内存溢出#可以使用类似如下操作:#from bson.objectid import ObjectId#collection.find(&#123;&apos;_id&apos;:&#123;&apos;$gt&apos;:&apos;5b866b6c623b5643595070b2&apos;&#125;&#125;)#这时只需要记录上次查询的id#更新#使用update()方法更新#condition = &#123;&apos;name&apos;:&apos;Lio&apos;&#125;#result_1 = collection.find_one(condition)#print(result_1)#result_1[&apos;age&apos;] = 20#result_2 = collection.update(condition,result_1)#print(result_2)#这里我们需要先查询到要修改的数据，修改完之后使用udate()方法将修改后的数据传入#执行结果#&#123;&apos;_id&apos;: ObjectId(&apos;5b866486623b564260fca3f7&apos;), &apos;id&apos;: &apos;20180001&apos;, &apos;name&apos;: &apos;Lio&apos;, &apos;age&apos;: 20&#125;#&#123;&apos;n&apos;: 1, &apos;nModified&apos;: 0, &apos;ok&apos;: 1.0, &apos;updatedExisting&apos;: True&#125;#还可以使用 $set 进行更新,注意使用$set只会更新result_1字典里存在的字段，如果原先还有其他字段怎不会更新也不会删除#而如果不用$set，会把之前的数据全部用result_1替换，若原数据存在其他字段则会被删除#condition = &#123;&apos;name&apos;:&apos;Lio&apos;&#125;#result_1 = collection.find_one(condition)#print(result_1)#result_1[&apos;age&apos;] = 20#result_2 = collection.update(condition,&#123;&apos;$set&apos;:result_1&#125;)#print(result_2)#建议使用update_one()和update_many()，第二个参数不能直接使用字典要使用$类型操作符#使用matched_count(匹配的数据条数)和modified_count(影响的数据条数)查看结果#condition = &#123;&apos;name&apos;:&apos;Lio&apos;&#125;#result_1 = collection.find_one(condition)#result_1[&apos;age&apos;] = 22#result_2 = collection.update_one(condition,&#123;&apos;$set&apos;:result_1&#125;)#print(result_2)#print(result_2.matched_count,result_2.modified_count)#执行结果#&#123;&apos;_id&apos;: ObjectId(&apos;5b866486623b564260fca3f7&apos;), &apos;id&apos;: &apos;20180001&apos;, &apos;name&apos;: &apos;Lio&apos;, &apos;age&apos;: 20&#125;#&#123;&apos;n&apos;: 1, &apos;nModified&apos;: 1, &apos;ok&apos;: 1.0, &apos;updatedExisting&apos;: True&#125;#&lt;pymongo.results.UpdateResult object at 0x110dd2fc8&gt;#1 1#使用条件#表示查询年龄条件大于20的人，然后更新条件为&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:1&#125;，表示age加1，执行后将会在爱满足条件的数据age字段加1#condition = &#123;&apos;age&apos;:&#123;&apos;$gt&apos;:20&#125;&#125;#result_2 = collection.update_one(condition,&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:1&#125;&#125;)#print(result_2)#print(result_2.matched_count,result_2.modified_count)#执行结果：由于使用了update_one所以只影响了1条数据#&lt;pymongo.results.UpdateResult object at 0x10627bf48&gt;#1 1#使用update_many(),更新所有#condition = &#123;&apos;age&apos;:&#123;&apos;$gt&apos;:10&#125;&#125;#result_2s = collection.update_many(condition,&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:1&#125;&#125;)#print(type(result_2s))#print(result_2s)#print(result_2s.matched_count,result_2s.modified_count)#执行结果#&lt;class &apos;pymongo.results.UpdateResult&apos;&gt;#&lt;pymongo.results.UpdateResult object at 0x10f76bfc8&gt;#6 6#删除#result = collection.remove(&#123;&apos;name&apos;:&apos;heler&apos;&#125;)#print(result) #&#123;&apos;n&apos;: 1, &apos;ok&apos;: 1.0&#125;#推荐使用delete_one()和delete_many()#result = collection.delete_one(&#123;&apos;name&apos;:&apos;lin&apos;&#125;)#print(result) #&lt;pymongo.results.DeleteResult object at 0x10e8fadc8&gt;#print(result.deleted_count)result = collection.delete_many(&#123;&apos;age&apos;:&#123;&apos;$lt&apos;:26&#125;&#125;)print(result) #&lt;pymongo.results.DeleteResult object at 0x10e40bdc8&gt;print(result.deleted_count) #4#其他操作#find_one_and_delete()#find_one_and_replace()#find_one_and_update()#详见官方文档","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://puguojing.com/tags/数据库/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://puguojing.com/tags/MongoDB/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}]},{"title":"Mysql常用pyhon接口的实现：增、删、改、查","slug":"Mysql常用pyhon接口的代码实现","date":"2018-08-28T15:20:31.000Z","updated":"2018-11-06T03:16:56.776Z","comments":true,"path":"2018/08/28/Mysql常用pyhon接口的代码实现/","link":"","permalink":"http://puguojing.com/2018/08/28/Mysql常用pyhon接口的代码实现/","excerpt":"","text":"代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#!/usr/bin/python3# -*- coding:utf-8 -*-import pymysql&quot;&quot;&quot;函数：CreateDatabase(Database_name)功能：创建数据库参数：Database_name：要创建的数据库名&quot;&quot;&quot;def CreateDatabase(Database_name): db = pymysql.connect(host=&apos;localhost&apos;,user=&apos;root&apos;,password=&apos;password&apos;,port=3306) cursor = db.cursor() cursor.execute(&apos;SELECT VERSION()&apos;) data = cursor.fetchone() print(&apos;DataBase Version:&apos;,data) sql = &apos;CREATE DATABASE &#123;&#125; DEFAULT CHARACTER SET utf8&apos;.format(Database_name) try: cursor.execute(sql) except Exception as e: print(&apos;Create %s error：&apos;%(Database_name), e) db.close()&quot;&quot;&quot;函数：CreateTables(DataBase,table)功能：在指定数据库里面创建指定的表参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名&quot;&quot;&quot;def CreateTables(DataBase,table): db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306,db=DataBase) cursor = db.cursor() sql = &apos;CREATE TABLE IF NOT EXISTS &#123;&#125; (id VARCHAR(255) NOT NULL,user_name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id))&apos;.format(table) try: cursor.execute(sql) except Exception as e: print(&apos;%s Create %s error：&apos;%(DataBase,table),e) db.close()&quot;&quot;&quot;函数：Insert(DataBase,table,data)功能：在某一数据库的指定表中插入一条数据,如果该数据的key已经存在则会插入失败参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名 3.data：要插入的数据，字典类型比如： data = &#123; &apos;id&apos;:&apos;20180001&apos;, &apos;user_name&apos;:&apos;Bob&apos;, &apos;age&apos;:20 &#125;&quot;&quot;&quot;def Insert(DataBase,table,data): db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306, db=DataBase) cursor = db.cursor() keys = &apos;,&apos;.join(data.keys())#-&gt;id,user_name,age values = &apos;,&apos;.join([&apos;%s&apos;] * len(data))#[&apos;a&apos;]*4 -&gt; [a,a,a,a] &apos;,&apos;.join([a,a,a,a])-&gt;&apos;a,a,a,a&apos; sql = &apos;INSERT INTO &#123;t&#125; (&#123;k&#125;) VALUES(&#123;v&#125;)&apos;.format(t=table,k=keys,v=values)#使用form格式化结果：INSERT INTO students (id,user_name,age) VALUES(%s,%s,%s) print(sql) try: cursor.execute(sql, tuple(data.values())) db.commit() except Exception as e: print(&quot;insert error&quot;, e) db.rollback() db.close()&quot;&quot;&quot;函数：Update(Database,table,data)功能：根据key更新某一数据库的指定表中的某一条数据，如果key存在在更新数据，不存在则插入数据参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名 3.data：要更新或插入的数据，字典类型比如： data = &#123; &apos;id&apos;:&apos;20180002&apos;, &apos;user_name&apos;:&apos;lio&apos;, &apos;age&apos;:22 &#125;&quot;&quot;&quot;def Update(Database,table,data): &quot;&quot;&quot; data = &#123; &apos;id&apos;:&apos;20180001&apos;, &apos;user_name&apos;:&apos;Bob&apos;, &apos;age&apos;:20 &#125; &quot;&quot;&quot; # table = &apos;students&apos; db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306, db=Database) cursor = db.cursor() keys = &apos;,&apos;.join(data.keys()) # -&gt;id,user_name,age values = &apos;,&apos;.join([&apos;%s&apos;] * len(data)) # [&apos;a&apos;]*4 -&gt; [a,a,a,a] &apos;,&apos;.join([a,a,a,a])-&gt;&apos;a,a,a,a&apos; sql = &apos;INSERT INTO &#123;t&#125; (&#123;k&#125;) VALUES(&#123;v&#125;) ON DUPLICATE KEY UPDATE&apos;.format(t=table, k=keys, v=values) # 使用format格式化INSERT INTO students (id,user_name,age) VALUES(%s,%s,%s) ON DUPLICATE KEY UPDATE update = &apos;,&apos;.join(&apos; &#123;key&#125; = %s&apos;.format(key=key) for key in data) #注意前面有空格，结果：&apos; id = %s,user_name = %s,age = %s&apos; #ON DUPLICATE KEY UPDATE 表示如果主键存在就执行UPDATE 而不是插入 sql += update #结果：INSERT INTO students (id,user_name,age) VALUES(%s,%s,%s) ON DUPLICATE KEY UPDATE id = %s, user_name = %s, age = %s try: cursor.execute(sql, tuple(data.values())*2)#使用了2次值，共6个%s db.commit() except Exception as e: print(&quot;insert error&quot;, e) db.rollback() db.close()&quot;&quot;&quot;函数：Delete(Database,table,condition):功能：根据指定条件删除数据库某表中的满足条件的数据参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名 3.condition：指定的SQL语句条件，比如：&apos;age &gt; 20&apos;,表示删除所有 age字段的值大于20的数据&quot;&quot;&quot;def Delete(Database,table,condition): db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306, db=Database) cursor = db.cursor() sql = &apos;DELETE FROM &#123;tables&#125; WHERE &#123;conditions&#125;&apos;.format(tables=table,conditions=condition) try: cursor.execute(sql) db.commit() except Exception as e: print(&quot;insert error&quot;, e) db.rollback() db.close()&quot;&quot;&quot;函数：Select(Database,table,condition)功能：从数据库某表中根据指定条件查询的满足条件的数据参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名 3.condition：指定的SQL语句条件，比如：&apos;age &gt; 20&apos;,表示查询所有age字段的值大于20的数据返回值：列表，存储满足查询条件的信息，列表的每个元素是一条信息，用元组封装。&quot;&quot;&quot;def Select(Database,table,condition): db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306, db=Database) cursor = db.cursor() sql = &apos;SELECT * FROM &#123;tablses&#125; WHERE &#123;conditions&#125;&apos;.format(tablses=table,conditions=condition) result = [] try: cursor.execute(sql) row = cursor.fetchone()#row是以元组返回，row： (&apos;20180001&apos;, &apos;Bob&apos;, 20) while row: result.append(row) row=cursor.fetchone() except Exception as e: print(&quot;SELECT error&quot;, e) db.close() return resultdef main(): CreateDatabase(&apos;test_db&apos;) CreateTables(&apos;test_db&apos;,&apos;test_db_table_1&apos;) data = &#123; &apos;id&apos;:&apos;20180004&apos;, &apos;user_name&apos;:&apos;jack&apos;, &apos;age&apos;:22 &#125; Insert(&apos;test_db&apos;,&apos;test_db_table_1&apos;,data) data = &#123; &apos;id&apos;:&apos;20180004&apos;, &apos;user_name&apos;:&apos;jack&apos;, &apos;age&apos;:25 &#125; Update(&apos;test_db&apos;,&apos;test_db_table_1&apos;,data) #Delete(&apos;test_db&apos;,&apos;test_db_table_1&apos;,&apos;age &gt; 21&apos;) result= Select(&apos;test_db&apos;,&apos;test_db_table_1&apos;,&apos;age &gt; 19&apos;) print(result)if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"http://puguojing.com/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"http://puguojing.com/tags/MySQL/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}]},{"title":"mac下MySQL忘记密码如何重置？","slug":"Mysql忘记密码解决办法","date":"2018-08-28T15:20:31.000Z","updated":"2018-11-06T04:31:11.576Z","comments":true,"path":"2018/08/28/Mysql忘记密码解决办法/","link":"","permalink":"http://puguojing.com/2018/08/28/Mysql忘记密码解决办法/","excerpt":"","text":"忘记Mysql密码如何重置？step1： 苹果-&gt;系统偏好设置-&gt;最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server） step2： 进入终端输入：cd /usr/local/mysql/bin/ 回车后 登录管理员权限 sudo su 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe –skip-grant-tables &amp; 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） step3. 输入命令 ./mysql 回车后，输入命令 FLUSH PRIVILEGES; 回车后，输入命令 ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘password’;（会把密码重置为password，如果想改其他的把password替换即可） 完整步骤如下图:","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"http://puguojing.com/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"http://puguojing.com/tags/MySQL/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"数据库","slug":"技术/数据库","permalink":"http://puguojing.com/categories/技术/数据库/"}]},{"title":"python爬虫-爬取豆瓣书籍（1）","slug":"python爬虫-爬取豆瓣书籍（1）","date":"2018-08-26T06:10:20.000Z","updated":"2018-11-06T03:19:03.116Z","comments":true,"path":"2018/08/26/python爬虫-爬取豆瓣书籍（1）/","link":"","permalink":"http://puguojing.com/2018/08/26/python爬虫-爬取豆瓣书籍（1）/","excerpt":"","text":"本篇记录使用Requests + Xpath爬取豆瓣书籍 1.RequestsRequests是python的一个HTTP库，里面包含了常见的一些HTTP操作，下面是Requests常用的七种方法： 方法 说明 requests.request() 构造一个请求，支撑以下方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页的信息头的方法，对应于HTTP的HEAD requests.post() 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HTML网页提交局部修改请求的方法，对应于HTTP的PATCH requests.delete() 向HTML网页提交请删除求的方法，对应于HTTP的DELETE 我们最常用的就是request.get()方法。 Requests.get()的用法12import requests#导入Requests库r = requests.get(url)#使用get方法发送请求，返回包含网页数据的Response并存储到对象r中 Response对象的属性r.statues.code: http请求的返回状态，200表示连接成功，404表示连接失败 r.text：http响应内容的字符串形式，url对应的页面内容 r.encoding：从HTTP header中猜测的响应内容编码方式 r.apparent_encoding：从内容分析出的响应内容的编码方式（备选编码方式） r.content:HTTP响应内容的二进制形式 r.headers：http响应内容的头部内容 123456789resp.text返回的是Unicode型的数据。resp.content返回的是bytes型也就是二进制的数据。也就是说，如果你想取文本，可以通过r.text。如果想取图片，文件，则可以通过r.content。（resp.json()返回的是json格式数据） 查看Requestes开发文档 Xpathxpath即为XML路径语言（XML Path Language），他是一种用来确定XML文档中某部分位置的语言。Xpath基于XML的树状结构，提供在数据结构树中找寻节点的能力。起初Xpath的提出初衷是将其做为一个通用的、介于Xpointer与XSL间的语法模型，但是很快Xpath被开发者采用来当作小型的查询语言。 Xpath解析网页的流程1.首先通过Requests库获取网页数据。2.通过网页解析得到想要的数据或者新的链接。3.网页解析可以通过Xpath或者其他的解析工具进行。Xpath，是一个非常友好的网页解析工具。 lxml库lxml库结合libxml2快速强大的特性，使用xpath语法来进行文件格式解析，与Beautiful相比，效率更高。 安装1pip install lxml 使用123from lxml import etree #导入库data = requests.get(url).text#获取网页内容s = etree.HTML(data)#解析网页节点 代码： 1234567891011121314151617181920def craw_douban_book_top250(): msg_num = 0 #数量统计 for page in range(10): #根据对网站分析，每页有25条信息，所有爬取10页共250条 url = &apos;https://book.douban.com/top250?start=&#123;&#125;&apos;.format(page*25)#每页的url地址最后刚好差25 data = requests.get(url).text #获取网页的内容 s = etree.HTML(data) #解析HTML节点转换成对象 divs = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table&apos;) #每一本书籍最外部的节点 for div in divs: msg_num += 1 title = div.xpath(&apos;./tr/td[2]/div[1]/a/@title&apos;)[0]#从最外部节点找到书籍名，后面加[0]是引用列表元素。 href = div.xpath(&apos;./tr/td[2]/div[1]/a/@href&apos;)[0]#从最外部节点找到书籍详细链接 score = div.xpath(&apos;./tr/td[2]/div[2]/span[2]/text()&apos;)[0]#从最外部节点找到书籍评分 score_people_num = div.xpath(&apos;./tr/td[2]/div[2]/span[3]/text()&apos;)[0]\\ .strip(&quot;(&quot;).strip().strip(&quot;)&quot;)#从最外部节点找到书籍评价人数，并去除左右两边的括号和中间的空格 print(&quot;&#123;&#125;: &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(msg_num, title, href, score, score_people_num)) time.sleep(1)#防止抓取信息过于频繁导致IP被封及尽量不影响别人的网站 通过对豆瓣TOP250书籍的url分析对比如下： 12345&lt;a href=&quot;https://book.douban.com/top250?start=25&quot;&gt;2&lt;/a&gt;&lt;a href=&quot;https://book.douban.com/top250?start=50&quot;&gt;3&lt;/a&gt;&lt;a href=&quot;https://book.douban.com/top250?start=75&quot;&gt;4&lt;/a&gt;&lt;a href=&quot;https://book.douban.com/top250?start=100&quot;&gt;5&lt;/a&gt;.... 我们发现区别就在于最后”start=”的数值每次相差25，所以 可以使用： 12for page in range(10): 10页共250条 url = &apos;https://book.douban.com/top250?start=&#123;&#125;&apos;.format(page*25) 来获取网页地址。 我们在获取每一本书的Xpath的时候也发现相应的规律，比如第一本书： 1234书籍的Xpath：‘//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]’书名的Xpath: &apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div[1]/a&apos;评分的Xpath：‘//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div[2]/span[2]’人数的Xpath：‘//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div[2]/span[3]’ 我们可以看到的是书名、评分、人数的Xpath都是在整本书的Xpath=‘//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]’的基础上在多加一点内容。所以我们可以这样写： 123456789divs = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table&apos;) #每一本书籍最外部的节点 for div in divs: msg_num += 1 title = div.xpath(&apos;./tr/td[2]/div[1]/a/@title&apos;)[0]#从最外部节点找到书籍名 href = div.xpath(&apos;./tr/td[2]/div[1]/a/@href&apos;)[0]#从最外部节点找到书籍详细链接 score = div.xpath(&apos;./tr/td[2]/div[2]/span[2]/text()&apos;)[0]#从最外部节点找到书籍评分 score_people_num = div.xpath(&apos;./tr/td[2]/div[2]/span[3]/text()&apos;)[0]\\ .strip(&quot;(&quot;).strip().strip(&quot;)&quot;)#从最外部节点找到书籍评价人数，并去除左右两边的括号和中间的空格 每一个信息都是在最外部的节点路径上加上更详细的路径。 注意： 1.当我们复制Xpath是里面会有一个”tbody/“内容，我们在下载时需要把这个内容删除掉，不然无法获取对应的信息。2.关于在Xpath内容后加上”text()“,”@title”、”@href“等内容是Xpath语法详见XPath总结的内容。 下面是另一个爬取小猪短租南京在指定时间内的信息 123456789101112131415161718def Craw(): msg_num = 0 for p in range(1,6): url = &apos;http://nj.xiaozhu.com/search-duanzufang-p&#123;&#125;-0/?startDate=2018-08-27&amp;endDate=2018-09-30&apos;.format(p) data = requests.get(url).text s = etree.HTML(data) #print(data) divs = s.xpath(&apos;//*[@id=&quot;page_list&quot;]/ul/li&apos;) for div in divs: msg_num += 1 titles = div.xpath(&apos;./div[2]/div/a/span/text()&apos;)[0] details = div.xpath(&apos;./div[2]/div/em/text()&apos;)[0].strip() prices = div.xpath(&apos;./div[2]/span[1]/i/text()&apos;)[0] href = div.xpath(&apos;./a/@href&apos;)[0] time.sleep(1) print(&quot;&#123;&#125;: &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(msg_num,titles,details,prices,href)) 加入存储数据到文件的内容： 12345678910111213141516171819202122def Craw(): msg_num = 0 with open(r&apos;/Users/pgj/Desktop/data.csv&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;) as f: for p in range(1,3): url = &apos;http://nj.xiaozhu.com/search-duanzufang-p&#123;&#125;-0/?startDate=2018-08-27&amp;endDate=2018-09-30&apos;.format(p) data = requests.get(url).text s = etree.HTML(data) #print(data) divs = s.xpath(&apos;//*[@id=&quot;page_list&quot;]/ul/li&apos;) for div in divs: msg_num += 1 titles = div.xpath(&apos;./div[2]/div/a/span/text()&apos;)[0] details = div.xpath(&apos;./div[2]/div/em/text()&apos;)[0].strip() prices = div.xpath(&apos;./div[2]/span[1]/i/text()&apos;)[0] href = div.xpath(&apos;./a/@href&apos;)[0] time.sleep(1) f.write(&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\\n&quot;.format(msg_num,titles,details,prices,href)) print(&quot;&#123;&#125;: &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(msg_num,titles,details,prices,href))Craw()","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"爬虫","slug":"技术/爬虫","permalink":"http://puguojing.com/categories/技术/爬虫/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/tags/爬虫/"},{"name":"Requests","slug":"Requests","permalink":"http://puguojing.com/tags/Requests/"},{"name":"Xpath","slug":"Xpath","permalink":"http://puguojing.com/tags/Xpath/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"爬虫","slug":"技术/爬虫","permalink":"http://puguojing.com/categories/技术/爬虫/"}]},{"title":"项目-learning-log（2）","slug":"项目-learning-log（2）","date":"2018-08-23T08:47:12.000Z","updated":"2018-11-06T03:16:18.859Z","comments":true,"path":"2018/08/23/项目-learning-log（2）/","link":"","permalink":"http://puguojing.com/2018/08/23/项目-learning-log（2）/","excerpt":"","text":"&#8195;&#8195; 用户账户 此处只记录在项目中实现登录功能时遇到的问题以及解决方法。 3. 创建用户账户 3.2 登陆页面 此处与书中不同，书中使用Django提供的默认登陆视图，而此处则是自己实现login登录视图。在users中的urls.py中添加如下代码： 12345678urlpatterns = [ # 登陆页面 #path(&quot;login/&quot;, login, &#123;&quot;template_name&quot;: &quot;users/login.html&quot;&#125;, name=&quot;login&quot;), path(&apos;login/&apos;, views.login_view,name=&quot;login&quot;), path(&quot;logout/&quot;, views.logout_view, name=&quot;logout&quot;), path(&quot;register/&quot;, views.register, name=&quot;register&quot;),] 原文中使用views中自带的login，但是我的Django版本是2.1。views中没有login，于是自己在view中实现login。views.PY代码如下： 12345678910111213141516171819202122from django.shortcuts import render, redirect, reversefrom django.contrib.auth import authenticate,login,logoutfrom django.http import HttpResponseRedirectfrom django.contrib.auth.forms import UserCreationFormdef login_view(request): if request.method == &apos;GET&apos;: return render(request, &apos;users/login.html&apos;) username = request.POST.get(&apos;username&apos;, &apos;&apos;) password = request.POST.get(&apos;password&apos;, &apos;&apos;) user = authenticate(request, username=username, password=password) if user is not None: login(request, user) return redirect(reverse(&apos;learning_logs:index&apos;)) else: return render(request, &apos;users/login.html&apos;, &#123; &apos;username&apos;: username, &apos;password&apos;: password, &#125;) login.html如下： 12345678910111213141516&#123;% extends &quot;learning_logs/base.html&quot; %&#125;&#123;% block content %&#125; &lt;form action=&quot;&#123;% url &apos;users:login&apos; %&#125;&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &#123;&#123; form.as_p &#125;&#125; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;&#123;&#123; username &#125;&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;用户名&quot; required autofocus&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; value=&quot;&#123;&#123; password &#125;&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; required&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt;&#123;% endblock %&#125; 此处登录界面完成。 其它内容请参考:原文链接","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"项目","slug":"技术/项目","permalink":"http://puguojing.com/categories/技术/项目/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://puguojing.com/tags/Django/"},{"name":"Web框架","slug":"Web框架","permalink":"http://puguojing.com/tags/Web框架/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"项目","slug":"技术/项目","permalink":"http://puguojing.com/categories/技术/项目/"}]},{"title":"项目-learning-log（1）","slug":"项目-learning-log（1）","date":"2018-08-23T05:51:18.000Z","updated":"2018-11-06T03:16:10.216Z","comments":true,"path":"2018/08/23/项目-learning-log（1）/","link":"","permalink":"http://puguojing.com/2018/08/23/项目-learning-log（1）/","excerpt":"","text":"&#8195;&#8195; 《Python编程：从入门到实践》笔记。记一次完成一个“学习笔记”的小网站。 1. 前言 在本篇中，我们将： 用Django来开发一个名为“学习笔记”(Learning Log)的项目； 为这个项目制定规范，然后为应用程序使用的数据定义模型； 使用Django的管理系统来输入一些初试数据，再学习编写视图和模板，让Django能够为我们的网站创建网页。 &#8195;&#8195;不过在开始之前，请先新建一个虚拟环境并安装Django。如果没有虚拟环境，通过pip安装的所有库都会保存到python的site-packages目录下。开发多个项目时，都会用同一个python，而某些项目并不需要其中的所有第三方库，但如果将这些不需要库的删除，又会影响到其他项目。而且，如果A项目需要Django2.0.4，B项目需要Django2.0.0，这该怎么办？此时就需要虚拟环境。它其实就相当于一个新的文件夹，将新项目与其他项目隔离，本项目的库不与其他项目的库相关联，类似于操作系统的多用户概念。 如果使用的是Python 3，可以使用命令： python -m venv ll_env 如果该命令不成功，可能是没有安装virtualenv模块：pip install virtualenv 然后创建并激活虚拟环境： 12345678910#创建虚拟环境，ll_env代表着虚拟环境名称virtualenv ll_env# linux:source ll_env/bin/activate# windows:ll_env\\Scripts\\activate# 停用：deactivate 管理虚拟环境的库还有很多，有兴趣的话可以到网上搜一搜。 如果你使用的是新版的PyCharm，那么它在新建项目的时候默认就会创建新的虚拟环境。 激活虚拟环境后就可以安装Django了： pip install django 2. 建立项目 2.1 在Django中创建项目 2.1.1 生成项目在虚拟环境中执行如下命令： 123# 主要最后有个实心句号！# 这个句点让新项目使用合适的目录结构，这样开发完成后可以轻松地将应用程序部署到服务器django-admin startproject learning_log . 执行上述命令后，将多出一个manage.py文件和一个learning_log文件夹，当然还有本身的一个ll_env文件夹。 而在learning_log文件夹中，又有四个文件：init.py，settings.py，urls.py，wsgi.py。 manage.py是一个简单的程序，它接收命令并将其交给Django的相关部分去运行；settings.py指定Django如何与你的系统交互以及如何管理项目，其实就是配置文件；urls.py告诉Django应创建哪些网页来响应浏览器请求；wsgi.py是web server gateway interface(Web服务器网关接口)的缩写，帮助Django提供它创建的文件。至于init.py，它是个空文件，Python的每个模块下必须要有这个文件。##### 2.1.2 创建数据库Django将大部分与项目相关的信息都存储在数据库中，所有还需要创建一个供Django使用的数据库。依然是在虚拟环境下执行如下命令：python manage.py migrate&#8195;&#8195;在PyCharm中的话，可以通过点击工具栏Tools中的Run manage.py Task（Ctrl+Alt+R），在弹出的命令行中直接输入原命令中manage.py后面的部分，后面的命令也可以这样执行（[appname]是自动提示）。&#8195;&#8195;”migrate”这个单词其实是迁移的意思，并不是“创建(create)”。之所以使用这个词，是因为一般将修改数据库的过程称为迁移数据库（笔者数据库学得渣，这段解释直接从书里照搬的，希望哪位大神在留言区解释一波）。如果是刚创建的项目，并且第一次执行，将会得到如下输出：123456Operations to perform: Apply all migrations: admin, auth, contenttypes, sessionsRunning migrations: Applying contenttypes.0001_initial... OK -- snip -- Applying sessions.0001_initial... OK从第2行结果可以看出，Django将创建和修改数据库看做是对数据库的迁移，Apply all migrations确保数据库结构与当前代码匹配（比如你修改了类的结构，添加了属性，这就相当于修改了数据表）。执行命令后，项目的根目录下会多出一个名为db.sqlite3的数据库文件。SQLite是一种使用单个文件的轻量级数据库，常用于开发简单应用程序，它让你不用太关注数据库管理的问题。##### 2.1.3 运行项目依然在项目的虚拟环境下输入如下命令：1python manage.py runserver得到如下输出：1234567Performing system checks...System check identified no issues (0 silenced).April 21, 2018 - 20:46:48Django version 2.0.4, using settings &apos;learning_log.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK.现在在浏览器中地址栏输入localhost:8000 (或者127.0.0.1:8000)，将得到如下页面：这是最新版的Django的默认启动界面。##### 3.1 映射URL（此处与原文略有不同）——-Django创建网页的过程通常分三个阶段：定义URL、编写视图和编写模板。URL模式描述了URL是如何设计的，让Django知道如何将浏览器请求与网站URL匹配，以确定返回哪个网页。每个URL都被映射到特定的视图——视图函数获取并处理网页所需的数据。视图函数通常调用一个模板，后者生成浏览器能够理解的网页。目前，基础URL(http://localhost:8000/ )返回默认的Django页面，现在修改这个映射，将其映射到我们自己编写的主页。打开learning_log文件夹中的urls.py，将看到如下内容：123456789101112131415161718from django.contrib import adminfrom django.urls import pathurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls),]# 书中的内容和实际的内容有些出入，以下是书中内容：# 新版Django简化了URL路由写法# from django.conf.urls import include, url# from django.contrib import admin# # from django.conf.urls import include, url# from django.contrib import admin## urlpatterns = [# url(r&apos;^admin/&apos;, include(admin.site.urls)),# ]变量urlpatterns包含项目中的APP的URL，admin.site.urls模块定义了可在管理网站中请求的所有URL。现在添加代码：123456789from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&quot;&quot;, include(&quot;learning_logs.urls&quot;)), # 书中代码： # url(r&quot;&quot;, include(&quot;learning_logs.urls&quot;, namespace=&quot;learning_logs&quot;)),]注意：书中在此处的include()函数中传入了关键字参数namespace=”learning_logs”，但在新版中，命名空间(namespace)是在APP的urls.py中设置的：在urlpatterns变量前新建一个值为”learning_logs”的app_name变量。此处与我配置不同，我已经在urlpatterns变量前新建一个值为”learning_logs”的app_name变量。但是仍然会报错：无法找到namespace,于是把urlpatterns修改为： 1234urlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&quot;&quot;, include(&quot;learning_logs.urls&quot;,namespace = &apos;learning_logs&apos;)),#https://blog.csdn.net/mukvintt/article/details/80320027 还是添加了namesapce 参数，而learning_log/urls.py为： 123456789#learning_logs的URLfrom django.urls import pathfrom . import views#添加命名空间app_name = &apos;learing_logs&apos; #https://blog.csdn.net/qq_38504396/article/details/79687269urlpatterns = [ #主页 path(&quot;&quot;,views.index,name = &apos;index&apos;), 我的Django版本是2.1 ……………… 原文链接","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"项目","slug":"技术/项目","permalink":"http://puguojing.com/categories/技术/项目/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://puguojing.com/tags/Django/"},{"name":"Web框架","slug":"Web框架","permalink":"http://puguojing.com/tags/Web框架/"},{"name":"项目","slug":"项目","permalink":"http://puguojing.com/tags/项目/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"项目","slug":"技术/项目","permalink":"http://puguojing.com/categories/技术/项目/"}]},{"title":"python学习-闭包函数、装饰器","slug":"python学习-闭包函数、装饰器","date":"2018-08-20T06:02:50.000Z","updated":"2018-11-06T03:19:57.171Z","comments":true,"path":"2018/08/20/python学习-闭包函数、装饰器/","link":"","permalink":"http://puguojing.com/2018/08/20/python学习-闭包函数、装饰器/","excerpt":"","text":"&#8195;&#8195; 1.不定长变量不定长变量一般使用在参数不固定的情况下，常使用*kargs表示一系列单一值（比如元组、列表），使用**kwargs表示一系列键值对（比如字典） 123def fun_1(*kargs,**kwargs): print(kargs) print(kwargs) 可以使用： 1fun_1(1,2,3,row = 1,colume = 2) 123输出结果：(1, 2, 3)&#123;&apos;row&apos;: 1, &apos;colum&apos;: 2&#125; 或者像这样（其实更多的情况下我们会这样用）： 1234my_list = [1,2,3]my_dict = &#123;&apos;row&apos;:1,&apos;colume&apos;:2&#125;fun_1(my_list,my_dict) *kargs和**kwargs会自动把列表和字典进行拆分开来,进行传入参数。 2.闭包函数&#8195;&#8195;函数闭包是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。（维基百科）1234def fun(x,y): def close_fun(a): return x+y+a #可以使用x,y return close_fun #返回函数对象 12var= fun(1,2)#fun(1,2)返回的是一个close_fun函数对象var(3) #结果：6，相当于使用close_fun(3） 3.装饰器函数&#8195;&#8195;装饰器函数就是把被装饰的函数当做参数传入一个闭包函数中，使闭包函数中的内容先执行，然后在执行被装饰函数中的内容。 (1)被装饰的函数带参数1234567#装饰器函数def my_decorator(fun):#fun代表被装饰的函数 def close_fun(a,b):#内部函数的参数要和被装饰的函数fun的参数对应 a += 1 #在执行被装饰的函数之前，先对参数做处理 b += 1 return fun(a,b) #返回被装饰的函数的 &apos;调用&apos; return close_fun #返回闭包函数 &apos;对象&apos; 123@my_decoratordef fun_add(x,y):#被装饰的函数fun_add是带参数的 return x+y 12#调用fun_add(1,2)#结果是5 123456#调用过程#1.把fun_add当做参数传入装饰器 res_fun = my_decorator（fun_add）#2.由于my_decorator是一个闭包函数，返回的是一个colse_fun 函数对象，所以res_fun &lt;-等价与-&gt;close_fun#3.调用close_fun(a,b),对应的实参就是close_fun(1,2)#4.close_fun内部对参数进行 &apos;+= 1&apos;的处理 所以传入的实参 1，2 变成了 2，3#5.close_fun内部最后返回的是被装饰的函数fun_add调用，而此时参数已经变成了2，3，所以是fun_add(2,3),最终结果 return 2+3 为 5 (2)装饰器函数同时也带参数1234567891011121314151617#装饰器函数同时也带参数,只需要在外面再加一层嵌套即可def my_decorator_arg(arg_1,arg_2): def my_decorator(fun):#fun代表被装饰的函数 def close_fun(a,b):#内部函数的参数要和被装饰的函数fun的参数对应 # 在执行被装饰的函数之前，先对参数做处理,根据装饰器装饰器函数不同的参数，对被装饰的函数做不同的处理 if arg_1==&apos;yes&apos;:#如果装饰器函数的第一个参数是yes,就对被装饰的函数的第一个参数进行 +1处理 a += 1 elif arg_1==&apos;no&apos;:#如果装饰器函数的第一个参数是no,就对被装饰的函数的第一个参数进行 -1处理 a -= 1 if arg_2 == 0:#如果装饰器函数的第二个参数是0,就对被装饰的函数的第二个参数进行 +1处理 b += 1 elif arg_2 == 1:#如果装饰器函数的第二个参数是1,就对被装饰的函数的第二个参数进行 -1处理 b -= 1 return fun(a,b) #返回被装饰的函数的 &apos;调用&apos; return close_fun #返回闭包函数 &apos;对象&apos; return my_decorator #返回装饰器函数 &apos;对象&apos; 12345@my_decorator_arg(&apos;yes&apos;,0)def fun_add(x,y):#被装饰的函数fun_add是带参数的 return x+yr = fun_add(1,2)#结果是5 12345@my_decorator_arg(&apos;no&apos;,0)def fun_add(x,y):#被装饰的函数fun_add是带参数的 return x+yr = fun_add(1,2)#结果是3 (3)被装饰函数任意参数1234567891011121314def my_decorator(fun):#fun代表被装饰的函数 def close_fun(*args,**kwargs):#内部函数的参数不定参 a += 1 #在执行被装饰的函数之前，先对参数做处理 res = fun(*args,**kwargs)#&apos;调用&apos;被装饰的函数 return res * res #对结果再做处理 return close_fun #返回闭包函数 &apos;对象&apos;@my_decorator_argdef fun_add(x):#被装饰的函数fun_add参数不定 return x@my_decorator_argdef fun_add(x,y,k):#被装饰的函数fun_add参数不定 return x+y+k (4)多个装饰函数12345678910111213141516def my_decorator_1(fun):#第一个装饰器函数，求和 def close_fun(*args,**kwargs): print(&quot;my_decorator_1 args:&quot;,args) print(&quot;my_decorator_1 kwargs:&quot;,kwargs) res = fun(*args,**kwargs)#调用被装饰的函数 return res + res return close_fundef my_decorator_2(fun):##第二个装饰器函数，求平方 def close_fun(*args,**kwargs): print(&quot;my_decorator_2 args:&quot;, args) print(&quot;my_decorator_2 kwargs:&quot;, kwargs) res = fun(*args,**kwargs) return res * res return close_fun 12345678910111213141516@my_decorator_1@my_decorator_2def fun_add(x,y):#被装饰的函数fun_add是带参数的 print(&apos;fun_add:&apos;,x,y) return x+yr = fun_add(1,2)print(r)#输出结果：#my_decorator_1 args: (1, 2)#my_decorator_1 kwargs: &#123;&#125;#my_decorator_2 args: (1, 2)#my_decorator_2 kwargs: &#123;&#125;#fun_add: 1 2#18 1234顺序:先执行my_decorator_2，后执行顺序1中先执行my_decorator_1。用嵌套表示：my_decorator_1(my_decorator_2(fun_add))具体分析：1.my_decorator_1调用fun(1,2)得到res为3，然后return 3*3 = 92.然后调用my_decorator_2 来自my_decorator_1 中结果 是 9 然后return 9+9 得出18 12345678910111213141516@my_decorator_2@my_decorator_1def fun_add(x,y):#被装饰的函数fun_add是带参数的 print(&apos;fun_add:&apos;,x,y) return x+yr = fun_add(1,2)print(r)#输出结果：#mmy_decorator_2 args: (1, 2)#my_decorator_2 kwargs: &#123;&#125;#my_decorator_1 args: (1, 2)#my_decorator_1 kwargs: &#123;&#125;#fun_add: 1 2#36 1234顺序:先执行my_decorator_1，后执行顺序1中先执行my_decorator_2。用嵌套表示：my_decorator_2(my_decorator_1(fun_add))具体分析：1.my_decorator_2调用fun(1,2)得到res为3，然后return 3+3 = 62.然后调用my_decorator_1 来自my_decorator_1 中结果 是 6 然后return 6*6 得出36 多个装饰器装饰一个函数时，装饰器的顺序也很重要。执行时总是先执行离被装饰函数最近的装饰函数，由近及远。","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"闭包","slug":"闭包","permalink":"http://puguojing.com/tags/闭包/"},{"name":"装饰器","slug":"装饰器","permalink":"http://puguojing.com/tags/装饰器/"},{"name":"不定参数","slug":"不定参数","permalink":"http://puguojing.com/tags/不定参数/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}]},{"title":"Python学习笔记-面向对象","slug":"python学习-面向对象","date":"2018-07-22T06:35:42.000Z","updated":"2018-11-27T11:07:56.206Z","comments":true,"path":"2018/07/22/python学习-面向对象/","link":"","permalink":"http://puguojing.com/2018/07/22/python学习-面向对象/","excerpt":"","text":"&#8195;&#8195; 面向对象类：是我们抽象出来的属性的集合，是描述。实例：也叫做对象，是我们用类这个属性集合具体生成的实例。属性：定义在类中的方法或变量。实例属性：定义在具体方法中的属性（属性可以是方法也可以是变量），只用作当前的实例。类属性：类属性定义在类中且在函数体外，类属性被所有实例化的对象共有，类属性通常不作为实例属性使用。 类的变量属性比如定义类变量: 12Class A(): var_1 = 1 #类的变量属性，可以使用类名和实例名调用 其中var_1这个变量指的就是A这个类的变量，他可以通过类名调用（比如：A.var_1），也可以通过实例名调用（比如：a = A() a.Var_1）比如我们创建2个A类的实例： 12a1 = A()a2 = A() 我们可以使用实例名调用变量： 12a1.var_1 #值为1a2.var_1 #值为1 也可以使用类名调用变量： 1A.var_1 #值为1 如果单独修改a1.var_1或a2.var_1的值，则不会影响其他实例的var_1和类本身的var_1的值，但是如果修改A.var_1（类变量）的值，则所有的实例变量都会被改变。比如,如果把a.var_1的值修改为2，则b.var_1和A.var_1的值均不会改变，仍为1。但是如果把A.var_1的值修改为2则a.var_1和b.var_1的值都会变成2。 实例的变量属性123Class A(): def __init__(self) self.var_1 = 1 #实例的变量属性，只可以使用实例名调用 创建2个实例： 12a1 = A()a2 = A() 使用实例名调用变量： 12a1.var_1 值为1a2.var_1 值为1 使用类名调用变量： 1A.var_1 #不可以使用 类属性和实例属性名不能设置成一样1234567891011121314151617&gt;&gt;&gt; class Student(object):... name = &apos;Student&apos;...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student 从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。 实例的函数属性实例的函数属性一般函数的第一个参数是self,Pyhon会默认把函数的第一个参数当做指向类实例的参数，一般使用self，当然你也可以换成其他的名字，毕竟这个地方只是形参，但是一般从程序的可读性上而言我们不会那么做。 123Class A(): def func(self,a,b): print(a+b) 如果我们想要调用func,则需要先实例化A这个类，然后使用实例化出来的对象调用： 12a = A()a.fun(2,3) 但是这里我们可不可以使用类名调用这个func函数呢，比如使用A.func(2,3)行不行呢,这当然是不行的。 “self，这里的self可以理解为C++中的this指针。遵循的原则就是：哪个实例调用我这个含有self的函数或变量，我这个函数或变量的self就代表哪个实例（指向哪个实例）。总结一句话：“谁调用就指向谁” 类方法类方法顾名思义就是指类的方法，而不是实例的方法，下面我们来看2个例子： 123Class A(): def func(a,b): print(a+b) 我们注意到这里的func没有使用self这个参数，那如果我们使用a.fun(2,3)这种调用会怎么样呢？答案是会报参数出错，因为在使用实例调用一个函数的时候，第一个参数会被默认是self，然而我们这里并没有定义这个参数。这里我们可以通过类名来调用这个参数A.func(2,3),这样会成功。这里我们好像就是要使用类名调用函数了，看起来像是类的方法，但是通常我们不会这样做，而是采用@clasmethod装饰器的方法来定义类方法： 1234Class A(): @classmethod def func(cls,a,b): print(a+b) 首先我们可以使用实例对象调用这个方法： 12a = A()a.func(2,3) 也可以使用类名来调用这个方法： 1A.func(2,3) 这里的方法默认会有一个cls的参数，用来表示当前的类（注意不是实例）。 如果想在类的方法里面调用类的变量，可以使用cls: 1234567class A(): num = 1 @classmethod def func(cls): cls.num += 1#使用cls.num，而不能直接使用num print(&apos;cls.num:&apos;,cls.num) 注意不管是使用类名调用类方法还是使用实例调用类方法所产生的结果都会相应影响： 12345678a = A()print(&apos;A.num:&apos;,A.num)a.func()print(&apos;A.num:&apos;,A.num)A.func()print(&apos;A.num:&apos;,A.num) 输出的结果： 12345A.num: 1cls.num: 2A.num: 2cls.num: 3A.num: 3 而且类方法中不能调用实例变量属性，比如： 123456789class A(): def __init__(self): self.var = 0 @classmethod def func(cls): cls.var += 1 print(cls.var) 会报错:AttributeError: type object &#39;A&#39; has no attribute &#39;var&#39; 静态方法定义静态方法使用@staticmethod，可以使用类名调用。静态方法不需要默认的任何参数,跟一般的普通函数类似.通过这样的定义方式，我们可以在多个实例之间共享这个函数中的数据和内容。静态方法无法访问实例变量。 类方法于静态方法： 1.类方法需要传递cls参数，静态方法不需要；2.静态方法和类方法都不可以访问实例变量；3.类方法可以通过cs访问类变量，静态方法不可以。 12345678class A(): num = 1 @staticmethod def func():#func中无法使用num a = 1 print(&apos;&apos;,a) 可以使用实例和类名调用： 12a = A()A.func() 继承继承分为单继承和多继承。单继承：子类只能继承一个父类。多继承：子类继承多个父类。 单继承：12class A1(A): pass 可以使用A1.__base__查看A1的基类 1234class A1(A): def __init__(self): self.var = 1 print(self.var) A1是A的子类，如果A1中没有init（self）函数，默认会调用父类的init(self),如果子类重写了init(self),则不会调用父类的init_(self)。 多继承：定义两个基类： 12345678class A(): def __init__(self): print(&apos;this is A&apos;)class B(): def __init__(self): print(&apos;this is B&apos;) 定义一个子类C： 12class C(A,B):#注意继承顺序 pass 实例化C这个类： 1c = C() 输出是： 1this is B 说明调用的是B的init(self) 如果定义C这个类 12class C(B,A): pass 实例化C这个类输出是： 1this is A 说明调用的是A的init(self) Python 多继承调用父类的顺序：python调用父类构造的顺序是:从左往右，从下往上。采用的是广度优先搜索算法，总会先找离自己最近的一个节点。具体方法是:首先访问i这个节点，然后访问i所有未被访问的相邻节点。 如图，访问顺序是：9-&gt;7-&gt;8-&gt;3-&gt;4-&gt;5-&gt;6-&gt;1-&gt;2 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/python3# -*- coding:utf-8 -*-class A(object): def __init__(self): print(&apos;A&apos;) super(A, self).__init__()class B(object): def __init__(self): print(&apos;B&apos;) super(B, self).__init__()class C(A): def __init__(self): print(&apos;C&apos;) super(C, self).__init__()class D(A): def __init__(self): print(&apos;D&apos;) super(D, self).__init__()class E(B,C): def __init__(self): print(&apos;E&apos;) super(E, self).__init__()class F(C,B,D): def __init__(self): print(&apos;F&apos;) super(F, self).__init__()class G(D,B): def __init__(self): print(&apos;G&apos;) super(G, self).__init__()if __name__ == &apos;__main__&apos;: g = G() print(G.mro()) f = F() print(F.mro()) 输出结果： 1234567891011GDAB[&lt;class &apos;__main__.G&apos;&gt;, &lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;object&apos;&gt;]FCBDA[&lt;class &apos;__main__.F&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;object&apos;&gt;] 1.如果每个类都有正确的写super(X, self).init()，那么mro顺序的所有的类的初始化方法都会执行一遍2.如果中途有的类没有写或错误的写了super(X, self).init()，那么会按mro顺序执行到执行完没写的那个类，执行结束。3.super(X, self)不是必须点init()，可以点别的，但一般没有这么做的4.类名.mro可以得到mro的顺序5.这种写法可以实现每个类都被执行有且仅有一次。 静态语言VS动态语言的继承对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了： 123class Timer(object): def run(self): print(&apos;Start...&apos;) 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。 继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。 动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的 获取对象的信息当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？ 用dir()如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法： 12&gt;&gt;&gt; dir(&apos;ABC&apos;)[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;] 类似xxx的属性和方法在Python中都是有特殊用途的，比如len方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的len()方法，所以，下面的代码是等价的： 1234&gt;&gt;&gt; len(&apos;ABC&apos;)3&gt;&gt;&gt; &apos;ABC&apos;.__len__()3 我们自己写的类，如果也想用len(myObj)的话，就自己写一个len()方法： 1234567&gt;&gt;&gt; class MyDog(object):... def __len__(self):... return 100...&gt;&gt;&gt; dog = MyDog()&gt;&gt;&gt; len(dog)100 剩下的都是普通属性或方法，比如lower()返回小写的字符串： 12&gt;&gt;&gt; &apos;ABC&apos;.lower()&apos;abc&apos; getattr()、setattr()以及hasattr()仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态： 1234567&gt;&gt;&gt; class MyObject(object):... def __init__(self):... self.x = 9... def power(self):... return self.x * self.x...&gt;&gt;&gt; obj = MyObject() 紧接着，可以测试该对象的属性： 12345678910111213&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？False&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？True&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;19&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;19 如果试图获取不存在的属性，会抛出AttributeError的错误： 1234&gt;&gt;&gt; getattr(obj, &apos;z&apos;) # 获取属性&apos;z&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;MyObject&apos; object has no attribute &apos;z&apos; 可以传入一个default参数，如果属性不存在，就返回默认值： 12&gt;&gt;&gt; getattr(obj, &apos;z&apos;, 404) # 获取属性&apos;z&apos;，如果不存在，返回默认值404404 也可以获得对象的方法： 123456789&gt;&gt;&gt; hasattr(obj, &apos;power&apos;) # 有属性&apos;power&apos;吗？True&gt;&gt;&gt; getattr(obj, &apos;power&apos;) # 获取属性&apos;power&apos;&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, &apos;power&apos;) # 获取属性&apos;power&apos;并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81 使用slots如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。 为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的slots变量，来限制该class实例能添加的属性： 12class Student(object): __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称 然后，我们试试： 1234567&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos; 由于’score’没有被放到slots中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。 使用slots要注意，slots定义的属性仅对当前类实例起作用，对继承的子类是不起作用的： 12345&gt;&gt;&gt; class GraduateStudent(Student):... pass...&gt;&gt;&gt; g = GraduateStudent()&gt;&gt;&gt; g.score = 9999 除非在子类中也定义slots，这样，子类实例允许定义的属性就是自身的slots加上父类的slots。 使用@property在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改： 12s = Student()s.score = 9999 这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数： 1234567891011class Student(object): def get_score(self): return self._score def set_score(self, value): if not isinstance(value, int): raise ValueError(&apos;score must be an integer!&apos;) if value &lt; 0 or value &gt; 100: raise ValueError(&apos;score must between 0 ~ 100!&apos;) self._score = value 现在，对任意的Student实例进行操作，就不能随心所欲地设置score了： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.set_score(60) # ok!&gt;&gt;&gt; s.get_score()60&gt;&gt;&gt; s.set_score(9999)Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。 有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！ 还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的： 12345678910111213class Student(object): @property def score(self):#变成属性调用读取属性 return self._score @score.setter def score(self, value):#设置属性,使用：@方法名.setter if not isinstance(value, int): raise ValueError(&apos;score must be an integer!&apos;) if value &lt; 0 or value &gt; 100: raise ValueError(&apos;score must between 0 ~ 100!&apos;) self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性： 12345678910111213class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth 上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。 小结@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 枚举类12345678from enum import Enum#获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员Month = Enum(&apos;Month&apos;,(&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))#for name, member in Month.__members__.items(): print(name, member, member.value) 输出: 123456789101112Jan Month.Jan 1Feb Month.Feb 2Mar Month.Mar 3Apr Month.Apr 4May Month.May 5Jun Month.Jun 6Jul Month.Jul 7Aug Month.Aug 8Sep Month.Sep 9Oct Month.Oct 10Nov Month.Nov 11Dec Month.Dec 12 如果想自己控制枚举的值，可以是使用派生类，继承Enum: 1234567891011121314151617181920from enum import Enum,unique#自定义控制枚举数值，使用派生类，继承Enum@uniqueclass WeekDay(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6#有多种方法可以访问枚举print(WeekDay.Sun)#WeekDay.Sunprint(WeekDay.Tue.value)#2print(WeekDay[&apos;Wed&apos;])#WeekDay.Wedprint(WeekDay(0))#WeekDay.Sunfor name, member in WeekDay.__members__.items(): print(name, member, member.value) 输出结果: 1234567891011WeekDay.Sun2WeekDay.WedWeekDay.SunSun WeekDay.Sun 0Mon WeekDay.Mon 1Tue WeekDay.Tue 2Wed WeekDay.Wed 3Thu WeekDay.Thu 4Fri WeekDay.Fri 5Sat WeekDay.Sat 6 元类参考[廖雪峰Python教程]","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"面向对象","slug":"面向对象","permalink":"http://puguojing.com/tags/面向对象/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}]},{"title":"Python学习笔记-正则表达式（1）","slug":" Python学习笔记-正则表达式（1）","date":"2018-07-20T10:53:48.000Z","updated":"2018-11-06T04:31:11.575Z","comments":true,"path":"2018/07/20/ Python学习笔记-正则表达式（1）/","link":"","permalink":"http://puguojing.com/2018/07/20/ Python学习笔记-正则表达式（1）/","excerpt":"","text":"&#8195;&#8195; 正则表达式1.常用正则表达式符号和语法1、’.’ 匹配所有字符串，除\\n以外2、‘-’ 表示范围[0-9]3、’*‘ 匹配前面的子表达式零次或多次。要匹配 字符，请使用 \\\\。4、’+’ 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +5、’\\^’ 匹配字符串开头6、‘$’ 匹配字符串结尾 re7、’\\’ 转义字符， 使后一个字符改变原来的意思，如果字符串中有字符 ‘ * ‘ 需要匹配，可以使用’ \\* ‘或者字符集[ *] , re.findall(r’3*‘,’3*ds’)结果[‘3‘]8、’\\‘ 匹配前面的字符0次或多次re.findall(“ab*“,”cabc3abcbbac”)结果：[‘ab’, ‘ab’, ‘a’]9、‘?’ 匹配前一个字符串0次或1次 re.findall(‘ab?’,’abcabcabcadf’)结果[‘ab’, ‘ab’, ‘ab’, ‘a’]10、’{m}’ 匹配前一个字符m次 re.findall(‘cb{1}’,’bchbchcbfbcbb’)结果[‘cb’, ‘cb’]11、’{n,m}’ 匹配前一个字符n到m次 re.findall(‘cb{2,3}’,’bchbchcbfbcbb’)结果[‘cbb’]12、’\\d’ 匹配数字，等于[0-9] re.findall(‘\\d’,’电话:10086’)结果[‘1’, ‘0’, ‘0’, ‘8’, ‘6’]13、’\\D’ 匹配非数字，等于[^0-9] re.findall(‘\\D’,’电话:10086’)结果[‘电’, ‘话’, ‘:’]14、’\\w’ 匹配字母和数字，等于[A-Za-z0-9] re.findall(‘\\w’,’alex123,./;;;’)结果[‘a’, ‘l’, ‘e’, ‘x’, ‘1’, ‘2’, ‘3’]15、’\\W’ 匹配非英文字母和数字,等于[^A-Za-z0-9] re.findall(‘\\W’,’alex123,./;;;’)结果[‘,’, ‘.’, ‘/‘, ‘;’, ‘;’, ‘;’]16、’\\s’ 匹配空白字符 re.findall(‘\\s’,’3*ds \\t\\n’)结果[‘ ‘, ‘\\t’, ‘\\n’]17、’\\S’ 匹配非空白字符 re.findall(‘\\s’,’3*ds \\t\\n’)结果[‘3’, ‘*‘, ‘d’, ‘s’]18、’\\A’ 匹配字符串开头19、’\\Z’ 匹配字符串结尾20、’\\b’ 匹配单词的词首和词尾，单词被定义为一个字母数字序列，因此词尾是用空白符或非字母数字符来表示的21、’\\B’ 与\\b相反，只在当前位置不在单词边界时匹配22、’( ?P\\&lt;name>… )’ 分组，除了原有编号外再指定一个额外的别名。 re.search(“(?P\\[0-9]{4})(?P\\[0-9]{2})(?P\\&lt;birthday>[0-9{8})”,”371481199306143242”).groupdict(“city”) 结果{‘province’: ‘3714’, ‘city’: ‘81’, ‘birthday’: ‘19930614’}23、[ ] 是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示相应位置的字符要匹配英文字符和数字。[\\s*]表示空格或者*号。 2.常用的re函数re.match(pattern,string,flags=0)&#8195;&#8195;从字符串的起始位置匹配，如果起始位置匹配不成功的话，match()就返回none re.search(pattern,string,flags=0)&#8195;&#8195;扫描整个字符串并返回第一个成功的匹配 re.findall(pattern,string,flags=0)&#8195;&#8195;找到RE匹配的所有字符串，并把他们作为一个列表返回 re.finditer(pattern, string, flags=0)&#8195;&#8195;找到RE匹配的所有字符串，并把他们作为一个迭代器返回 re.sub(pattern, repl, string, count=0, flags=0)#8195;&#8195;替换匹配到的字符串 re.subn(pattern, repl, string, count=0, flags=0)#8195;&#8195;替换匹配到的字符串,并返回替换数量 未完待续…","categories":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://puguojing.com/tags/正则表达式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://puguojing.com/categories/技术/"},{"name":"python","slug":"技术/python","permalink":"http://puguojing.com/categories/技术/python/"}]}]}