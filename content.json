{"meta":{"title":"心小天个人博客","subtitle":"生活不止coding,还有诗和远方。","description":"生活不止coding,还有诗和远方。","author":"心小天","url":"http://puguojing.com"},"pages":[{"title":"tags","date":"2018-11-05T07:48:59.000Z","updated":"2018-11-05T07:53:12.387Z","comments":true,"path":"tags/index.html","permalink":"http://puguojing.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-05T07:54:52.000Z","updated":"2018-11-05T07:55:16.783Z","comments":true,"path":"categories/index.html","permalink":"http://puguojing.com/categories/index.html","excerpt":"","text":""},{"title":"python","date":"2018-11-05T15:52:32.000Z","updated":"2018-11-05T15:56:14.070Z","comments":true,"path":"python/index.html","permalink":"http://puguojing.com/python/index.html","excerpt":"","text":"1.进程&#8195;&#8195;计算机程序知识存储在磁盘上的可执行二进制（或其他类型）文件，只有把他们加载到内存中并被操作系统调用，才拥有生命周期，进程是一个执行中的程序，每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪的辅助数据。由于进程之间相互独立，所以只能采用进程间通信(IPC)的方式共享信息。"},{"title":"about","date":"2018-11-05T08:08:55.000Z","updated":"2018-11-05T08:08:55.344Z","comments":true,"path":"about/index.html","permalink":"http://puguojing.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac下Redis数据的安装、操作、配置","slug":"Redis数据的安装、操作、配置","date":"2018-10-16T07:49:56.000Z","updated":"2018-11-05T13:59:37.544Z","comments":true,"path":"2018/10/16/Redis数据的安装、操作、配置/","link":"","permalink":"http://puguojing.com/2018/10/16/Redis数据的安装、操作、配置/","excerpt":"","text":"1.安装使用brew安装 1brew install redis 完成后会自动安装redis-server和redis-cli。 redis安装后，默认会自动启动，可以通过以下PS进程命令查看： 1ps aux|grep redis 执行结果： 1234➜ ~ ps aux|grep redispgj 17677 0.0 0.0 4287208 1064 s001 S+ 3:54下午 0:00.01 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn redispgj 17616 0.0 0.0 4295500 1160 s003 S+ 3:44下午 0:00.02 redis-cli -h 127.0.0.1 -p 6379 -a foobaredpgj 17555 0.0 0.0 4309276 2312 s002 S+ 3:40下午 0:00.62 redis-server 127.0.0.1:6379 可以看到进程PID为17555的就是redis-server,可以使用： 1kill 17555 关闭Redis服务（不建议使用，强制杀死进程，可能导致Redis部分缓存丢失）。 手动启动：Redis安装完成后会生成/usr/local/etc/redis.conf文件，执行启动命令： 1redis-server /usr/local/etc/redis.conf 会显示： 123456789101112131415161718192021➜ ~ redis-server /usr/local/etc/redis.conf17555:C 16 Oct 15:40:34.312 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo17555:C 16 Oct 15:40:34.313 # Redis version=4.0.4, bits=64, commit=00000000, modified=0, pid=17555, just started17555:C 16 Oct 15:40:34.313 # Configuration loaded17555:M 16 Oct 15:40:34.316 * Increased maximum number of open files to 10032 (it was originally set to 4864). _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 4.0.4 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 17555 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | http://redis.io `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; 说明启动成功。 客户端连接1redis-cli -h [ip] -p [端口] -h:指定IP-p:指定端口号（默认6379，可在redis.conf中修改） 1redis-cli -h 127.0.0.1 -p 6379 ###配置配置文件具体在：/usr/local/etc/redis.conf 1.添加密码在配置文件中找到： 1234# use a very strong password otherwise it will be very easy to break.## requirepass foobared# 其中requirepass后面的字符，就是Redis数据库密码,默认时注释掉的。如果此处指定了密码，那么以后使用redis-cli链接redis数据库的时候就要使用密码，否则连接Redis数据库之后,无法进行Redis数据库操作。比如指定密码为：123456 1234# use a very strong password otherwise it will be very easy to break.#requirepass 123456# 那么以后使用redis-cli连接数据库的时候就要用-a指定密码下面的命令: 1redis-cli -h 127.0.0.1 -p 6379 -a 123456 如果你在连接redis数据库是没有使用-a指定密码，也可以在redis-cli命令行中使用：auth password指定密码： 12127.0.0.1:6379&gt; auth 123456OK 2.让其其他的电脑访问可以redis在配置文件中找打bind,默认IP只有127.0.0.1： 1bind 127.0.0.1 ::1 在127.0.0.1后面加上自己电脑的（redis-server所在的电脑）的IP。 1bind 127.0.0.1 198.168.1.102 注意：添加不是Redis客户端的IP，是redis-server端的IP。这样别的客户端就可以使用： 1redis-cli -h 198.168.1.102 6379 来连接redis数据库了","categories":[],"tags":[],"keywords":[]},{"title":"memcached的调试使用","slug":"memcached的调试使用","date":"2018-10-12T13:07:03.000Z","updated":"2018-11-05T13:59:37.548Z","comments":true,"path":"2018/10/12/memcached的调试使用/","link":"","permalink":"http://puguojing.com/2018/10/12/memcached的调试使用/","excerpt":"","text":"Mac memcached的调试1.安装：1brew install memcached 2.启动：1memcached -d -p 11211 -u nobody -c 1024 -m 64 1234567-d：这个参数是让memcached在后台运行（启动一个守护进程）。-m：指定占用多少内存。以M为单位，默认为64M。-u是运行Memcache的用户，我这里是nobody-p：设置Memcache监听的端口,最好是1024以上的端口，默认端口是11211。-l：别的机器可以通过哪个ip地址连接到我这台服务器。如果是通过service memcached start的方式，那么只能通过本机连接。如果想要让别的机器连接，就必须设置-l 0.0.0.0。-c选项是最大运行的并发连接数，默认是1024，按照你服务器的负载量来设定 3.Telnet连接1telnet 127.0.0.1 11211 telnet操作memcached:memcached的数据是以 key:value 方式存储在内存中，所以我们一般对key 进行操作，而value保存实际的值。 1.set：添加或更新数据：123456语法： set key flas(是否压缩) timeout(存储的时间,0代表一直存储) value_length(value的长度) value示例： set username 0 60 7 zhiliao 注意指定的value长度和实际输入value的长度必须一致，否则按Enter键后会出现ERROR(如果实际的value长度大于指定的长度)或者一直等到你输入完指定的字符数。 2.add：添加数据123456语法： add key flas(是否压缩) timeout(存储的时间,0代表一直存储) value_length(value的长度) value示例： add username 0 60 7 xiaotuo set和add的区别：add是只负责添加数据，不会去修改数据。如果添加的数据的key已经存在了，则添加失败，如果添加的key不存在，则添加成功。而set不同，如果memcached中不存在相同的key，则进行添加，如果存在，则替换。 set、add执行成功后会显示：STORED，未执行成功会显示：NOT STORED 3.get：获取数据1234语法： get key示例： get username 4.delete:删除数据1234语法： delete key示例： delete username 5.flush_all：删除memcached中的所有数据。6.incr:给memcached中数字类型的值进行相加操作，相加的项必须也是数字类型。123456语法： incr key num(num表示要加的值，必须是数字)示例： incr age 2 给key是age的值加上2 7.decr:给memcached中数字类型的值进行减操作，相减的项必须也是数字类型。12345语法： decr key num(num表示要减的值，必须是数字)示例： devr age 2 给key是age的值减去2 8.stats：查看memcached的当前状态，可以查看自己的操作记录和正确执行数据，以分析memcached的命中率（正确率）12示例： stats 结果： 123456789101112STAT pid 5286STAT uptime 3741STAT time 1539349048STAT version 1.5.3...STAT cmd_get 9 #表示进行实际get的次数STAT cmd_set 16 #表示进行实际get的次数STAT cmd_flush 1STAT cmd_touch 0STAT get_hits 7 #表示get命中(有效)的次数...END 常见的：STAT cmd_get 9 表示进行实际get的次数STAT cmd_set 16 表示进行实际set的次数STAT get_hits 7 表示get命中(有效)的次数STAT curr_items 4 表示当前有多少条数据 stats之后会显示很多结果常用的就是查看set、get等操作的cmd_get/set 数量和 get_hits 数量 用类似: get_hits/cmd_get 的结果反映当前memcached的状态，如果命中率良好，说明memcached的状态良好，反之说明memcached的状态较差，比如可能碎片较多。","categories":[],"tags":[],"keywords":[]},{"title":"sql语句中left join、right join 以及innerjoin之间的使用与区别","slug":"Mysql中的内联接、左外联接、右外联接","date":"2018-10-08T06:29:15.000Z","updated":"2018-11-05T13:59:37.536Z","comments":true,"path":"2018/10/08/Mysql中的内联接、左外联接、右外联接/","link":"","permalink":"http://puguojing.com/2018/10/08/Mysql中的内联接、左外联接、右外联接/","excerpt":"","text":"sql语句中left join、right join 以及innerjoin之间的使用与区别left [outer] join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录right [outer] join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录inner join(等值连接) 只返回两个表中联结字段相等的行 左联接和右联接统称为外联接，其中的outer关键字可以省略。 左连接和右连接的区别在于以哪个表为主（主表中的数据都会出现在表中） 举例如下： 表A记录如下：aID aNum1 a200501112 a200501123 a200501134 a200501145 a20050115 表B记录如下:bID bName1 20060324012 20060324023 20060324034 20060324048 2006032408 1.left joinsql语句如下:select * from Aleft join Bon A.aID = B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 20060324045 a20050115 NULL NULL （所影响的行数为 5 行）结果说明:left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID). B表记录不足的地方均为NULL.2.right joinsql语句如下:select * from Aright join Bon A.aID = B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404NULL NULL 8 2006032408 （所影响的行数为 5 行）结果说明: 仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.3.inner joinsql语句如下:select * from Ainnerjoin Bon A.aID = B.bID 结果如下:aID aNum bID bName1 a20050111 1 20060324012 a20050112 2 20060324023 a20050113 3 20060324034 a20050114 4 2006032404 结果说明: 很明显,这里只显示出了 A.aID = B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.注:LEFT JOIN操作用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，即使在第二个（右边）表中并没有相符值的记录。 语法：FROM table1 LEFT JOIN table2 ON table1.field1 compopr table2.field2 说明：table1, table2参数用于指定要将记录组合的表的名称。field1, field2参数指定被联接的字段的名称。且这些字段必须有相同的数据类型及包含相同类型的数据，但它们不需要有相同的名称。compopr参数指定关系比较运算符：”=”， “&lt;”， “&gt;”， “&lt;=”， “&gt;=” 或 “&lt;&gt;”。如果在INNER JOIN操作中要联接包含Memo 数据类型或 OLE Object 数据类型数据的字段，将会发生错误.","categories":[],"tags":[],"keywords":[]},{"title":"pycharm连接mysql数据库","slug":"pycharm连接mysql数据库","date":"2018-10-07T10:08:57.000Z","updated":"2018-11-05T13:59:37.549Z","comments":true,"path":"2018/10/07/pycharm连接mysql数据库/","link":"","permalink":"http://puguojing.com/2018/10/07/pycharm连接mysql数据库/","excerpt":"","text":"1.首先选择添加mysql数据库。 2.填入对应的额mysql配置信息（其中数据库orm_lookup_demo应该事先被创建好） 此时可以点击“Test Connections”测试是否连接成功，如果连接成功会出现:”succesfully”提示。如果“Test Connections”按钮无法点击，说明没有安装对应的mysql java驱动（因为pyhcarm使用java语言编写）。可以按下面的步骤快速安装：（1）.点击“Test Connections”按钮下面的Mysql 跳转到 Driver配置界面。（2）.点击下面途中的连接下载安装。（3）.重新回到数据库连接界面发现可以执行“Test Connections”。","categories":[],"tags":[],"keywords":[]},{"title":"Mysql中的外键","slug":"Mysql中的外键","date":"2018-10-06T08:54:06.000Z","updated":"2018-11-05T13:59:37.539Z","comments":true,"path":"2018/10/06/Mysql中的外键/","link":"","permalink":"http://puguojing.com/2018/10/06/Mysql中的外键/","excerpt":"","text":"mysql中的外键foreign key一、如果一张表中有一个非主键的字段指向了别一张表中的主键，就将该字段叫做外键。 一张表中可以有多个外键。 外键的默认作用有两点： 1.对子表(外键所在的表)的作用：子表在进行写操作的时候，如果外键字段在父表中找不到对应的匹配，操作就会失败。 2.对父表的作用：对父表的主键字段进行删和改时，如果对应的主键在子表中被引用，操作就会失败。 外键的定制作用—-三种约束模式： district：严格模式(默认), 父表不能删除或更新一个被子表引用的记录。 cascade：级联模式, 父表操作后，子表关联的数据也跟着一起操作。 set null：置空模式,前提外键字段允许为NLL, 父表操作后，子表对应的字段被置空。 使用外键的前提： 1. 表储存引擎必须是innodb，否则创建的外键无约束效果。 2. 外键的列类型必须与父表的主键类型完全一致。 3. 外键的名字不能重复。 4. 已经存在数据的字段被设为外键时，必须保证字段中的数据与父表的主键数据对应起来。 二、新增外键 在创建时增加 1234567891011create table my_tab1( id int primary key auto_increment, name varchar(10) not null, class int, foreign key(class) references my_tab2(主键字段名); )charset utf8; 在创建好的表中增加 1alter table my_tab1 add [constraint 外键名] foreign key(外键字段名) references mytab2(主键字段名); 三、删除外键1alter table my_tab drop foreign key 外键名字;","categories":[],"tags":[],"keywords":[]},{"title":"python3 与 Django 连接数据库Error loading MySQLdb module解决方案","slug":"python3 与 Django 连接数据库Error loading MySQLdb module解决方案","date":"2018-09-30T09:11:41.000Z","updated":"2018-11-05T13:59:37.552Z","comments":true,"path":"2018/09/30/python3 与 Django 连接数据库Error loading MySQLdb module解决方案/","link":"","permalink":"http://puguojing.com/2018/09/30/python3 与 Django 连接数据库Error loading MySQLdb module解决方案/","excerpt":"","text":"学习django时候，采用MySQL作为后台数据库，在执行python3 manage.py startapp appname创建app时遇到如下问题: 12django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module.Did you install mysqlclient? 完整报错如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Traceback (most recent call last): File &quot;/usr/local/lib/python3.6/site-packages/django/db/backends/mysql/base.py&quot;, line 15, in &lt;module&gt; import MySQLdb as DatabaseModuleNotFoundError: No module named &apos;MySQLdb&apos;The above exception was the direct cause of the following exception:Traceback (most recent call last): File &quot;manage.py&quot;, line 15, in &lt;module&gt; execute_from_command_line(sys.argv) File &quot;/usr/local/lib/python3.6/site-packages/django/core/management/__init__.py&quot;, line 381, in execute_from_command_line utility.execute() File &quot;/usr/local/lib/python3.6/site-packages/django/core/management/__init__.py&quot;, line 357, in execute django.setup() File &quot;/usr/local/lib/python3.6/site-packages/django/__init__.py&quot;, line 24, in setup apps.populate(settings.INSTALLED_APPS) File &quot;/usr/local/lib/python3.6/site-packages/django/apps/registry.py&quot;, line 112, in populate app_config.import_models() File &quot;/usr/local/lib/python3.6/site-packages/django/apps/config.py&quot;, line 198, in import_models self.models_module = import_module(models_module_name) File &quot;/usr/local/Cellar/python3/3.6.3/Frameworks/Python.framework/Versions/3.6/lib/python3.6/importlib/__init__.py&quot;, line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 994, in _gcd_import File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 971, in _find_and_load File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 955, in _find_and_load_unlocked File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 665, in _load_unlocked File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 678, in exec_module File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed File &quot;/usr/local/lib/python3.6/site-packages/django/contrib/auth/models.py&quot;, line 2, in &lt;module&gt; from django.contrib.auth.base_user import AbstractBaseUser, BaseUserManager File &quot;/usr/local/lib/python3.6/site-packages/django/contrib/auth/base_user.py&quot;, line 47, in &lt;module&gt; class AbstractBaseUser(models.Model): File &quot;/usr/local/lib/python3.6/site-packages/django/db/models/base.py&quot;, line 101, in __new__ new_class.add_to_class(&apos;_meta&apos;, Options(meta, app_label)) File &quot;/usr/local/lib/python3.6/site-packages/django/db/models/base.py&quot;, line 304, in add_to_class value.contribute_to_class(cls, name) File &quot;/usr/local/lib/python3.6/site-packages/django/db/models/options.py&quot;, line 203, in contribute_to_class self.db_table = truncate_name(self.db_table, connection.ops.max_name_length()) File &quot;/usr/local/lib/python3.6/site-packages/django/db/__init__.py&quot;, line 33, in __getattr__ return getattr(connections[DEFAULT_DB_ALIAS], item) File &quot;/usr/local/lib/python3.6/site-packages/django/db/utils.py&quot;, line 202, in __getitem__ backend = load_backend(db[&apos;ENGINE&apos;]) File &quot;/usr/local/lib/python3.6/site-packages/django/db/utils.py&quot;, line 110, in load_backend return import_module(&apos;%s.base&apos; % backend_name) File &quot;/usr/local/Cellar/python3/3.6.3/Frameworks/Python.framework/Versions/3.6/lib/python3.6/importlib/__init__.py&quot;, line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) File &quot;/usr/local/lib/python3.6/site-packages/django/db/backends/mysql/base.py&quot;, line 20, in &lt;module&gt; ) from errdjango.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module.Did you install mysqlclient? 原因分析：在 python2 中，使用 pip install mysql-python 进行安装连接MySQL的库，使用时 import MySQLdb 进行使用 在 python3 中，改变了连接库，改为了 pymysql 库，但是在 Django 中， 连接数据库时使用的是 MySQLdb 库，这在与 python3 的合作中就会报以下错误了： 1django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module: No module named &apos;MySQLdb&apos; 使用pip install pymysql 进行安装，直接导入即可使用。 1. 安装pymsql1pip install pymysql 2. 安装完毕，打开项目的init.py,添加代码12import pymysql pymysql.install_as_MySQLdb() 重新执行python3 manage.py startapp appname创建app成功。","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}],"tags":[{"name":"Djiango","slug":"Djiango","permalink":"http://puguojing.com/tags/Djiango/"},{"name":"Python3","slug":"Python3","permalink":"http://puguojing.com/tags/Python3/"},{"name":"mysql","slug":"mysql","permalink":"http://puguojing.com/tags/mysql/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}]},{"title":"Django学习笔记（1）","slug":"Django学习笔记（1）","date":"2018-09-29T07:49:35.000Z","updated":"2018-11-05T16:18:53.470Z","comments":true,"path":"2018/09/29/Django学习笔记（1）/","link":"","permalink":"http://puguojing.com/2018/09/29/Django学习笔记（1）/","excerpt":"","text":"创建Django项目1.使用命令：1django-admin startproject [项目名]","categories":[{"name":"Web框架","slug":"Web框架","permalink":"http://puguojing.com/categories/Web框架/"},{"name":"Django","slug":"Web框架/Django","permalink":"http://puguojing.com/categories/Web框架/Django/"}],"tags":[{"name":"Web框架","slug":"Web框架","permalink":"http://puguojing.com/tags/Web框架/"},{"name":"Django","slug":"Django","permalink":"http://puguojing.com/tags/Django/"}],"keywords":[{"name":"Web框架","slug":"Web框架","permalink":"http://puguojing.com/categories/Web框架/"},{"name":"Django","slug":"Web框架/Django","permalink":"http://puguojing.com/categories/Web框架/Django/"}]},{"title":"virtualenv和virtualenvwrapper的使用","slug":"virtualenv和virtualenvwrapper的使用","date":"2018-09-29T06:11:44.000Z","updated":"2018-11-05T16:18:10.053Z","comments":true,"path":"2018/09/29/virtualenv和virtualenvwrapper的使用/","link":"","permalink":"http://puguojing.com/2018/09/29/virtualenv和virtualenvwrapper的使用/","excerpt":"","text":"1.virtualenv虚拟环境的使用1.安装虚拟环境：1pip install virtualenv 2.创建虚拟环境1virtualenv [虚拟环境的名称] 会在当前路径中创建虚拟环境文件夹 3.进入虚拟环境12Windows:cd 到Script文件夹Linux/Mac： source path/虚拟环境/bin/activate 4.退出虚拟环境1deactivate 5.创建虚拟环境的时候指定Python解释器：当电脑有多个Python版本时，可以使用 -p 参数来指定Python解释器： 1virtualenv -p [Python解释器路径] 建议使用 virtualenvwrapper使用virtualenv时每一次创建虚拟环境都会在当前目录下创建一个虚拟环境文件夹，如果创建太多会很混乱，使用virtualenvwrapper只会下用户文件夹下创建一个Env文件夹，所有的虚拟环境都放在这个Env里面，所以非常易于维护。 1.安装1pip install virtualenvwrapper 进行下面步骤配置：1.创建目录用来存放虚拟环境 1mkdir $HOME/.virtualenvs 2.在~/.bash_profile中添加行： 123456#声明虚拟环境的文件夹export WORKON_HOME=$HOME/.virtualenvs#声明虚拟环境使用的python版本（多pyhton版本情况，请填写自己的python版本解释器路径）export VIRTUALENVWRAPPER_PYTHON=/usr/bin/local/python3.6 #执行虚拟环境脚本生效source /usr/local/bin/virtualenvwrapper.sh 3.运行以下命令使修改生效: 1source ~/.bash_profile 执行： 1➜~ virtualenvwrapper 如果提示：not found command或者/usr/bin/python: No module named virtualenvwrapper，说明未在正确的版本上安装virtualenv。 1.创建虚拟环境1mkvirtualenv [虚拟环境名称] 会在当前用户文件夹下创建一个Env文件夹，然后将虚拟环境安装到这个目录下。 2.切换到虚拟环境1workon my_env 退出当前虚拟环境1deactivate 3.删除某个虚拟环境1rmvirtualenv my_env 4.列出所有虚拟环境1lsvirtualenv 5.进入某个虚拟环境1cdvirtualenv my_env","categories":[{"name":"工具 - python - virsualenv","slug":"工具-python-virsualenv","permalink":"http://puguojing.com/categories/工具-python-virsualenv/"}],"tags":[{"name":"virsualenv","slug":"virsualenv","permalink":"http://puguojing.com/tags/virsualenv/"},{"name":"virtualenvwrapper","slug":"virtualenvwrapper","permalink":"http://puguojing.com/tags/virtualenvwrapper/"}],"keywords":[{"name":"工具 - python - virsualenv","slug":"工具-python-virsualenv","permalink":"http://puguojing.com/categories/工具-python-virsualenv/"}]},{"title":"HTTP协议（一）","slug":"HTTP协议（一）","date":"2018-09-28T09:30:01.000Z","updated":"2018-11-05T13:59:37.532Z","comments":true,"path":"2018/09/28/HTTP协议（一）/","link":"","permalink":"http://puguojing.com/2018/09/28/HTTP协议（一）/","excerpt":"","text":"HTTP及超文本传输协议，用于在客户端和服务器之间传送数据，包括文本、图像、视频流都可以使用HTTP协议进行传输。 1.1HTTP协议流程 输入网址并按Enter键，比如访问：hhtp://mysite:8080/app/index.html。 浏览器通过域名系统查询mysite的真实IP，比如：212.34.98.20。 向服务器的8080端口发起TCP请求并建立链接。 发送HTTP请求的内容，包括访问的地址/app/index.html、访问方式GET、浏览器本身的产品等。 服务器返回/app/index.html中的数据，并作文Reponse发送给客户端，如果请求的不是一个文件，则服务器需要执行相应的代码，动态生成切返回给客户端。 浏览器收到结果后关闭于服务器的链接。 浏览器将收到的结果呈现在显示器上。 注意:其中1、2不是HTTP解析的一部分。 如今的HTTP还允许客户端在一次HTTP请求之后不关闭TCP链接，以便之后第2次发送HTTP请求时复用该链接，以减少系统开销，此技术在HTTP中叫keep-alive。 1.2HTTP消息结构1.Request消息结构Request是客户端向服务器发起请求时的请求结构。 123456【请求方法】 【URL】【协议版本】【头字段1】：值 ...【头字段N】：值【消息体】 Request消息结构由两部分组成，消息头和消息体。消息头必须遵循上述格式，消息体则没有固定格式。消息头和消息体之间使用一行空格。 123GET /hello.txt HTTP/1.1Host:www.mysite.comAccept-Languange:en 上面就是一个请求头结构。 1.Reponse消息结构","categories":[],"tags":[],"keywords":[]},{"title":"生成器","slug":"生成器","date":"2018-09-15T14:41:56.000Z","updated":"2018-11-05T16:11:42.644Z","comments":true,"path":"2018/09/15/生成器/","link":"","permalink":"http://puguojing.com/2018/09/15/生成器/","excerpt":"","text":"参考： 廖雪峰官网Python教程-生成器 Python生成器generator之next和send运行流程","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"},{"name":"生成器","slug":"python/生成器","permalink":"http://puguojing.com/categories/python/生成器/"}],"tags":[{"name":"python","slug":"python","permalink":"http://puguojing.com/tags/python/"},{"name":"生成器","slug":"生成器","permalink":"http://puguojing.com/tags/生成器/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"},{"name":"生成器","slug":"python/生成器","permalink":"http://puguojing.com/categories/python/生成器/"}]},{"title":"多线程（二）同步原语","slug":"多线程（二）","date":"2018-09-09T15:11:06.000Z","updated":"2018-11-05T16:10:38.235Z","comments":true,"path":"2018/09/09/多线程（二）/","link":"","permalink":"http://puguojing.com/2018/09/09/多线程（二）/","excerpt":"","text":"Lock、BoundedSemaphore（和Semaphore类似，不过不允许超过初始值）的使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding:utf-8 -*-from atexit import registerfrom random import randrangefrom threading import BoundedSemaphore,Lock,Threadfrom time import sleep,ctimelock = Lock()MAX = 5candytray = BoundedSemaphore(MAX)def producer(loops): print(&apos;producer loops:&apos;,loops) lock.acquire() for i in range(loops): try: candytray.release()#realse后Semaphore会增多相当于产生 except ValueError: print(&apos;release fail all Semaphore &apos;) else: print(&apos;release(produce) ok&apos;) sleep(randrange(3)) lock.release()def consumer(loops): print(&apos;consumer loops:&apos;, loops) lock.acquire() for i in range(loops): if candytray.acquire(False):#acquire后 Semaphore会减少 print(&apos;acquire(consumer) ok&apos;) else: print(&apos;acquire fail empty&apos;) sleep(randrange(3)) lock.release()def main(): n=randrange(2,6) Thread(target=consumer,args=(randrange(n,n+MAX+2),)).start() Thread(target=producer, args=(n,)).start()@registerdef _atexit(): print(&apos;DONE :&apos;,ctime())if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"},{"name":"线程","slug":"python/线程","permalink":"http://puguojing.com/categories/python/线程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"线程","slug":"线程","permalink":"http://puguojing.com/tags/线程/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"},{"name":"线程","slug":"python/线程","permalink":"http://puguojing.com/categories/python/线程/"}]},{"title":"Bootstrap样式设置及Heroku部署","slug":"Django学习笔记（三）样式设置及部署","date":"2018-09-09T14:11:06.000Z","updated":"2018-11-05T17:23:57.137Z","comments":true,"path":"2018/09/09/Django学习笔记（三）样式设置及部署/","link":"","permalink":"http://puguojing.com/2018/09/09/Django学习笔记（三）样式设置及部署/","excerpt":"","text":"1. 前言–在本篇中，我们将：·使用Bootstrap库设置样式；·把项目部署到Heroku上。 2. 设置项目“学习笔记”的样式– 之前关注的都是项目的功能，现在来为项目添加样式。 我们将使用django-bootstrap3来设置样式。首先请在虚拟环境中安装这个第三方库。 1pip install django-bootstrap3 然后像之前在项目settings.py中注册我们自己编写的APP一样，注册bootstrap3这个应用程序。 还需要包含django-bootstrap3包含jQuery，在settings.py末尾添加如下代码： 1234567...LOGIN_URL = &apos;/users/login/&apos;# django-bootstrap3的设置BOOTSTRAP3 = &#123; &quot;include_jquery&quot;: True,&#125; 2.1-2.2参看原文链接 2.3 设置登录页面样式–此处与文中不同，我的login.html中的form无法通过% bootstrap_form form %}引用Bootstrap的样式.因此我的login.html如下： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;% extends &quot;learning_logs/base.html&quot; %&#125;&#123;% load bootstrap3 %&#125;&#123;% block header %&#125; &lt;h2&gt;登录您的账户&lt;/h2&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form action=&quot;&#123;% url &apos;users:login&apos; %&#125;&quot; method=&quot;post&quot; class=&quot;form-signin&quot;&gt; &#123;% csrf_token %&#125; &lt;h2 class=&quot;form-signin-heading&quot;&gt;请登录&lt;/h2&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;&#123;&#123; username &#125;&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;用户名&quot; required autofocus&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; value=&quot;&#123;&#123; password &#125;&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; required&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 2.4-2.6参看原文链接 3. 部署“学习笔记”–3.1-3.2参看原文链接 3.3 为部署到Heroku而修改settings.py–此处setting.py中的与文中不同，文中如下: 1234567891011121314151617181920212223-- snip --# 书中的判断语句是 if os.getcwd() == &apos;/app&apos;: # 现在估计是Heroku升级了，改为了下面的语句，否则待会儿部署的时候会出错if os.environ[&apos;HOME&apos;] == &quot;/app&quot;: import dj_database_url DATABASES = &#123; &quot;default&quot;: dj_database_url.config(default=&quot;postgres://localhost&quot;) &#125; # 让request.is_secure()承认X-Forwarded-Proto头 SECURE_PROXY_HEADER = (&quot;HTTP_X_FORWARDED_PROTO&quot;, &quot;https&quot;) # 支持所有的主机头（host header） ALLOWED_HOSTS = [&quot;*&quot;] # 静态资产配置 BASE_DIR = os.path.dirname(os.path.abspath(__file__)) # 书中设置是这样的： STATIC_ROOT = &quot;staticfiles&quot; STATIC_ROOT = os.path.join(BASE_DIR, &apos;static&apos;) STATICFILES_DIRS = ( os.path.join(BASE_DIR, &quot;static&quot;), ) 按照此种方式设置报错，提示STATICFILES_DIRS 的STATIC_ROOT不正确。 1?: (staticfiles.E002) The STATICFILES_DIRS setting should not contain the STATIC_ROOT setting. 修改为: 1234567891011... # 静态资产配置 BASE_DIR = os.path.dirname(os.path.abspath(__file__)) STATIC_ROOT = &quot;staticfiles&quot;#书中设置是这样的： STATIC_URL = &apos;/static/&apos; #STATIC_ROOT = os.path.join(BASE_DIR, &apos;/static/&apos;)#错误 #STATIC_ROOT = os.path.join(BASE_DIR, &quot;static/&quot;) # 错误(staticfiles.E002) The STATICFILES_DIRS setting should not contain the STATIC_ROOT setting. STATICFILES_DIRS = ( os.path.join(BASE_DIR, &quot;static&quot;), ) 最终执行成功。 3.4 创建启动进程的Procfile– Procfile告诉Heroku启动那些进程，以便能够正确地提供项目支持的服务。这个文件只包含一行，文件名为Procfile，不带扩展名，保存到项目根目录。 1web: gunicorn learning_log.wsgi --log-file - 这段代码让Heroku将gunicorn用过服务器，并使用learning_log/wsgi.py中的设置来启动应用程序。标志log-file告诉Heroku应将哪些类型的时间写入日志。注意最后的“-”不能省略 3.14 部署总结–从前面这些例子可看出，开发与部署的过程如下： ①修改项目。如果创建了新文件，使用命令 git add .（最后有个句点！）将它们加到Git仓库中。如果要迁移数据库，也需要执行该命令，因为每个迁移都生成了新的迁移文件。 ②执行 git commit -am &quot;commit message&quot;，将修改提交到仓库。 ③执行 git push heroku master 将修改推送到服务器。 ④如果本地迁移了数据库，也需要迁移在线数据库，可以使用一次性命令 heroku run python manage.py migrate，也可以使用 heroku run bash打开一个远程终端会话，再执行迁移。 3.15 设置SECRET_KEY–Django根据settings.py中的SECRET_KEY来实现大量的安全协议。本项目中设置的SECRET_KEY对一个练习项目来说已经足够了，但是对于生产网站，请务必认真对待这个值。 3.16 将项目从Heroku删除1(ll_env)learning_log$ heroku apps:destroy --app appname 现在可以访问这个网站 https://pgj-learning-log.herokuapp.com","categories":[{"name":"部署","slug":"部署","permalink":"http://puguojing.com/categories/部署/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"Heroku","slug":"Heroku","permalink":"http://puguojing.com/tags/Heroku/"}],"keywords":[{"name":"部署","slug":"部署","permalink":"http://puguojing.com/categories/部署/"}]},{"title":"多线程（一）","slug":"多线程（一）","date":"2018-09-09T14:11:06.000Z","updated":"2018-11-05T16:10:02.549Z","comments":true,"path":"2018/09/09/多线程（一）/","link":"","permalink":"http://puguojing.com/2018/09/09/多线程（一）/","excerpt":"","text":"&#8195;&#8195; 1.进程&#8195;&#8195;计算机程序知识存储在磁盘上的可执行二进制（或其他类型）文件，只有把他们加载到内存中并被操作系统调用，才拥有生命周期，进程是一个执行中的程序，每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪的辅助数据。由于进程之间相互独立，所以只能采用进程间通信(IPC)的方式共享信息。 2.线程&#8195;&#8195;线程与进程类似，不过他是在同一个进程下执行的，所以共享上下文。 3.全局解释锁(GIL)&#8195;&#8195;Python代码的执行是由Python解释器（解释器主循环）进行控制的，在主循环中同时只能有一个线程在执行，就像单核CPU的多进程一样。尽管Python解释器可以运行多个线程，但是在任意给定的时刻只能有一个线程会被解释器调用。Python解释器将按照下面的过程执行：1.设置GIL。2.切换金一个线程去运行。3.执行下面的操作之一 ： &#8195;&#8195;a.指定数量的字节码指令。 &#8195;&#8195;b.线程主动让出控制权（可以调用time.sleep(0)来完成。4.把线程切换回睡眠状态（切换出线程。5.解锁GIL。6.重复上述步骤。 &#8195;&#8195;在当调用外部代码（即任意C/C++扩展D额内置函数）时，GIL会保持锁定，直至函数执行结束(因为在这期间没有Python字节码计数）。编写扩展函数的程序员有能力解锁GIL。然而，作为Python开发者，你并不需要担心Pyhon代码会在这些情况下被锁住。 &#8195;&#8195;例如，对于任意面向I/O的Python例程(调用了内置操作系统的C代码那种)GIL会在I/O调用前被释放，以允许其他线程在I/O执行的时候运行。而对那些没有太多I/O操作的代码而言，更加倾向于在该线程整个时间片内始终占有处理器。换句话说就是，I/O密集型的Python程序要比计算密集型的代码能够更好的利用多线程环境。 &#8195;&#8195;关于解释器主循环和GIL可以才看源码Python/ceval.c 4.在Python中使用线程&#8195;&#8195;Python提供了多个模块来支持多线程编程，包括thread、threading，queue模块等。thread提供了基本的线程和锁定支持。threading模块提供了更高级别功能，更全面面的线程管理。queue模块，用户可以创建一个队列数据结构，用于在多线程之间进行共享。 推荐使用更高级别的锁定模块threading，而不是使用thread模块。 1.一个原因是低级别的thread模块入的同步原语很少只有Lock，而threading模块拥有Lock,Semephore、Condition、Event等多种同步机制。2.另一个原因是thread对于进程何时退出没有控制，当主线程结束时，所有其他线程也都强制结束，不会发出警告或者进行适当的清理，所以他也不支持守护线程。 守护线程 &#8195;&#8195;守护线程一般是一个等待客户端请求服务的服务器，如果没有客户端请求守护线程就是空闲的.如果把一个线程置为守护线程，就表示这个线程是不重要的。进程退出时不需要等待这个线程执行完成。 &#8195;&#8195;如果主线程准备退出时不需要等待某些子线程完成，就可以为这些子线程设置守护线程标记。该标记值为真时，表示线程是不重要的，或者说线程只是用来等待客户端请求而不做任何其他事情。设置一个线程为守护线程需要在启动线程之前执行如下赋值语句：thread.daemon = True 5.threaing模块下的Thread类 属性 描述 Thread对象的数据属性 Name 线程名 Ident 线程标志符 Daemon 守护线程标志 Thread对象方法 init(group=NONE,target=None,name=None, args=(),kwargs{},verbose=None,daemon=None) 实例化一个线程对象，需要有一个可调用的target，以及其参数args或kwargs，还可以传递name或group参数，daemon会设置thread.daemon属性标志 Start() 开始执行线程 run() 定义线程功能的方法（通常在子类中进行重写） jion() 直至启动的线程终止之前一直挂起。除非给出了timeout。否则会一直阻塞。 代码案例一，创建Thread实例传给他一个可调用的函数： 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python3# -*- coding:utf-8 -*-import threadingfrom time import sleep,ctimeloops_time = [4,2]def loop(nloop,nsec): print(&apos;start loop :&apos;,nloop,&apos;at:&apos;,ctime()) sleep(nsec) print(&apos;end loop :&apos;, nloop, &apos;at:&apos;, ctime())def main(): print(&apos;starting at----------------- :&apos;,ctime()) test_thresds = [] for i in range(len(loops_time)): t = threading.Thread(target=loop,args=(i,loops_time[i])) test_thresds.append(t) for i in range(len(loops_time)): test_thresds[i].start() for i in range(len(loops_time)): test_thresds[i].join() print(&apos;end at :-------------------&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 代码案例二：创建Thread实例传给他一个可调用的类实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3# -*- coding:utf-8 -*-import threadingfrom time import sleep,ctimeloops_time = [4,2]class ThreadFunc(object): def __init__(self,func,args,name=&apos;&apos;): self.name = name self.args = args self.func = func def __call__(self, *args, **kwargs): self.func(*self.args)def loop(nloop,nsec): print(&apos;start loop :&apos;,nloop,&apos;at:&apos;,ctime()) sleep(nsec) print(&apos;end loop :&apos;, nloop, &apos;at:&apos;, ctime())def main(): print(&apos;starting at----------------- :&apos;,ctime()) test_thresds = [] for i in range(len(loops_time)): t = threading.Thread(target=ThreadFunc(loop,args=(i,loops_time[i]),name=loop.__name__)) test_thresds.append(t) for i in range(len(loops_time)): test_thresds[i].start() for i in range(len(loops_time)): test_thresds[i].join() print(&apos;end at :-------------------&apos;, ctime())if __name__ == &apos;__main__&apos;: main() 代码案例三，派生Thread子类，并创建子类实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding:utf-8 -*-import threadingfrom time import sleep,ctimeloops_time = [4,2]class MyThread(threading.Thread): def __init__(self,func,args,name=&apos;&apos;): threading.Thread.__init__(self) self.name = name self.args = args self.func = func def getResult(self): return self.res def run(self): self.res = self.func(*self.args)def loop(nloop,nsec): print(&apos;start loop :&apos;,nloop,&apos;at:&apos;,ctime()) sleep(nsec) print(&apos;end loop :&apos;, nloop, &apos;at:&apos;, ctime())def main(): print(&apos;starting at----------------- :&apos;,ctime()) test_thresds = [] for i in range(len(loops_time)): t = MyThread(func=loop,args=(i,loops_time[i]),name=loop.__name__) test_thresds.append(t) for i in range(len(loops_time)): test_thresds[i].start() print(threading.enumerate()) # 当前活动的Thread对象列表 for i in range(len(loops_time)): test_thresds[i].join() print(&apos;end at :-------------------&apos;, ctime())if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"},{"name":"线程","slug":"python/线程","permalink":"http://puguojing.com/categories/python/线程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"线程","slug":"线程","permalink":"http://puguojing.com/tags/线程/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"},{"name":"线程","slug":"python/线程","permalink":"http://puguojing.com/categories/python/线程/"}]},{"title":"Scrapy学习（一）","slug":"Scrapy学习（一）","date":"2018-09-07T15:13:09.000Z","updated":"2018-11-05T13:59:37.546Z","comments":true,"path":"2018/09/07/Scrapy学习（一）/","link":"","permalink":"http://puguojing.com/2018/09/07/Scrapy学习（一）/","excerpt":"","text":"Scrapy安装Mac下构建Scrapy依赖库需要C编译器及开发头文件，他一般由Xcode提供，具体命令如下： 1xcode-select --install 随后利用pip安装Scrapy 1pip install Scrapy 安装完成后验证安装，命令行输入： 1Scrapy 运行结果如下图说明安装成功： Scrapy框架介绍Scrapy是一个基于Twisted的异步处理框架，是纯Python实现的爬虫框架。其架构清晰，模块之间耦合程度低，可扩展性极强，可以灵活完成各种需求。我们只需要定制开发几个模版就可以轻松实现一个爬虫。 Scrapy的架构框架如下图所示","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"http://puguojing.com/tags/Scrapy/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}]},{"title":"selenium的使用（二）","slug":"selenium的使用（二）","date":"2018-08-30T07:49:51.000Z","updated":"2018-11-05T13:59:37.559Z","comments":true,"path":"2018/08/30/selenium的使用（二）/","link":"","permalink":"http://puguojing.com/2018/08/30/selenium的使用（二）/","excerpt":"","text":"使用selenium打开chrome浏览器百度进行搜索12345678910111213141516171819202122232425from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitimport timebrower = webdriver.Chrome()try: brower.get(&apos;https://www.baidu.com/&apos;) input = brower.find_element_by_id(&apos;kw&apos;)#通过id寻找元素 input.send_keys(&apos;Python&apos;)#在找到的input输入框内输入Python input.send_keys(Keys.ENTER)#输入键盘的Enter wait = WebDriverWait(brower,10)#设置wait的超时时间 wait.until(EC.presence_of_element_located((By.ID,&apos;content_left&apos;)))#等待直到出现id是conten_left的元素加载出来的时候，最大等待时间不超过10秒 print(brower.current_url)#打印url print(brower.get_cookies())#打印现在的cookies print(brower.page_source)#打印网页源代码 time.sleep(5)except Exception as e: print(e)finally: brower.close() 还可以使用其他浏览器，比如：Firefox、Edge、以及一些手机浏览器等 12345678from selenium import webdriverbrower = webdriver.Chrome()brower = webdriver.Firefox()brower = webdriver.Edge()brower = webdriver.PhantomJS()brower = webdriver.Safari() 注意每个浏览器都有自己对应的类似chrome浏览器的chromedriver驱动可执行文件。 2使用selenium打开淘货搜索123456789101112131415161718brower = webdriver.Chrome()try: brower.get(&apos;https://www.taobao.com/&apos;) search_input = brower.find_element_by_id(&apos;q&apos;) search_input.send_keys(&apos;iPhone&apos;) time.sleep(2) search_input.clear() time.sleep(1) search_input.send_keys(&apos;iPad&apos;) time.sleep(1) search_button = brower.find_element_by_class_name(&apos;btn-search&apos;) time.sleep(1) search_button.click() time.sleep(10)except Exception as e: print(e)finally: brower.close() 打开淘宝，搜索‘iPhone’然后删除，接着搜索‘iPad’ 3.动作链，实现拖拽1234567891011121314151617from selenium.webdriver import ActionChainsbrower = webdriver.Chrome()try: url = &apos;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&apos; brower.get(url) brower.switch_to.frame(&apos;#iframeResult&apos;)#切换到子页面中&apos;iframeResult&apos;是子页面的id名，也可以根据name inex 甚至webElement对象定位 source = brower.find_element_by_css_selector(&apos;#draggable&apos;) target = brower.find_element_by_css_selector(&apos;#droppable&apos;) actions = ActionChains(brower)#构建action actions.drag_and_drop(source,target)# actions.perform()#调用perform()就是执行上面的动作链except Exception as e: print(e)finally: brower.close() ActionChains是什么呢？顾名思义，是一个动作链，如果在一个用例中只有一两个动作，那么用之前讲过的简单版的就可以了，如果动作很复杂，那么可以使用这个了。 1.ActionChains是自动执行低级交互的一种方式，例如：鼠标移动，鼠标点按，键盘操作，文本操作等。2.当我们调用这里的方法时，这些操作会被先储存在一个队列中，当我们调用perform()方法时，队列中的操作会被按顺序执行，执行后队列被清空。 iframe的切换参看网址:https://blog.csdn.net/huilan_same/article/details/52200586frame标签有frameset、frame、iframe三种，frameset跟其他普通标签没有区别，不会影响到正常的定位，而frame与iframe对selenium定位而言是一样的，selenium有一组方法对frame进行操作。 1.怎么切到frame中(switch_to.frame())selenium提供了switch_to.frame()方法来切换frame 1switch_to.frame(reference) 不得不提到switch_to_frame()，很多人在这样写的时候会发现，这句话被划上了删除线，原因是这个方法已经out了，之后很有可能会不支持，建议的写法是switch_to.frame() reference是传入的参数，用来定位frame，可以传入id、name、index以及selenium的WebElement对象，假设有如下HTML代码 index.html： 12345678&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;FrameTest&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src=&quot;a.html&quot; id=&quot;frame1&quot; name=&quot;myframe&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 想要定位其中的iframe并切进去，可以通过如下代码： 123456from selenium import webdriverdriver = webdriver.Firefox()driver.switch_to.frame(0) # 1.用frame的index来定位，第一个是0# driver.switch_to.frame(&quot;frame1&quot;) # 2.用id来定位# driver.switch_to.frame(&quot;myframe&quot;) # 3.用name来定位# driver.switch_to.frame(driver.find_element_by_tag_name(&quot;iframe&quot;)) # 4.用WebElement对象来定位 通常采用id和name就能够解决绝大多数问题。但有时候frame并无这两项属性，则可以用index和WebElement来定位：1.index从0开始，传入整型参数即判定为用index定位，传入str参数则判定为用id/name定位2.WebElement对象，即用find_element系列方法所取得的对象，我们可以用tag_name、xpath等来定位frame对象 比如： 1&lt;iframe src=&quot;myframetest.html&quot; /&gt; 用xpath定位，传入WebElement对象： 1driver.switch_to.frame(driver.find_element_by_xpath(&quot;//iframe[contains(@src,&apos;myframe&apos;)]&quot;)) 2.从frame中切回主文档(switch_to.default_content())切到frame中之后，我们便不能继续操作主文档的元素，这时如果想操作主文档内容，则需切回主文档。 1driver.switch_to.default_content() 3.嵌套frame的操作(switch_to.parent_frame())有时候我们会遇到嵌套的frame，如下： 12345&lt;html&gt; &lt;iframe id=&quot;frame1&quot;&gt; &lt;iframe id=&quot;frame2&quot; / &gt; &lt;/iframe&gt;&lt;/html&gt; 1.从主文档切到frame2，一层层切进去 12driver.switch_to.frame(&quot;frame1&quot;)driver.switch_to.frame(&quot;frame2&quot;) 2.从frame2再切回frame1，这里selenium给我们提供了一个方法能够从子frame切回到父frame，而不用我们切回主文档再切进来。 1driver.switch_to.parent_frame() # 如果当前已是主文档，则无效果 有了parent_frame()这个相当于后退的方法，我们可以随意切换不同的frame，随意的跳来跳去了。 所以只要善用以下三个方法，遇到frame分分钟搞定： 123driver.switch_to.frame(reference)driver.switch_to.parent_frame()driver.switch_to.default_content() 另外补充一下，之前曾看到过用点分法来切入嵌套frame的方法，但我试验之后发现并不能定位到frame： 1driver.switch_to.frame(&apos;frame1.0.frame3&apos;) 据说以上代码可以切到 “frame1” 下的 “第一个frame” 下的 “frame3” 中。 Selenium官方文档点击查看Selenium官方文档","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"selenium","slug":"selenium","permalink":"http://puguojing.com/tags/selenium/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}]},{"title":"selenium的使用（一）安装及环境配置","slug":"selenium的使用（一）","date":"2018-08-30T07:49:51.000Z","updated":"2018-11-05T13:59:37.557Z","comments":true,"path":"2018/08/30/selenium的使用（一）/","link":"","permalink":"http://puguojing.com/2018/08/30/selenium的使用（一）/","excerpt":"","text":"1.安装selenium1pip install selenium 2.安装ChromeDriver2.1查看chrome版本： 我的版本是68.0 64 位，所以要下载对应的ChromeDriver版本，打开如下网址：https://chromedriver.storage.googleapis.com/index.html 下拉找到对应自己chrome版本的ChromeDriver版本，我的Chrome版本是68.0对应的ChromeDriver版本是2.40。 下面的是不同的chrome版本和对应的ChromeDriver版本对照表：第一列是ChromeDriver版本，第二列是chrome版本。 v2.40 v66-68v2.39 v66-68v2.38 v65-67v2.37 v64-66v2.36 v63-65v2.35 v62-64v2.34 v61-63v2.33 v60-62v2.32 v59-61v2.31 v58-60v2.30 v58-60v2.29 v56-58v2.28 v55-57v2.27 v54-56v2.26 v53-55v2.25 v53-55v2.24 v52-54v2.23 v51-53v2.22 v49-52v2.21 v46-50v2.20 v43-48v2.19 v43-47v2.18 v43-46v2.17 v42-43v2.13 v42-45v2.15 v40-43v2.14 v39-42v2.13 v38-41v2.12 v36-40v2.11 v36-40v2.10 v33-36v2.9 v31-34v2.8 v30-33v2.7 v30-33v2.6 v29-32v2.5 v29-32v2.4 v29-32 下载完成后会是一个chromedriver_mac64.zip压缩文件，解压后chromedriver是一个Unix可执行文件 接下来就需要配置环境变量让这个可执行文件在任意目录下可执行，你可以直接把它放到/usr/bin等已经存在环境变量路径的目录里，也可以新添加一条自己的路径：首先新建一个文件目录： 1sudo mkdir -p /usr/local/chromedriver 然后把‘chromedriver’这个可执行文件放到这个目录里,在‘chromedriver’这个可执行文件所在的目录下执行： 1sudo mv chromedriver /usr/local/chromedriver 可以把文件放到该目录。 接着打开配置文件添加环境变量路径： 1vim ./.bash_profile 添加一行： 1export PATH=&quot;/usr/local/chromedriver:$PATH&quot; 然后执行 1source ./.bash_profile 使修改生效，然后输入：export查看修改结果： 1234567~export...PATH=&apos;/usr/local/chromedriver:/usr/local/opt/imagemagick@6/bin:/Users/pgj/anaconda3/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/aria2/bin:/usr/local/share/dotnet:/Library/Frameworks/Mono.framework/Versions/Current/Commands:/Applications/Wireshark.app/Contents/MacOS:/Applications/Xamarin Workbooks.app/Contents/SharedSupport/path-bin:/usr/local/mysql/bin&apos;PWD=/Users/pgjSHELL=/bin/zsh.... 发现PATH中有：/usr/local/chromedriver目录路径（此路径一定要和chromedriver可执行文件所放目录一致，务必注意拼写错误），说明加入到环境变量成功。之后关闭命令行终端重新打开命令行终端输入：chromedriver如果控制台有如下显示输出说明配置好了: 123~ chromedriverStarting ChromeDriver 2.40.565386 (45a059dc425e08165f9a10324bd1380cc13ca363) on port 9515Only local connections are allowed. !!!注意该上述修改之后可能在运行代码是仍然会报：NOT FOUND chromedriver 错误，所以最好的办法就是直接把chromedriver可执行文件放入usr/bin/中。其他浏览器也是同样类似的只需要下载对应的驱动文件放入usr/bin/中即可，比如Firefox浏览器就需要下载GeckoDriver，地址如下：https://github.com/mozilla/geckodriver/releases 由于我的MAC版本是：10.13,系统开启了Rootless内核保护机制，所以需要关闭。（mac 从10.11及之后加入了Rootless内核保护机制）关闭方法参考如下链接：http://www.pc6.com/edu/86809.html1.重启电脑开后按住 Command-R 进入恢复分区. 然后在 实用工具 栏找到 终端启动运行.输入:csrutil disable; reboot2.你会看到系统保护被关闭的字样并且系统自动重启. 这样你就可以修改系统级别的文件了. 3.通过csrutil status来查询 Rootless 保护的状态. 12~ csrutil statusSystem Integrity Protection status: disabled. 4.最后就是重新激活 Rootless的方法了. 终端内输入：csrutil enable","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"selenium","slug":"selenium","permalink":"http://puguojing.com/tags/selenium/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}]},{"title":"MongoDB（一）","slug":"MongoDB常用接口的使用代码案例（一）","date":"2018-08-29T09:22:49.000Z","updated":"2018-11-05T13:59:37.533Z","comments":true,"path":"2018/08/29/MongoDB常用接口的使用代码案例（一）/","link":"","permalink":"http://puguojing.com/2018/08/29/MongoDB常用接口的使用代码案例（一）/","excerpt":"","text":"参考常用MongoDB操作代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262#!/usr/bin/python3# -*- coding:utf-8 -*-import pymongo#brew install mongodb#新建一个文件夹/data/db 用于存放MangoDB数据#启动MongoDB服务：brew services start mongodb#sudo mongodb#停止MongoDB服务：brew services stop mongodb#重启MongoDB服务：brew services restart mongodb #import pymongo#创建MongoDB连接对象client = pymongo.MongoClient(host=&apos;localhost&apos;,port=27017)#client = pymongo.MongoClient(&apos;mongondb://localhost:27017/&apos;)#指定或创建数据库db = client.testmongodb#db = client[&apos;testmongodb&apos;]#指定或创建集合(类似于table)collection = db.studens#collection = db[&apos;studens&apos;]#插入数据，数据以字典的形势表示data = &#123; &apos;id&apos;:&apos;20180001&apos;, &apos;name&apos;:&apos;Lio&apos;, &apos;age&apos;:20&#125;#第一种方式，插入一条数据#result = collection.insert(data)#print(result)#5b866486623b564260fca3f7data_1 = &#123; &apos;id&apos;:&apos;20180002&apos;, &apos;name&apos;:&apos;mark&apos;, &apos;age&apos;:21&#125;data_2 = &#123; &apos;id&apos;:&apos;20180003&apos;, &apos;name&apos;:&apos;kang&apos;, &apos;age&apos;:24&#125;#第一种方式，插入多条数据#result = collection.insert([data_1,data_2])#print(result)#[ObjectId(&apos;5b866b6c623b5643595070b2&apos;), ObjectId(&apos;5b866b6c623b5643595070b3&apos;)]data_3 = &#123; &apos;id&apos;:&apos;20180004&apos;, &apos;name&apos;:&apos;lin&apos;, &apos;age&apos;:25, &apos;gender&apos;:&apos;male&apos;&#125;#第二种方式，插入一条数据#result = collection.insert_one(data_3)#print(result)#&lt;pymongo.results.InsertOneResult object at 0x10c1d3d88&gt;#print(type(result))#&lt;class &apos;pymongo.results.InsertOneResult&apos;&gt;#print(result.inserted_id)#5b866c5d623b5643904db0afdata_4 = &#123; &apos;id&apos;:&apos;20180005&apos;, &apos;name&apos;:&apos;heler&apos;, &apos;age&apos;:30, &apos;gender&apos;:&apos;male&apos;&#125;data_5 = &#123; &apos;id&apos;:&apos;20180006&apos;, &apos;name&apos;:&apos;jay&apos;, &apos;age&apos;:22, &apos;gender&apos;:&apos;female&apos;&#125;#第二种方式插入多条数据#result = collection.insert_many([data_4,data_5])#print(result)#&lt;pymongo.results.InsertManyResult object at 0x109435ec8&gt;#print(type(result))#&lt;class &apos;pymongo.results.InsertManyResult&apos;&gt;#print(result.inserted_ids)#[ObjectId(&apos;5b866d0f623b5643c6acf070&apos;), ObjectId(&apos;5b866d0f623b5643c6acf071&apos;)]##### 推荐使用insert_one()和insert_many()#查询#可以使用find_one()和find（）方法进行查询，其中find_one()查询得到的是单条结果，find（）则是返回一个生成器对象#result = collection.find_one(&#123;&apos;name&apos;:&apos;Lio&apos;&#125;)#print(type(result))#&lt;class &apos;dict&apos;&gt;#print(result)#&#123;&apos;_id&apos;: ObjectId(&apos;5b866486623b564260fca3f7&apos;), &apos;id&apos;: &apos;20180001&apos;, &apos;name&apos;: &apos;Lio&apos;, &apos;age&apos;: 20&#125;#返回的是字典类型，其中数据多了一个_id属性他是MongoDB插入数据时自动添加的#此外我们可以根据ObjectId来查询，此时需要bson库中的objectid:#from bson.objectid import ObjectId#result = collection.find_one(&#123;&apos;_id&apos;:ObjectId(&apos;5b866486623b564260fca3f7&apos;)&#125;)#print(type(result))#&lt;class &apos;dict&apos;&gt;#print(result)#&#123;&apos;_id&apos;: ObjectId(&apos;5b866486623b564260fca3f7&apos;), &apos;id&apos;: &apos;20180001&apos;, &apos;name&apos;: &apos;Lio&apos;, &apos;age&apos;: 20&#125;#对于多条数据查询可以使用find#results = collection.find(&#123;&apos;age&apos;:30&#125;)#print(type(results))#&lt;class &apos;pymongo.cursor.Cursor&apos;&gt;#print(results)#&lt;pymongo.cursor.Cursor object at 0x10cd07160&gt;#for result in results:#&#123;&apos;_id&apos;: ObjectId(&apos;5b866d0f623b5643c6acf070&apos;), &apos;id&apos;: &apos;20180005&apos;, &apos;name&apos;: &apos;heler&apos;, &apos;age&apos;: 30, &apos;gender&apos;: &apos;male&apos;&#125;# print(result)#返回的结果是cursor类型，相当于一个生成器#条件查询#查询年龄大于20的数据#results = collection.find(&#123;&apos;age&apos;:&#123;&apos;$gt&apos;:20&#125;&#125;)#print(type(results))#&lt;class &apos;pymongo.cursor.Cursor&apos;&gt;#print(results)#&lt;pymongo.cursor.Cursor object at 0x10cf561d0&gt;#for result in results:## print(result)#查询结果：#&#123;&apos;_id&apos;: ObjectId(&apos;5b866b6c623b5643595070b2&apos;), &apos;id&apos;: &apos;20180002&apos;, &apos;name&apos;: &apos;mark&apos;, &apos;age&apos;: 21&#125;#&#123;&apos;_id&apos;: ObjectId(&apos;5b866b6c623b5643595070b3&apos;), &apos;id&apos;: &apos;20180003&apos;, &apos;name&apos;: &apos;kang&apos;, &apos;age&apos;: 24&#125;#&#123;&apos;_id&apos;: ObjectId(&apos;5b866c5d623b5643904db0af&apos;), &apos;id&apos;: &apos;20180004&apos;, &apos;name&apos;: &apos;lin&apos;, &apos;age&apos;: 25, &apos;gender&apos;: &apos;male&apos;&#125;#&#123;&apos;_id&apos;: ObjectId(&apos;5b866d0f623b5643c6acf070&apos;), &apos;id&apos;: &apos;20180005&apos;, &apos;name&apos;: &apos;heler&apos;, &apos;age&apos;: 30, &apos;gender&apos;: &apos;male&apos;&#125;#&#123;&apos;_id&apos;: ObjectId(&apos;5b866d0f623b5643c6acf071&apos;), &apos;id&apos;: &apos;20180006&apos;, &apos;name&apos;: &apos;jay&apos;, &apos;age&apos;: 22, &apos;gender&apos;: &apos;female&apos;&#125;#这里的查询条件是一个字典形式：意思是查询age大于20的信息,$gt是大于，其他常见入如下：#$lt 小于 &#123;&apos;age&apos;:&#123;&apos;$lt&apos;:20&#125;&#125;#$gt 大于 &#123;&apos;age&apos;:&#123;&apos;$gt&apos;:20&#125;&#125;#$lte 小于等于 &#123;&apos;age&apos;:&#123;&apos;$lte&apos;:20&#125;&#125;#$gte 大于等于 &#123;&apos;age&apos;:&#123;&apos;$gte&apos;:20&#125;&#125;#$ne 不等于 &#123;&apos;age&apos;:&#123;&apos;$ne&apos;:20&#125;&#125;#$in 在范围内 &#123;&apos;age&apos;:&#123;&apos;$in&apos;:[20,23]&#125;&#125;#$nin 不在范围内 &#123;&apos;age&apos;:&#123;&apos;$nin&apos;:[20,23]&#125;&#125;#$lt 小于 &#123;&apos;age&apos;:&#123;&apos;$t&apos;:20&#125;&#125;#还可以正则匹配#results = collection.find(&#123;&apos;name&apos;:&#123;&apos;$regex&apos;:&apos;^M.*&apos;&#125;&#125;)#&apos;$regex&apos;表示使用正则匹配，&apos;^M.*&apos;表示以M开头#其他：#$exists 属性是否存在 &#123;&apos;name&apos;:&#123;&apos;$exists&apos;:True&#125;&#125; name的属性存在#$type 类型判断 &#123;&apos;age&apos;:&#123;&apos;$type&apos;:&apos;int&apos;&#125;&#125; age的类型为int#$mod 数字模操作 &#123;&apos;age&apos;:&#123;&apos;$mod&apos;:&apos;[5,0]&apos;&#125;&#125; 年龄的模5余0#$text 文本查询 &#123;&apos;$text&apos;:&#123;&apos;$search&apos;:&apos;Mike&apos;&#125;&#125; text类型的属性中包含Mike字符串#$where 高级条件查询 &#123;&apos;where&apos;:&apos;obj.fans_count == obj.follows_count&apos;&#125; 自身粉丝数等于关注数#计数#可使用count函数统计查询的数据条数#count = collection.find(&#123;&apos;name&apos;:&#123;&apos;$regex&apos;:&apos;^.*&apos;&#125;&#125;).count()#print(count)#排序#pymongo.ASCENDIN升序,pymongo.DESCENDING降序#results = collection.find().sort(&apos;name&apos;,pymongo.DESCENDING)#for result in results:# print(result)#偏移#使用skip(2)，表示偏移几个位置，及忽略查询到的前面2条数据#使用limit(2)表示最多获取多少结果，限制获取的条数#！！！注意在庞大数据的时候（千万、亿级别）不要使用大偏移量来查询数据，可能导致内存溢出#可以使用类似如下操作:#from bson.objectid import ObjectId#collection.find(&#123;&apos;_id&apos;:&#123;&apos;$gt&apos;:&apos;5b866b6c623b5643595070b2&apos;&#125;&#125;)#这时只需要记录上次查询的id#更新#使用update()方法更新#condition = &#123;&apos;name&apos;:&apos;Lio&apos;&#125;#result_1 = collection.find_one(condition)#print(result_1)#result_1[&apos;age&apos;] = 20#result_2 = collection.update(condition,result_1)#print(result_2)#这里我们需要先查询到要修改的数据，修改完之后使用udate()方法将修改后的数据传入#执行结果#&#123;&apos;_id&apos;: ObjectId(&apos;5b866486623b564260fca3f7&apos;), &apos;id&apos;: &apos;20180001&apos;, &apos;name&apos;: &apos;Lio&apos;, &apos;age&apos;: 20&#125;#&#123;&apos;n&apos;: 1, &apos;nModified&apos;: 0, &apos;ok&apos;: 1.0, &apos;updatedExisting&apos;: True&#125;#还可以使用 $set 进行更新,注意使用$set只会更新result_1字典里存在的字段，如果原先还有其他字段怎不会更新也不会删除#而如果不用$set，会把之前的数据全部用result_1替换，若原数据存在其他字段则会被删除#condition = &#123;&apos;name&apos;:&apos;Lio&apos;&#125;#result_1 = collection.find_one(condition)#print(result_1)#result_1[&apos;age&apos;] = 20#result_2 = collection.update(condition,&#123;&apos;$set&apos;:result_1&#125;)#print(result_2)#建议使用update_one()和update_many()，第二个参数不能直接使用字典要使用$类型操作符#使用matched_count(匹配的数据条数)和modified_count(影响的数据条数)查看结果#condition = &#123;&apos;name&apos;:&apos;Lio&apos;&#125;#result_1 = collection.find_one(condition)#result_1[&apos;age&apos;] = 22#result_2 = collection.update_one(condition,&#123;&apos;$set&apos;:result_1&#125;)#print(result_2)#print(result_2.matched_count,result_2.modified_count)#执行结果#&#123;&apos;_id&apos;: ObjectId(&apos;5b866486623b564260fca3f7&apos;), &apos;id&apos;: &apos;20180001&apos;, &apos;name&apos;: &apos;Lio&apos;, &apos;age&apos;: 20&#125;#&#123;&apos;n&apos;: 1, &apos;nModified&apos;: 1, &apos;ok&apos;: 1.0, &apos;updatedExisting&apos;: True&#125;#&lt;pymongo.results.UpdateResult object at 0x110dd2fc8&gt;#1 1#使用条件#表示查询年龄条件大于20的人，然后更新条件为&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:1&#125;，表示age加1，执行后将会在爱满足条件的数据age字段加1#condition = &#123;&apos;age&apos;:&#123;&apos;$gt&apos;:20&#125;&#125;#result_2 = collection.update_one(condition,&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:1&#125;&#125;)#print(result_2)#print(result_2.matched_count,result_2.modified_count)#执行结果：由于使用了update_one所以只影响了1条数据#&lt;pymongo.results.UpdateResult object at 0x10627bf48&gt;#1 1#使用update_many(),更新所有#condition = &#123;&apos;age&apos;:&#123;&apos;$gt&apos;:10&#125;&#125;#result_2s = collection.update_many(condition,&#123;&apos;$inc&apos;:&#123;&apos;age&apos;:1&#125;&#125;)#print(type(result_2s))#print(result_2s)#print(result_2s.matched_count,result_2s.modified_count)#执行结果#&lt;class &apos;pymongo.results.UpdateResult&apos;&gt;#&lt;pymongo.results.UpdateResult object at 0x10f76bfc8&gt;#6 6#删除#result = collection.remove(&#123;&apos;name&apos;:&apos;heler&apos;&#125;)#print(result) #&#123;&apos;n&apos;: 1, &apos;ok&apos;: 1.0&#125;#推荐使用delete_one()和delete_many()#result = collection.delete_one(&#123;&apos;name&apos;:&apos;lin&apos;&#125;)#print(result) #&lt;pymongo.results.DeleteResult object at 0x10e8fadc8&gt;#print(result.deleted_count)result = collection.delete_many(&#123;&apos;age&apos;:&#123;&apos;$lt&apos;:26&#125;&#125;)print(result) #&lt;pymongo.results.DeleteResult object at 0x10e40bdc8&gt;print(result.deleted_count) #4#其他操作#find_one_and_delete()#find_one_and_replace()#find_one_and_update()#详见官方文档","categories":[],"tags":[],"keywords":[]},{"title":"Mysql忘记密码如何重置？","slug":"Mysql忘记密码解决办法","date":"2018-08-28T15:20:31.000Z","updated":"2018-11-05T13:59:37.540Z","comments":true,"path":"2018/08/28/Mysql忘记密码解决办法/","link":"","permalink":"http://puguojing.com/2018/08/28/Mysql忘记密码解决办法/","excerpt":"","text":"忘记Mysql密码如何重置？step1： 苹果-&gt;系统偏好设置-&gt;最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server） step2： 进入终端输入：cd /usr/local/mysql/bin/ 回车后 登录管理员权限 sudo su 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe –skip-grant-tables &amp; 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） step3. 输入命令 ./mysql 回车后，输入命令 FLUSH PRIVILEGES; 回车后，输入命令 ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘password’;（会把密码重置为password，如果想改其他的把password替换即可） 完整步骤如下图:","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"Mysql","slug":"Mysql","permalink":"http://puguojing.com/tags/Mysql/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}]},{"title":"Mysql常用pyhon接口的实现：增、删、改、查","slug":"Mysql常用pyhon接口的代码实现","date":"2018-08-28T15:20:31.000Z","updated":"2018-11-05T13:59:37.542Z","comments":true,"path":"2018/08/28/Mysql常用pyhon接口的代码实现/","link":"","permalink":"http://puguojing.com/2018/08/28/Mysql常用pyhon接口的代码实现/","excerpt":"","text":"代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#!/usr/bin/python3# -*- coding:utf-8 -*-import pymysql&quot;&quot;&quot;函数：CreateDatabase(Database_name)功能：创建数据库参数：Database_name：要创建的数据库名&quot;&quot;&quot;def CreateDatabase(Database_name): db = pymysql.connect(host=&apos;localhost&apos;,user=&apos;root&apos;,password=&apos;password&apos;,port=3306) cursor = db.cursor() cursor.execute(&apos;SELECT VERSION()&apos;) data = cursor.fetchone() print(&apos;DataBase Version:&apos;,data) sql = &apos;CREATE DATABASE &#123;&#125; DEFAULT CHARACTER SET utf8&apos;.format(Database_name) try: cursor.execute(sql) except Exception as e: print(&apos;Create %s error：&apos;%(Database_name), e) db.close()&quot;&quot;&quot;函数：CreateTables(DataBase,table)功能：在指定数据库里面创建指定的表参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名&quot;&quot;&quot;def CreateTables(DataBase,table): db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306,db=DataBase) cursor = db.cursor() sql = &apos;CREATE TABLE IF NOT EXISTS &#123;&#125; (id VARCHAR(255) NOT NULL,user_name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id))&apos;.format(table) try: cursor.execute(sql) except Exception as e: print(&apos;%s Create %s error：&apos;%(DataBase,table),e) db.close()&quot;&quot;&quot;函数：Insert(DataBase,table,data)功能：在某一数据库的指定表中插入一条数据,如果该数据的key已经存在则会插入失败参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名 3.data：要插入的数据，字典类型比如： data = &#123; &apos;id&apos;:&apos;20180001&apos;, &apos;user_name&apos;:&apos;Bob&apos;, &apos;age&apos;:20 &#125;&quot;&quot;&quot;def Insert(DataBase,table,data): db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306, db=DataBase) cursor = db.cursor() keys = &apos;,&apos;.join(data.keys())#-&gt;id,user_name,age values = &apos;,&apos;.join([&apos;%s&apos;] * len(data))#[&apos;a&apos;]*4 -&gt; [a,a,a,a] &apos;,&apos;.join([a,a,a,a])-&gt;&apos;a,a,a,a&apos; sql = &apos;INSERT INTO &#123;t&#125; (&#123;k&#125;) VALUES(&#123;v&#125;)&apos;.format(t=table,k=keys,v=values)#使用form格式化结果：INSERT INTO students (id,user_name,age) VALUES(%s,%s,%s) print(sql) try: cursor.execute(sql, tuple(data.values())) db.commit() except Exception as e: print(&quot;insert error&quot;, e) db.rollback() db.close()&quot;&quot;&quot;函数：Update(Database,table,data)功能：根据key更新某一数据库的指定表中的某一条数据，如果key存在在更新数据，不存在则插入数据参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名 3.data：要更新或插入的数据，字典类型比如： data = &#123; &apos;id&apos;:&apos;20180002&apos;, &apos;user_name&apos;:&apos;lio&apos;, &apos;age&apos;:22 &#125;&quot;&quot;&quot;def Update(Database,table,data): &quot;&quot;&quot; data = &#123; &apos;id&apos;:&apos;20180001&apos;, &apos;user_name&apos;:&apos;Bob&apos;, &apos;age&apos;:20 &#125; &quot;&quot;&quot; # table = &apos;students&apos; db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306, db=Database) cursor = db.cursor() keys = &apos;,&apos;.join(data.keys()) # -&gt;id,user_name,age values = &apos;,&apos;.join([&apos;%s&apos;] * len(data)) # [&apos;a&apos;]*4 -&gt; [a,a,a,a] &apos;,&apos;.join([a,a,a,a])-&gt;&apos;a,a,a,a&apos; sql = &apos;INSERT INTO &#123;t&#125; (&#123;k&#125;) VALUES(&#123;v&#125;) ON DUPLICATE KEY UPDATE&apos;.format(t=table, k=keys, v=values) # 使用format格式化INSERT INTO students (id,user_name,age) VALUES(%s,%s,%s) ON DUPLICATE KEY UPDATE update = &apos;,&apos;.join(&apos; &#123;key&#125; = %s&apos;.format(key=key) for key in data) #注意前面有空格，结果：&apos; id = %s,user_name = %s,age = %s&apos; #ON DUPLICATE KEY UPDATE 表示如果主键存在就执行UPDATE 而不是插入 sql += update #结果：INSERT INTO students (id,user_name,age) VALUES(%s,%s,%s) ON DUPLICATE KEY UPDATE id = %s, user_name = %s, age = %s try: cursor.execute(sql, tuple(data.values())*2)#使用了2次值，共6个%s db.commit() except Exception as e: print(&quot;insert error&quot;, e) db.rollback() db.close()&quot;&quot;&quot;函数：Delete(Database,table,condition):功能：根据指定条件删除数据库某表中的满足条件的数据参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名 3.condition：指定的SQL语句条件，比如：&apos;age &gt; 20&apos;,表示删除所有 age字段的值大于20的数据&quot;&quot;&quot;def Delete(Database,table,condition): db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306, db=Database) cursor = db.cursor() sql = &apos;DELETE FROM &#123;tables&#125; WHERE &#123;conditions&#125;&apos;.format(tables=table,conditions=condition) try: cursor.execute(sql) db.commit() except Exception as e: print(&quot;insert error&quot;, e) db.rollback() db.close()&quot;&quot;&quot;函数：Select(Database,table,condition)功能：从数据库某表中根据指定条件查询的满足条件的数据参数：1.DataBase：已经创建的数据库名 2.table：要创建的表名 3.condition：指定的SQL语句条件，比如：&apos;age &gt; 20&apos;,表示查询所有age字段的值大于20的数据返回值：列表，存储满足查询条件的信息，列表的每个元素是一条信息，用元组封装。&quot;&quot;&quot;def Select(Database,table,condition): db = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;password&apos;, port=3306, db=Database) cursor = db.cursor() sql = &apos;SELECT * FROM &#123;tablses&#125; WHERE &#123;conditions&#125;&apos;.format(tablses=table,conditions=condition) result = [] try: cursor.execute(sql) row = cursor.fetchone()#row是以元组返回，row： (&apos;20180001&apos;, &apos;Bob&apos;, 20) while row: result.append(row) row=cursor.fetchone() except Exception as e: print(&quot;SELECT error&quot;, e) db.close() return resultdef main(): CreateDatabase(&apos;test_db&apos;) CreateTables(&apos;test_db&apos;,&apos;test_db_table_1&apos;) data = &#123; &apos;id&apos;:&apos;20180004&apos;, &apos;user_name&apos;:&apos;jack&apos;, &apos;age&apos;:22 &#125; Insert(&apos;test_db&apos;,&apos;test_db_table_1&apos;,data) data = &#123; &apos;id&apos;:&apos;20180004&apos;, &apos;user_name&apos;:&apos;jack&apos;, &apos;age&apos;:25 &#125; Update(&apos;test_db&apos;,&apos;test_db_table_1&apos;,data) #Delete(&apos;test_db&apos;,&apos;test_db_table_1&apos;,&apos;age &gt; 21&apos;) result= Select(&apos;test_db&apos;,&apos;test_db_table_1&apos;,&apos;age &gt; 19&apos;) print(result)if __name__ == &apos;__main__&apos;: main()","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"Mysql","slug":"Mysql","permalink":"http://puguojing.com/tags/Mysql/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}]},{"title":"BeautifulSoup学习笔记（一）","slug":"BeautifulSoup学习笔记（一）","date":"2018-08-27T05:10:32.000Z","updated":"2018-11-05T17:20:15.781Z","comments":true,"path":"2018/08/27/BeautifulSoup学习笔记（一）/","link":"","permalink":"http://puguojing.com/2018/08/27/BeautifulSoup学习笔记（一）/","excerpt":"","text":"1后续更新...","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/categories/爬虫/"},{"name":"BeautifulSoup","slug":"爬虫/BeautifulSoup","permalink":"http://puguojing.com/categories/爬虫/BeautifulSoup/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/tags/爬虫/"},{"name":"BeautifulSoup","slug":"BeautifulSoup","permalink":"http://puguojing.com/tags/BeautifulSoup/"}],"keywords":[{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/categories/爬虫/"},{"name":"BeautifulSoup","slug":"爬虫/BeautifulSoup","permalink":"http://puguojing.com/categories/爬虫/BeautifulSoup/"}]},{"title":"python爬虫-爬取豆瓣书籍（一）","slug":"python爬虫-爬取豆瓣书籍（一）","date":"2018-08-26T06:10:20.000Z","updated":"2018-11-05T13:59:37.556Z","comments":true,"path":"2018/08/26/python爬虫-爬取豆瓣书籍（一）/","link":"","permalink":"http://puguojing.com/2018/08/26/python爬虫-爬取豆瓣书籍（一）/","excerpt":"","text":"本篇记录使用Requests+Xpath爬取豆瓣书籍 1.RequestsRequests是python的一个HTTP库，里面包含了常见的一些HTTP操作，下面是Requests常用的七种方法： 方法 说明 requests.request() 构造一个请求，支撑以下方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页的信息头的方法，对应于HTTP的HEAD requests.post() 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HTML网页提交局部修改请求的方法，对应于HTTP的PATCH requests.delete() 向HTML网页提交请删除求的方法，对应于HTTP的DELETE 我们最常用的就是request.get()方法。 Requests.get()的用法12import requests#导入Requests库r = requests.get(url)#使用get方法发送请求，返回包含网页数据的Response并存储到对象r中 Response对象的属性r.statues.code: http请求的返回状态，200表示连接成功，404表示连接失败 r.text：http响应内容的字符串形式，url对应的页面内容 r.encoding：从HTTP header中猜测的响应内容编码方式 r.apparent_encoding：从内容分析出的响应内容的编码方式（备选编码方式） r.content:HTTP响应内容的二进制形式 r.headers：http响应内容的头部内容 123456789resp.text返回的是Unicode型的数据。resp.content返回的是bytes型也就是二进制的数据。也就是说，如果你想取文本，可以通过r.text。如果想取图片，文件，则可以通过r.content。（resp.json()返回的是json格式数据） 查看Requestes开发文档 Xpathxpath即为XML路径语言（XML Path Language），他是一种用来确定XML文档中某部分位置的语言。Xpath基于XML的树状结构，提供在数据结构树中找寻节点的能力。起初Xpath的提出初衷是将其做为一个通用的、介于Xpointer与XSL间的语法模型，但是很快Xpath被开发者采用来当作小型的查询语言。 Xpath解析网页的流程1.首先通过Requests库获取网页数据。2.通过网页解析得到想要的数据或者新的链接。3.网页解析可以通过Xpath或者其他的解析工具进行。Xpath，是一个非常友好的网页解析工具。 lxml库lxml库结合libxml2快速强大的特性，使用xpath语法来进行文件格式解析，与Beautiful相比，效率更高。 安装1pip install lxml 使用123from lxml import etree #导入库data = requests.get(url).text#获取网页内容s = etree.HTML(data)#解析网页节点 代码： 1234567891011121314151617181920def craw_douban_book_top250(): msg_num = 0 #数量统计 for page in range(10): #根据对网站分析，每页有25条信息，所有爬取10页共250条 url = &apos;https://book.douban.com/top250?start=&#123;&#125;&apos;.format(page*25)#每页的url地址最后刚好差25 data = requests.get(url).text #获取网页的内容 s = etree.HTML(data) #解析HTML节点转换成对象 divs = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table&apos;) #每一本书籍最外部的节点 for div in divs: msg_num += 1 title = div.xpath(&apos;./tr/td[2]/div[1]/a/@title&apos;)[0]#从最外部节点找到书籍名，后面加[0]是引用列表元素。 href = div.xpath(&apos;./tr/td[2]/div[1]/a/@href&apos;)[0]#从最外部节点找到书籍详细链接 score = div.xpath(&apos;./tr/td[2]/div[2]/span[2]/text()&apos;)[0]#从最外部节点找到书籍评分 score_people_num = div.xpath(&apos;./tr/td[2]/div[2]/span[3]/text()&apos;)[0]\\ .strip(&quot;(&quot;).strip().strip(&quot;)&quot;)#从最外部节点找到书籍评价人数，并去除左右两边的括号和中间的空格 print(&quot;&#123;&#125;: &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(msg_num, title, href, score, score_people_num)) time.sleep(1)#防止抓取信息过于频繁导致IP被封及尽量不影响别人的网站 通过对豆瓣TOP250书籍的url分析对比如下： 12345&lt;a href=&quot;https://book.douban.com/top250?start=25&quot;&gt;2&lt;/a&gt;&lt;a href=&quot;https://book.douban.com/top250?start=50&quot;&gt;3&lt;/a&gt;&lt;a href=&quot;https://book.douban.com/top250?start=75&quot;&gt;4&lt;/a&gt;&lt;a href=&quot;https://book.douban.com/top250?start=100&quot;&gt;5&lt;/a&gt;.... 我们发现区别就在于最后”start=”的数值每次相差25，所以 可以使用： 12for page in range(10): 10页共250条 url = &apos;https://book.douban.com/top250?start=&#123;&#125;&apos;.format(page*25) 来获取网页地址。 我们在获取每一本书的Xpath的时候也发现相应的规律，比如第一本书： 1234书籍的Xpath：‘//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]’书名的Xpath: &apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div[1]/a&apos;评分的Xpath：‘//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div[2]/span[2]’人数的Xpath：‘//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]/div[2]/span[3]’ 我们可以看到的是书名、评分、人数的Xpath都是在整本书的Xpath=‘//*[@id=&quot;content&quot;]/div/div[1]/div/table[1]/tbody/tr/td[2]’的基础上在多加一点内容。所以我们可以这样写： 123456789divs = s.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/div/table&apos;) #每一本书籍最外部的节点 for div in divs: msg_num += 1 title = div.xpath(&apos;./tr/td[2]/div[1]/a/@title&apos;)[0]#从最外部节点找到书籍名 href = div.xpath(&apos;./tr/td[2]/div[1]/a/@href&apos;)[0]#从最外部节点找到书籍详细链接 score = div.xpath(&apos;./tr/td[2]/div[2]/span[2]/text()&apos;)[0]#从最外部节点找到书籍评分 score_people_num = div.xpath(&apos;./tr/td[2]/div[2]/span[3]/text()&apos;)[0]\\ .strip(&quot;(&quot;).strip().strip(&quot;)&quot;)#从最外部节点找到书籍评价人数，并去除左右两边的括号和中间的空格 每一个信息都是在最外部的节点路径上加上更详细的路径。 注意： 1.当我们复制Xpath是里面会有一个”tbody/“内容，我们在下载时需要把这个内容删除掉，不然无法获取对应的信息。2.关于在Xpath内容后加上”text()“,”@title”、”@href“等内容是Xpath语法详见XPath总结的内容。 下面是另一个爬取小猪短租南京在指定时间内的信息 123456789101112131415161718def Craw(): msg_num = 0 for p in range(1,6): url = &apos;http://nj.xiaozhu.com/search-duanzufang-p&#123;&#125;-0/?startDate=2018-08-27&amp;endDate=2018-09-30&apos;.format(p) data = requests.get(url).text s = etree.HTML(data) #print(data) divs = s.xpath(&apos;//*[@id=&quot;page_list&quot;]/ul/li&apos;) for div in divs: msg_num += 1 titles = div.xpath(&apos;./div[2]/div/a/span/text()&apos;)[0] details = div.xpath(&apos;./div[2]/div/em/text()&apos;)[0].strip() prices = div.xpath(&apos;./div[2]/span[1]/i/text()&apos;)[0] href = div.xpath(&apos;./a/@href&apos;)[0] time.sleep(1) print(&quot;&#123;&#125;: &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(msg_num,titles,details,prices,href)) 加入存储数据到文件的内容： 12345678910111213141516171819202122def Craw(): msg_num = 0 with open(r&apos;/Users/pgj/Desktop/data.csv&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;) as f: for p in range(1,3): url = &apos;http://nj.xiaozhu.com/search-duanzufang-p&#123;&#125;-0/?startDate=2018-08-27&amp;endDate=2018-09-30&apos;.format(p) data = requests.get(url).text s = etree.HTML(data) #print(data) divs = s.xpath(&apos;//*[@id=&quot;page_list&quot;]/ul/li&apos;) for div in divs: msg_num += 1 titles = div.xpath(&apos;./div[2]/div/a/span/text()&apos;)[0] details = div.xpath(&apos;./div[2]/div/em/text()&apos;)[0].strip() prices = div.xpath(&apos;./div[2]/span[1]/i/text()&apos;)[0] href = div.xpath(&apos;./a/@href&apos;)[0] time.sleep(1) f.write(&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\\n&quot;.format(msg_num,titles,details,prices,href)) print(&quot;&#123;&#125;: &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(msg_num,titles,details,prices,href))Craw()","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/categories/爬虫/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/tags/爬虫/"}],"keywords":[{"name":"爬虫","slug":"爬虫","permalink":"http://puguojing.com/categories/爬虫/"}]},{"title":"Django学习笔记（二）-用户登录及注册","slug":"Django学习笔记（2）","date":"2018-08-23T08:47:12.000Z","updated":"2018-11-05T16:20:12.119Z","comments":true,"path":"2018/08/23/Django学习笔记（2）/","link":"","permalink":"http://puguojing.com/2018/08/23/Django学习笔记（2）/","excerpt":"","text":"&#8195;&#8195; 用户账户 此处只记录在项目中，制作登录功能时遇到的问题以及解决方法。 3. 创建用户账户 3.2 登陆页面 此处与书中不同，书中使用Django提供的默认登陆视图，而此处则是自己实现login登录视图。在users中的urls.py中添加如下代码： 12345678urlpatterns = [ # 登陆页面 #path(&quot;login/&quot;, login, &#123;&quot;template_name&quot;: &quot;users/login.html&quot;&#125;, name=&quot;login&quot;), path(&apos;login/&apos;, views.login_view,name=&quot;login&quot;), path(&quot;logout/&quot;, views.logout_view, name=&quot;logout&quot;), path(&quot;register/&quot;, views.register, name=&quot;register&quot;),] 原文中使用views中自带的login，但是我的Django版本是2.1。views中没有login，于是自己在view中实现login。views.PY代码如下： 12345678910111213141516171819202122from django.shortcuts import render, redirect, reversefrom django.contrib.auth import authenticate,login,logoutfrom django.http import HttpResponseRedirectfrom django.contrib.auth.forms import UserCreationFormdef login_view(request): if request.method == &apos;GET&apos;: return render(request, &apos;users/login.html&apos;) username = request.POST.get(&apos;username&apos;, &apos;&apos;) password = request.POST.get(&apos;password&apos;, &apos;&apos;) user = authenticate(request, username=username, password=password) if user is not None: login(request, user) return redirect(reverse(&apos;learning_logs:index&apos;)) else: return render(request, &apos;users/login.html&apos;, &#123; &apos;username&apos;: username, &apos;password&apos;: password, &#125;) login.html如下： 12345678910111213141516&#123;% extends &quot;learning_logs/base.html&quot; %&#125;&#123;% block content %&#125; &lt;form action=&quot;&#123;% url &apos;users:login&apos; %&#125;&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &#123;&#123; form.as_p &#125;&#125; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;&#123;&#123; username &#125;&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;用户名&quot; required autofocus&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; value=&quot;&#123;&#123; password &#125;&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; required&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt;&#123;% endblock %&#125; 此处登录界面完成。 其它内容请参考:原文链接","categories":[{"name":"Web框架","slug":"Web框架","permalink":"http://puguojing.com/categories/Web框架/"},{"name":"Django","slug":"Web框架/Django","permalink":"http://puguojing.com/categories/Web框架/Django/"}],"tags":[{"name":"Web框架","slug":"Web框架","permalink":"http://puguojing.com/tags/Web框架/"},{"name":"Django","slug":"Django","permalink":"http://puguojing.com/tags/Django/"}],"keywords":[{"name":"Web框架","slug":"Web框架","permalink":"http://puguojing.com/categories/Web框架/"},{"name":"Django","slug":"Web框架/Django","permalink":"http://puguojing.com/categories/Web框架/Django/"}]},{"title":"Django学习笔记（一）-入门介绍及基本使用","slug":"Django学习笔记（一）入门介绍及基本使用","date":"2018-08-23T05:51:18.000Z","updated":"2018-11-05T13:59:37.518Z","comments":true,"path":"2018/08/23/Django学习笔记（一）入门介绍及基本使用/","link":"","permalink":"http://puguojing.com/2018/08/23/Django学习笔记（一）入门介绍及基本使用/","excerpt":"","text":"&#8195;&#8195; 《Python编程：从入门到实践》笔记。记一次完成一个“学习笔记”的小网站。 1. 前言 在本篇中，我们将： 用Django来开发一个名为“学习笔记”(Learning Log)的项目； 为这个项目制定规范，然后为应用程序使用的数据定义模型； 使用Django的管理系统来输入一些初试数据，再学习编写视图和模板，让Django能够为我们的网站创建网页。 &#8195;&#8195;不过在开始之前，请先新建一个虚拟环境并安装Django。如果没有虚拟环境，通过pip安装的所有库都会保存到python的site-packages目录下。开发多个项目时，都会用同一个python，而某些项目并不需要其中的所有第三方库，但如果将这些不需要库的删除，又会影响到其他项目。而且，如果A项目需要Django2.0.4，B项目需要Django2.0.0，这该怎么办？此时就需要虚拟环境。它其实就相当于一个新的文件夹，将新项目与其他项目隔离，本项目的库不与其他项目的库相关联，类似于操作系统的多用户概念。 如果使用的是Python 3，可以使用命令： python -m venv ll_env 如果该命令不成功，可能是没有安装virtualenv模块：pip install virtualenv 然后创建并激活虚拟环境： 12345678910#创建虚拟环境，ll_env代表着虚拟环境名称virtualenv ll_env# linux:source ll_env/bin/activate# windows:ll_env\\Scripts\\activate# 停用：deactivate 管理虚拟环境的库还有很多，有兴趣的话可以到网上搜一搜。 如果你使用的是新版的PyCharm，那么它在新建项目的时候默认就会创建新的虚拟环境。 激活虚拟环境后就可以安装Django了： pip install django 2. 建立项目 2.1 在Django中创建项目 2.1.1 生成项目在虚拟环境中执行如下命令： 123# 主要最后有个实心句号！# 这个句点让新项目使用合适的目录结构，这样开发完成后可以轻松地将应用程序部署到服务器django-admin startproject learning_log . 执行上述命令后，将多出一个manage.py文件和一个learning_log文件夹，当然还有本身的一个ll_env文件夹。 而在learning_log文件夹中，又有四个文件：init.py，settings.py，urls.py，wsgi.py。 manage.py是一个简单的程序，它接收命令并将其交给Django的相关部分去运行；settings.py指定Django如何与你的系统交互以及如何管理项目，其实就是配置文件；urls.py告诉Django应创建哪些网页来响应浏览器请求；wsgi.py是web server gateway interface(Web服务器网关接口)的缩写，帮助Django提供它创建的文件。至于init.py，它是个空文件，Python的每个模块下必须要有这个文件。##### 2.1.2 创建数据库Django将大部分与项目相关的信息都存储在数据库中，所有还需要创建一个供Django使用的数据库。依然是在虚拟环境下执行如下命令：python manage.py migrate&#8195;&#8195;在PyCharm中的话，可以通过点击工具栏Tools中的Run manage.py Task（Ctrl+Alt+R），在弹出的命令行中直接输入原命令中manage.py后面的部分，后面的命令也可以这样执行（[appname]是自动提示）。&#8195;&#8195;”migrate”这个单词其实是迁移的意思，并不是“创建(create)”。之所以使用这个词，是因为一般将修改数据库的过程称为迁移数据库（笔者数据库学得渣，这段解释直接从书里照搬的，希望哪位大神在留言区解释一波）。如果是刚创建的项目，并且第一次执行，将会得到如下输出：123456Operations to perform: Apply all migrations: admin, auth, contenttypes, sessionsRunning migrations: Applying contenttypes.0001_initial... OK -- snip -- Applying sessions.0001_initial... OK从第2行结果可以看出，Django将创建和修改数据库看做是对数据库的迁移，Apply all migrations确保数据库结构与当前代码匹配（比如你修改了类的结构，添加了属性，这就相当于修改了数据表）。执行命令后，项目的根目录下会多出一个名为db.sqlite3的数据库文件。SQLite是一种使用单个文件的轻量级数据库，常用于开发简单应用程序，它让你不用太关注数据库管理的问题。##### 2.1.3 运行项目依然在项目的虚拟环境下输入如下命令：1python manage.py runserver得到如下输出：1234567Performing system checks...System check identified no issues (0 silenced).April 21, 2018 - 20:46:48Django version 2.0.4, using settings &apos;learning_log.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK.现在在浏览器中地址栏输入localhost:8000 (或者127.0.0.1:8000)，将得到如下页面：这是最新版的Django的默认启动界面。##### 3.1 映射URL（此处与原文略有不同）——-Django创建网页的过程通常分三个阶段：定义URL、编写视图和编写模板。URL模式描述了URL是如何设计的，让Django知道如何将浏览器请求与网站URL匹配，以确定返回哪个网页。每个URL都被映射到特定的视图——视图函数获取并处理网页所需的数据。视图函数通常调用一个模板，后者生成浏览器能够理解的网页。目前，基础URL(http://localhost:8000/ )返回默认的Django页面，现在修改这个映射，将其映射到我们自己编写的主页。打开learning_log文件夹中的urls.py，将看到如下内容：123456789101112131415161718from django.contrib import adminfrom django.urls import pathurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls),]# 书中的内容和实际的内容有些出入，以下是书中内容：# 新版Django简化了URL路由写法# from django.conf.urls import include, url# from django.contrib import admin# # from django.conf.urls import include, url# from django.contrib import admin## urlpatterns = [# url(r&apos;^admin/&apos;, include(admin.site.urls)),# ]变量urlpatterns包含项目中的APP的URL，admin.site.urls模块定义了可在管理网站中请求的所有URL。现在添加代码：123456789from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&quot;&quot;, include(&quot;learning_logs.urls&quot;)), # 书中代码： # url(r&quot;&quot;, include(&quot;learning_logs.urls&quot;, namespace=&quot;learning_logs&quot;)),]注意：书中在此处的include()函数中传入了关键字参数namespace=”learning_logs”，但在新版中，命名空间(namespace)是在APP的urls.py中设置的：在urlpatterns变量前新建一个值为”learning_logs”的app_name变量。此处与我配置不同，我已经在urlpatterns变量前新建一个值为”learning_logs”的app_name变量。但是仍然会报错：无法找到namespace,于是把urlpatterns修改为： 1234urlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&quot;&quot;, include(&quot;learning_logs.urls&quot;,namespace = &apos;learning_logs&apos;)),#https://blog.csdn.net/mukvintt/article/details/80320027 还是添加了namesapce 参数，而learning_log/urls.py为： 123456789#learning_logs的URLfrom django.urls import pathfrom . import views#添加命名空间app_name = &apos;learing_logs&apos; #https://blog.csdn.net/qq_38504396/article/details/79687269urlpatterns = [ #主页 path(&quot;&quot;,views.index,name = &apos;index&apos;), 我的Django版本是2.1 ……………… 原文链接","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"Djiango","slug":"Djiango","permalink":"http://puguojing.com/tags/Djiango/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}]},{"title":"python学习-闭包函数、装饰器","slug":"python学习-闭包函数、装饰器","date":"2018-08-20T06:02:50.000Z","updated":"2018-11-05T13:59:37.550Z","comments":true,"path":"2018/08/20/python学习-闭包函数、装饰器/","link":"","permalink":"http://puguojing.com/2018/08/20/python学习-闭包函数、装饰器/","excerpt":"","text":"&#8195;&#8195; 1.不定长变量123def fun_1(*kargs,**kwargs): print(kargs) print(kwargs) 1fun_1(1,2,3,row = 1,colum = 2) 123输出结果：(1, 2, 3)&#123;&apos;row&apos;: 1, &apos;colum&apos;: 2&#125; 2.闭包函数&#8195;&#8195;函数闭包是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。（维基百科）1234def fun(x,y): def close_fun(a): return x+y+a #可以使用x,y return close_fun #返回函数对象 12var= fun(1,2)#fun(1,2)返回的是一个close_fun函数对象var(3) #结果：6，相当于使用close_fun(3） 3.装饰器函数&#8195;&#8195;装饰器函数就是把被装饰的函数当做参数传入一个闭包函数中，使闭包函数中的内容先执行，然后在执行被装饰函数中的内容。 (1)被装饰的函数带参数1234567#装饰器函数def my_decorator(fun):#fun代表被装饰的函数 def close_fun(a,b):#内部函数的参数要和被装饰的函数fun的参数对应 a += 1 #在执行被装饰的函数之前，先对参数做处理 b += 1 return fun(a,b) #返回被装饰的函数的 &apos;调用&apos; return close_fun #返回闭包函数 &apos;对象&apos; 123@my_decoratordef fun_add(x,y):#被装饰的函数fun_add是带参数的 return x+y 12#调用fun_add(1,2)#结果是5 123456#调用过程#1.把fun_add当做参数传入装饰器 res_fun = my_decorator（fun_add）#2.由于my_decorator是一个闭包函数，返回的是一个colse_fun 函数对象，所以res_fun &lt;-等价与-&gt;close_fun#3.调用close_fun(a,b),对应的实参就是close_fun(1,2)#4.close_fun内部对参数进行 &apos;+= 1&apos;的处理 所以传入的实参 1，2 变成了 2，3#5.close_fun内部最后返回的是被装饰的函数fun_add调用，而此时参数已经变成了2，3，所以是fun_add(2,3),最终结果 return 2+3 为 5 (2)装饰器函数同时也带参数1234567891011121314151617#装饰器函数同时也带参数,只需要在外面再加一层嵌套即可def my_decorator_arg(arg_1,arg_2): def my_decorator(fun):#fun代表被装饰的函数 def close_fun(a,b):#内部函数的参数要和被装饰的函数fun的参数对应 # 在执行被装饰的函数之前，先对参数做处理,根据装饰器装饰器函数不同的参数，对被装饰的函数做不同的处理 if arg_1==&apos;yes&apos;:#如果装饰器函数的第一个参数是yes,就对被装饰的函数的第一个参数进行 +1处理 a += 1 elif arg_1==&apos;no&apos;:#如果装饰器函数的第一个参数是no,就对被装饰的函数的第一个参数进行 -1处理 a -= 1 if arg_2 == 0:#如果装饰器函数的第二个参数是0,就对被装饰的函数的第二个参数进行 +1处理 b += 1 elif arg_2 == 1:#如果装饰器函数的第二个参数是1,就对被装饰的函数的第二个参数进行 -1处理 b -= 1 return fun(a,b) #返回被装饰的函数的 &apos;调用&apos; return close_fun #返回闭包函数 &apos;对象&apos; return my_decorator #返回装饰器函数 &apos;对象&apos; 12345@my_decorator_arg(&apos;yes&apos;,0)def fun_add(x,y):#被装饰的函数fun_add是带参数的 return x+yr = fun_add(1,2)#结果是5 12345@my_decorator_arg(&apos;no&apos;,0)def fun_add(x,y):#被装饰的函数fun_add是带参数的 return x+yr = fun_add(1,2)#结果是3 (3)被装饰函数任意参数1234567891011121314def my_decorator(fun):#fun代表被装饰的函数 def close_fun(*args,**kwargs):#内部函数的参数不定参 a += 1 #在执行被装饰的函数之前，先对参数做处理 res = fun(*args,**kwargs)#&apos;调用&apos;被装饰的函数 return res * res #对结果再做处理 return close_fun #返回闭包函数 &apos;对象&apos;@my_decorator_argdef fun_add(x):#被装饰的函数fun_add参数不定 return x@my_decorator_argdef fun_add(x,y,k):#被装饰的函数fun_add参数不定 return x+y+k (4)多个装饰函数12345678910111213141516def my_decorator_1(fun):#第一个装饰器函数，求和 def close_fun(*args,**kwargs): print(&quot;my_decorator_1 args:&quot;,args) print(&quot;my_decorator_1 kwargs:&quot;,kwargs) res = fun(*args,**kwargs)#调用被装饰的函数 return res + res return close_fundef my_decorator_2(fun):##第二个装饰器函数，求平方 def close_fun(*args,**kwargs): print(&quot;my_decorator_2 args:&quot;, args) print(&quot;my_decorator_2 kwargs:&quot;, kwargs) res = fun(*args,**kwargs) return res * res return close_fun 12345678910111213141516@my_decorator_1@my_decorator_2def fun_add(x,y):#被装饰的函数fun_add是带参数的 print(&apos;fun_add:&apos;,x,y) return x+yr = fun_add(1,2)print(r)#输出结果：#my_decorator_1 args: (1, 2)#my_decorator_1 kwargs: &#123;&#125;#my_decorator_2 args: (1, 2)#my_decorator_2 kwargs: &#123;&#125;#fun_add: 1 2#18 1234顺序:先执行my_decorator_2，后执行顺序1中先执行my_decorator_1。用嵌套表示：my_decorator_1(my_decorator_2(fun_add))具体分析：1.my_decorator_1调用fun(1,2)得到res为3，然后return 3*3 = 92.然后调用my_decorator_2 来自my_decorator_1 中结果 是 9 然后return 9+9 得出18 12345678910111213141516@my_decorator_2@my_decorator_1def fun_add(x,y):#被装饰的函数fun_add是带参数的 print(&apos;fun_add:&apos;,x,y) return x+yr = fun_add(1,2)print(r)#输出结果：#mmy_decorator_2 args: (1, 2)#my_decorator_2 kwargs: &#123;&#125;#my_decorator_1 args: (1, 2)#my_decorator_1 kwargs: &#123;&#125;#fun_add: 1 2#36 1234顺序:先执行my_decorator_1，后执行顺序1中先执行my_decorator_2。用嵌套表示：my_decorator_2(my_decorator_1(fun_add))具体分析：1.my_decorator_2调用fun(1,2)得到res为3，然后return 3+3 = 62.然后调用my_decorator_1 来自my_decorator_1 中结果 是 6 然后return 6*6 得出36 多个装饰器装饰一个函数时，装饰器的顺序也很重要。执行时总是先执行离被装饰函数最近的装饰函数，由近及远。","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"闭包","slug":"闭包","permalink":"http://puguojing.com/tags/闭包/"},{"name":"装饰器","slug":"装饰器","permalink":"http://puguojing.com/tags/装饰器/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}]},{"title":"Python学习笔记-面向对象","slug":"python学习-面向对象","date":"2018-07-22T06:35:42.000Z","updated":"2018-11-05T13:59:37.554Z","comments":true,"path":"2018/07/22/python学习-面向对象/","link":"","permalink":"http://puguojing.com/2018/07/22/python学习-面向对象/","excerpt":"","text":"&#8195;&#8195; 面向对象类：是我们抽象出来的属性的集合，是描述。实例：也叫做对象，是我们用类这个属性集合具体生成的实例。属性：定义在类中的方法或变量。实例属性：定义在具体方法中的属性（属性可以是方法也可以是变量），只用作当前的实例。类属性：类属性定义在类中且在函数体外，类属性被所有实例化的对象共有，类属性通常不作为实例属性使用。 类的变量属性比如定义类变量： 123456Class A(): var_1 = 1 #类的变量属性，可以使用类名和实例名调用``` 其中var_1这个变量指的就是A这个类的变量，他可以通过类名调用（比如：`A.var_1`），也可以通过实例名调用（比如：`a = A() a.Var_1`）比如我们创建2个A类的实例： a1 = A()a2 = A()12我们可以使用实例名调用变量： a1.var_1 #值为1a2.var_1 #值为112也可以使用类名调用变量： A.var_1 #值为11234如果单独修改a1.var_1或a2.var_1的值，则不会影响其他实例的var_1和类本身的var_1的值，但是如果修改A.var_1（类变量）的值，则所有的实例变量都会被改变。比如,如果把a.var_1的值修改为2，则b.var_1和A.var_1的值均不会改变，仍为1。但是如果把A.var_1的值修改为2则a.var_1和b.var_1的值都会变成2。### 实例的变量属性 Class A(): def init(self) self.var_1 = 1 #实例的变量属性，只可以使用实例名调用12创建2个实例： a1 = A()a2 = A()12使用实例名调用变量： a1.var_1 值为1a2.var_1 值为112使用类名调用变量： A.var_1 #不可以使用12### 类属性和实例属性名不能设置成一样 class Student(object):… name = ‘Student’…s = Student() # 创建实例sprint(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Studentprint(Student.name) # 打印类的name属性Students.name = ‘Michael’ # 给实例绑定name属性print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michaelprint(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Studentdel s.name # 如果删除实例的name属性print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student12345从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。### 实例的函数属性实例的函数属性一般函数的第一个参数是*self*,Pyhon会默认把函数的第一个参数当做指向类实例的参数，一般使用*self*，当然你也可以换成其他的名字，毕竟这个地方只是形参，但是一般从程序的可读性上而言我们不会那么做。 Class A(): def func(self,a,b): print(a+b) 12如果我们想要调用func,则需要先实例化A这个类，然后使用实例化出来的对象调用： a = A()a.fun(2,3)1234567但是这里我们可不可以使用类名调用这个func函数呢，比如使用`A.func(2,3)`行不行呢,这当然是不行的。&gt;`“self，这里的self可以理解为C++中的this指针。遵循的原则就是：哪个实例调用我这个含有self的函数或变量，我这个函数或变量的self就代表哪个实例（指向哪个实例）。总结一句话：“谁调用就指向谁”`### 类方法类方法顾名思义就是指类的方法，而不是实例的方法，下面我们来看2个例子： Class A(): def func(a,b): print(a+b)12我们注意到这里的func没有使用self这个参数，那如果我们使用`a.fun(2,3)`这种调用会怎么样呢？答案是会报参数出错，因为在使用实例调用一个函数的时候，第一个参数会被默认是self，然而我们这里并没有定义这个参数。这里我们可以通过类名来调用这个参数`A.func(2,3)`,这样会成功。这里我们好像就是要使用类名调用函数了，看起来像是类的方法，但是通常我们不会这样做，而是采用@clasmethod装饰器的方法来定义类方法： Class A(): @classmethod def func(cls,a,b): print(a+b)12首先我们可以使用实例对象调用这个方法： a = A()a.func(2,3)12也可以使用类名来调用这个方法： A.func(2,3)1234这里的方法默认会有一个cls的参数，用来表示当前的类（注意不是实例）。如果想在类的方法里面调用类的变量，可以使用cls: class A(): num = 1 @classmethod def func(cls): cls.num += 1#使用cls.num，而不能直接使用num print(&apos;cls.num:&apos;,cls.num) 12注意不管是使用类名调用类方法还是使用实例调用类方法所产生的结果都会相应影响： a = A() print(‘A.num:’,A.num)a.func()print(‘A.num:’,A.num)A.func()print(‘A.num:’,A.num)12输出的结果： A.num: 1cls.num: 2A.num: 2cls.num: 3A.num: 312而且类方法中不能调用实例变量属性，比如： class A(): def init(self): self.var = 0 @classmethod def func(cls): cls.var += 1 print(cls.var) 1234567891011会报错:`AttributeError: type object &apos;A&apos; has no attribute &apos;var&apos;`### 静态方法定义静态方法使用`@staticmethod`，可以使用类名调用。静态方法不需要默认的任何参数,跟一般的普通函数类似.**通过这样的定义方式，我们可以在多个实例之间共享这个函数中的数据和内容。**静态方法无法访问实例变量。**类方法于静态方法**：&gt;1.类方法需要传递cls参数，静态方法不需要；2.静态方法和类方法都不可以访问实例变量；3.类方法可以通过cs访问类变量，静态方法不可以。 class A(): num = 1 @staticmethod def func():#func中无法使用num a = 1 print(&apos;&apos;,a) 12可以使用实例和类名调用： a = A()A.func()12345### 继承继承分为单继承和多继承。**单继承：**子类只能继承一个父类。**多继承：**子类继承多个父类。#### 单继承： class A1(A): pass12可以使用`A1.__base__`查看A1的基类 class A1(A): def init(self): self.var = 1 print(self.var)123456A1是A的子类，如果A1中没有__init__（self）函数，默认会调用父类的__init__(self),如果子类重写了__init__(self),则不会调用父类的__init___(self)。#### 多继承：定义两个基类： class A(): def init(self): print(‘this is A’) class B(): def init(self): print(‘this is B’)12定义一个子类C： class C(A,B):#注意继承顺序 pass12实例化C这个类： c = C()12输出是： this is B1234说明调用的是B的**__init__(self)**如果定义C这个类 class C(B,A): pass12实例化C这个类输出是： this is A12345678910说明调用的是A的**__init__(self)**### Python 多继承调用父类的顺序：python调用父类构造的顺序是:*从左往右，从下往上*。采用的是广度优先搜索算法，总会先找离自己最近的一个节点。具体方法是:首先访问i这个节点，然后访问i所有未被访问的相邻节点。![14](http://pc59bkg3l.bkt.clouddn.com/14.png)如图，访问顺序是：`9-&gt;7-&gt;8-&gt;3-&gt;4-&gt;5-&gt;6-&gt;1-&gt;2` #!/usr/bin/python3 -- coding:utf-8 --class A(object): def init(self): print(‘A’) super(A, self).init()class B(object): def init(self): print(‘B’) super(B, self).init()class C(A): def init(self): print(‘C’) super(C, self).init()class D(A): def init(self): print(‘D’) super(D, self).init()class E(B,C): def init(self): print(‘E’) super(E, self).init()class F(C,B,D): def init(self): print(‘F’) super(F, self).init()class G(D,B): def init(self): print(‘G’) super(G, self).init() if name == ‘main‘: g = G() print(G.mro()) f = F() print(F.mro())12输出结果： GDAB[, , , , ]FCBDA[, , , , , ] 1234567891011121.如果每个类都有正确的写super(X, self).__init__()，那么mro顺序的所有的类的初始化方法都会执行一遍 2.如果中途有的类没有写或错误的写了super(X, self).__init__()，那么会按mro顺序执行到执行完没写的那个类，执行结束。 3.super(X, self)不是必须点__init__()，可以点别的，但一般没有这么做的 4.类名.mro可以得到mro的顺序 5.这种写法可以实现每个类都被执行有且仅有一次。#### 静态语言VS动态语言的继承对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了： class Timer(object): def run(self): print(‘Start…’)1234567891011121314151617&gt;这就是动态语言的“**鸭子类型**”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。&gt;继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。&gt;动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的#### 获取对象的信息当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？##### 用dir()如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法： dir(‘ABC’)[‘add‘, ‘class‘,…, ‘subclasshook‘, ‘capitalize’, ‘casefold’,…, ‘zfill’]12类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的： len(‘ABC’)3‘ABC’.len()312我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法： class MyDog(object):… def len(self):… return 100…dog = MyDog()len(dog)10012剩下的都是普通属性或方法，比如lower()返回小写的字符串： ‘ABC’.lower()‘abc’1234##### getattr()、setattr()以及hasattr()仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态： class MyObject(object):… def init(self):… self.x = 9… def power(self):… return self.x * self.x…obj = MyObject()12紧接着，可以测试该对象的属性： hasattr(obj, ‘x’) # 有属性’x’吗？Trueobj.x9hasattr(obj, ‘y’) # 有属性’y’吗？Falsesetattr(obj, ‘y’, 19) # 设置一个属性’y’hasattr(obj, ‘y’) # 有属性’y’吗？Truegetattr(obj, ‘y’) # 获取属性’y’19obj.y # 获取属性’y’19 12如果试图获取不存在的属性，会抛出AttributeError的错误： getattr(obj, ‘z’) # 获取属性’z’Traceback (most recent call last): File ““, line 1, in AttributeError: ‘MyObject’ object has no attribute ‘z’12可以传入一个default参数，如果属性不存在，就返回默认值： getattr(obj, ‘z’, 404) # 获取属性’z’，如果不存在，返回默认值40440412也可以获得对象的方法： hasattr(obj, ‘power’) # 有属性’power’吗？Truegetattr(obj, ‘power’) # 获取属性’power’ &lt;bound method MyObject.power of &lt;main.MyObject object at 0x10077a6a0&gt;&gt; fn = getattr(obj, ‘power’) # 获取属性’power’并赋值到变量fnfn # fn指向obj.power &lt;bound method MyObject.power of &lt;main.MyObject object at 0x10077a6a0&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81 12345#### 使用__slots__如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性： class Student(object): slots = (‘name’, ‘age’) # 用tuple定义允许绑定的属性名称1然后，我们试试： s = Student() # 创建新的实例s.name = ‘Michael’ # 绑定属性’name’s.age = 25 # 绑定属性’age’s.score = 99 # 绑定属性’score’Traceback (most recent call last): File ““, line 1, in AttributeError: ‘Student’ object has no attribute ‘score’12345由于&apos;score&apos;没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的： class GraduateStudent(Student):… pass…g = GraduateStudent()g.score = 9999123456除非在子类中也定义__slots__，这样，**子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。**#### 使用@property在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改： s = Student()s.score = 999912这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数： class Student(object): def get_score(self): return self._score def set_score(self, value): if not isinstance(value, int): raise ValueError(&apos;score must be an integer!&apos;) if value &lt; 0 or value &gt; 100: raise ValueError(&apos;score must between 0 ~ 100!&apos;) self._score = value 12现在，对任意的Student实例进行操作，就不能随心所欲地设置score了： s = Student()s.set_score(60) # ok!s.get_score()60s.set_score(9999)Traceback (most recent call last): …ValueError: score must between 0 ~ 100! 1234567但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的： class Student(object): @property def score(self):#变成属性调用读取属性 return self._score @score.setter def score(self, value):#设置属性,使用：@方法名.setter if not isinstance(value, int): raise ValueError(&apos;score must be an integer!&apos;) if value &lt; 0 or value &gt; 100: raise ValueError(&apos;score must between 0 ~ 100!&apos;) self._score = value 12@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： s = Student()s.score = 60 # OK，实际转化为s.set_score(60)s.score # OK，实际转化为s.get_score()60s.score = 9999Traceback (most recent call last): …ValueError: score must between 0 ~ 100!1234注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性： class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth 123456789上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。小结@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。#### 枚举类 from enum import Enum #获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员Month = Enum(‘Month’,(‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’, ‘Jun’, ‘Jul’, ‘Aug’, ‘Sep’, ‘Oct’, ‘Nov’, ‘Dec’))# for name, member in Month.members.items(): print(name, member, member.value)12输出: Jan Month.Jan 1Feb Month.Feb 2Mar Month.Mar 3Apr Month.Apr 4May Month.May 5Jun Month.Jun 6Jul Month.Jul 7Aug Month.Aug 8Sep Month.Sep 9Oct Month.Oct 10Nov Month.Nov 11Dec Month.Dec 1212如果想自己控制枚举的值，可以是使用派生类，继承Enum: from enum import Enum,unique #自定义控制枚举数值，使用派生类，继承Enum@uniqueclass WeekDay(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 #有多种方法可以访问枚举print(WeekDay.Sun)#WeekDay.Sunprint(WeekDay.Tue.value)#2print(WeekDay[‘Wed’])#WeekDay.Wedprint(WeekDay(0))#WeekDay.Sun for name, member in WeekDay.members.items(): print(name, member, member.value)12输出结果: WeekDay.Sun2WeekDay.WedWeekDay.SunSun WeekDay.Sun 0Mon WeekDay.Mon 1Tue WeekDay.Tue 2Wed WeekDay.Wed 3Thu WeekDay.Thu 4Fri WeekDay.Fri 5Sat WeekDay.Sat 6` 元类参考[廖雪峰Python教程]","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"面向对象","slug":"面向对象","permalink":"http://puguojing.com/tags/面向对象/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"}]},{"title":"Python学习笔记-正则表达式","slug":" Python学习笔记-正则表达式","date":"2018-07-20T10:53:48.000Z","updated":"2018-11-05T16:09:35.572Z","comments":true,"path":"2018/07/20/ Python学习笔记-正则表达式/","link":"","permalink":"http://puguojing.com/2018/07/20/ Python学习笔记-正则表达式/","excerpt":"","text":"&#8195;&#8195; 正则表达式1.常用正则表达式符号和语法1、’.’ 匹配所有字符串，除\\n以外2、‘-’ 表示范围[0-9]3、’*‘ 匹配前面的子表达式零次或多次。要匹配 字符，请使用 \\\\。4、’+’ 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +5、’\\^’ 匹配字符串开头6、‘$’ 匹配字符串结尾 re7、’\\’ 转义字符， 使后一个字符改变原来的意思，如果字符串中有字符 ‘ * ‘ 需要匹配，可以使用’ \\* ‘或者字符集[ *] , re.findall(r’3*‘,’3*ds’)结果[‘3‘]8、’\\‘ 匹配前面的字符0次或多次re.findall(“ab*“,”cabc3abcbbac”)结果：[‘ab’, ‘ab’, ‘a’]9、‘?’ 匹配前一个字符串0次或1次 re.findall(‘ab?’,’abcabcabcadf’)结果[‘ab’, ‘ab’, ‘ab’, ‘a’]10、’{m}’ 匹配前一个字符m次 re.findall(‘cb{1}’,’bchbchcbfbcbb’)结果[‘cb’, ‘cb’]11、’{n,m}’ 匹配前一个字符n到m次 re.findall(‘cb{2,3}’,’bchbchcbfbcbb’)结果[‘cbb’]12、’\\d’ 匹配数字，等于[0-9] re.findall(‘\\d’,’电话:10086’)结果[‘1’, ‘0’, ‘0’, ‘8’, ‘6’]13、’\\D’ 匹配非数字，等于[^0-9] re.findall(‘\\D’,’电话:10086’)结果[‘电’, ‘话’, ‘:’]14、’\\w’ 匹配字母和数字，等于[A-Za-z0-9] re.findall(‘\\w’,’alex123,./;;;’)结果[‘a’, ‘l’, ‘e’, ‘x’, ‘1’, ‘2’, ‘3’]15、’\\W’ 匹配非英文字母和数字,等于[^A-Za-z0-9] re.findall(‘\\W’,’alex123,./;;;’)结果[‘,’, ‘.’, ‘/‘, ‘;’, ‘;’, ‘;’]16、’\\s’ 匹配空白字符 re.findall(‘\\s’,’3*ds \\t\\n’)结果[‘ ‘, ‘\\t’, ‘\\n’]17、’\\S’ 匹配非空白字符 re.findall(‘\\s’,’3*ds \\t\\n’)结果[‘3’, ‘*‘, ‘d’, ‘s’]18、’\\A’ 匹配字符串开头19、’\\Z’ 匹配字符串结尾20、’\\b’ 匹配单词的词首和词尾，单词被定义为一个字母数字序列，因此词尾是用空白符或非字母数字符来表示的21、’\\B’ 与\\b相反，只在当前位置不在单词边界时匹配22、’( ?P\\&lt;name>… )’ 分组，除了原有编号外再指定一个额外的别名。 re.search(“(?P\\[0-9]{4})(?P\\[0-9]{2})(?P\\&lt;birthday>[0-9{8})”,”371481199306143242”).groupdict(“city”) 结果{‘province’: ‘3714’, ‘city’: ‘81’, ‘birthday’: ‘19930614’}23、[ ] 是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示相应位置的字符要匹配英文字符和数字。[\\s*]表示空格或者*号。 2.常用的re函数re.match(pattern,string,flags=0)&#8195;&#8195;从字符串的起始位置匹配，如果起始位置匹配不成功的话，match()就返回none re.search(pattern,string,flags=0)&#8195;&#8195;扫描整个字符串并返回第一个成功的匹配 re.findall(pattern,string,flags=0)&#8195;&#8195;找到RE匹配的所有字符串，并把他们作为一个列表返回 re.finditer(pattern, string, flags=0)&#8195;&#8195;找到RE匹配的所有字符串，并把他们作为一个迭代器返回 re.sub(pattern, repl, string, count=0, flags=0)#8195;&#8195;替换匹配到的字符串 re.subn(pattern, repl, string, count=0, flags=0)#8195;&#8195;替换匹配到的字符串,并返回替换数量 未完待续…","categories":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"},{"name":"正则表达式","slug":"python/正则表达式","permalink":"http://puguojing.com/categories/python/正则表达式/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://puguojing.com/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://puguojing.com/tags/正则表达式/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://puguojing.com/categories/python/"},{"name":"正则表达式","slug":"python/正则表达式","permalink":"http://puguojing.com/categories/python/正则表达式/"}]}]}